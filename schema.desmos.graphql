# This file was generated. Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"application_link\""
type application_link {
    application: String!
    "An array relationship"
    application_link_oracle_requests(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): [application_link_oracle_request!]!
    "An aggregate relationship"
    application_link_oracle_requests_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): application_link_oracle_request_aggregate!
    creation_time: timestamp!
    expiration_time: timestamp!
    height: bigint!
    id: Int!
    "An object relationship"
    oracle_request: application_link_oracle_request
    "An object relationship"
    profile: profile!
    result(
        "JSON select path"
        path: String
    ): jsonb
    "An object relationship"
    score: application_link_score!
    state: String!
    user_address: String!
    username: String!
}

"aggregated selection of \"application_link\""
type application_link_aggregate {
    aggregate: application_link_aggregate_fields
    nodes: [application_link!]!
}

"aggregate fields of \"application_link\""
type application_link_aggregate_fields {
    avg: application_link_avg_fields
    count(columns: [application_link_select_column!], distinct: Boolean): Int!
    max: application_link_max_fields
    min: application_link_min_fields
    stddev: application_link_stddev_fields
    stddev_pop: application_link_stddev_pop_fields
    stddev_samp: application_link_stddev_samp_fields
    sum: application_link_sum_fields
    var_pop: application_link_var_pop_fields
    var_samp: application_link_var_samp_fields
    variance: application_link_variance_fields
}

"aggregate avg on columns"
type application_link_avg_fields {
    height: Float
    id: Float
}

"aggregate max on columns"
type application_link_max_fields {
    application: String
    creation_time: timestamp
    expiration_time: timestamp
    height: bigint
    id: Int
    state: String
    user_address: String
    username: String
}

"aggregate min on columns"
type application_link_min_fields {
    application: String
    creation_time: timestamp
    expiration_time: timestamp
    height: bigint
    id: Int
    state: String
    user_address: String
    username: String
}

"response of any mutation on the table \"application_link\""
type application_link_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [application_link!]!
}

"columns and relationships of \"application_link_oracle_request\""
type application_link_oracle_request {
    "An object relationship"
    application_link: application_link!
    application_link_id: bigint!
    call_data(
        "JSON select path"
        path: String
    ): jsonb!
    client_id: String!
    height: bigint!
    id: Int!
    request_id: String!
    script_id: String!
}

"aggregated selection of \"application_link_oracle_request\""
type application_link_oracle_request_aggregate {
    aggregate: application_link_oracle_request_aggregate_fields
    nodes: [application_link_oracle_request!]!
}

"aggregate fields of \"application_link_oracle_request\""
type application_link_oracle_request_aggregate_fields {
    avg: application_link_oracle_request_avg_fields
    count(columns: [application_link_oracle_request_select_column!], distinct: Boolean): Int!
    max: application_link_oracle_request_max_fields
    min: application_link_oracle_request_min_fields
    stddev: application_link_oracle_request_stddev_fields
    stddev_pop: application_link_oracle_request_stddev_pop_fields
    stddev_samp: application_link_oracle_request_stddev_samp_fields
    sum: application_link_oracle_request_sum_fields
    var_pop: application_link_oracle_request_var_pop_fields
    var_samp: application_link_oracle_request_var_samp_fields
    variance: application_link_oracle_request_variance_fields
}

"aggregate avg on columns"
type application_link_oracle_request_avg_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate max on columns"
type application_link_oracle_request_max_fields {
    application_link_id: bigint
    client_id: String
    height: bigint
    id: Int
    request_id: String
    script_id: String
}

"aggregate min on columns"
type application_link_oracle_request_min_fields {
    application_link_id: bigint
    client_id: String
    height: bigint
    id: Int
    request_id: String
    script_id: String
}

"response of any mutation on the table \"application_link_oracle_request\""
type application_link_oracle_request_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [application_link_oracle_request!]!
}

"aggregate stddev on columns"
type application_link_oracle_request_stddev_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type application_link_oracle_request_stddev_pop_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type application_link_oracle_request_stddev_samp_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate sum on columns"
type application_link_oracle_request_sum_fields {
    application_link_id: bigint
    height: bigint
    id: Int
}

"aggregate var_pop on columns"
type application_link_oracle_request_var_pop_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type application_link_oracle_request_var_samp_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"aggregate variance on columns"
type application_link_oracle_request_variance_fields {
    application_link_id: Float
    height: Float
    id: Float
}

"columns and relationships of \"application_link_score\""
type application_link_score {
    "An object relationship"
    application_link: application_link!
    application_link_row_id: bigint!
    details(
        "JSON select path"
        path: String
    ): jsonb!
    id: Int!
    score: Int!
    timestamp: timestamp!
}

"aggregated selection of \"application_link_score\""
type application_link_score_aggregate {
    aggregate: application_link_score_aggregate_fields
    nodes: [application_link_score!]!
}

"aggregate fields of \"application_link_score\""
type application_link_score_aggregate_fields {
    avg: application_link_score_avg_fields
    count(columns: [application_link_score_select_column!], distinct: Boolean): Int!
    max: application_link_score_max_fields
    min: application_link_score_min_fields
    stddev: application_link_score_stddev_fields
    stddev_pop: application_link_score_stddev_pop_fields
    stddev_samp: application_link_score_stddev_samp_fields
    sum: application_link_score_sum_fields
    var_pop: application_link_score_var_pop_fields
    var_samp: application_link_score_var_samp_fields
    variance: application_link_score_variance_fields
}

"aggregate avg on columns"
type application_link_score_avg_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate max on columns"
type application_link_score_max_fields {
    application_link_row_id: bigint
    id: Int
    score: Int
    timestamp: timestamp
}

"aggregate min on columns"
type application_link_score_min_fields {
    application_link_row_id: bigint
    id: Int
    score: Int
    timestamp: timestamp
}

"response of any mutation on the table \"application_link_score\""
type application_link_score_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [application_link_score!]!
}

"aggregate stddev on columns"
type application_link_score_stddev_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate stddev_pop on columns"
type application_link_score_stddev_pop_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate stddev_samp on columns"
type application_link_score_stddev_samp_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate sum on columns"
type application_link_score_sum_fields {
    application_link_row_id: bigint
    id: Int
    score: Int
}

"aggregate var_pop on columns"
type application_link_score_var_pop_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate var_samp on columns"
type application_link_score_var_samp_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate variance on columns"
type application_link_score_variance_fields {
    application_link_row_id: Float
    id: Float
    score: Float
}

"aggregate stddev on columns"
type application_link_stddev_fields {
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type application_link_stddev_pop_fields {
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type application_link_stddev_samp_fields {
    height: Float
    id: Float
}

"aggregate sum on columns"
type application_link_sum_fields {
    height: bigint
    id: Int
}

"aggregate var_pop on columns"
type application_link_var_pop_fields {
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type application_link_var_samp_fields {
    height: Float
    id: Float
}

"aggregate variance on columns"
type application_link_variance_fields {
    height: Float
    id: Float
}

"columns and relationships of \"authz_grant\""
type authz_grant {
    authorization(
        "JSON select path"
        path: String
    ): jsonb!
    expiration: timestamp!
    "An object relationship"
    grantee: profile
    grantee_address: String!
    "An object relationship"
    granter: profile
    granter_address: String!
    height: bigint!
    msg_type_url: String!
}

"aggregated selection of \"authz_grant\""
type authz_grant_aggregate {
    aggregate: authz_grant_aggregate_fields
    nodes: [authz_grant!]!
}

"aggregate fields of \"authz_grant\""
type authz_grant_aggregate_fields {
    avg: authz_grant_avg_fields
    count(columns: [authz_grant_select_column!], distinct: Boolean): Int!
    max: authz_grant_max_fields
    min: authz_grant_min_fields
    stddev: authz_grant_stddev_fields
    stddev_pop: authz_grant_stddev_pop_fields
    stddev_samp: authz_grant_stddev_samp_fields
    sum: authz_grant_sum_fields
    var_pop: authz_grant_var_pop_fields
    var_samp: authz_grant_var_samp_fields
    variance: authz_grant_variance_fields
}

"aggregate avg on columns"
type authz_grant_avg_fields {
    height: Float
}

"aggregate max on columns"
type authz_grant_max_fields {
    expiration: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
    msg_type_url: String
}

"aggregate min on columns"
type authz_grant_min_fields {
    expiration: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
    msg_type_url: String
}

"response of any mutation on the table \"authz_grant\""
type authz_grant_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [authz_grant!]!
}

"aggregate stddev on columns"
type authz_grant_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type authz_grant_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type authz_grant_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type authz_grant_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type authz_grant_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type authz_grant_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type authz_grant_variance_fields {
    height: Float
}

"columns and relationships of \"block\""
type block {
    hash: String!
    height: bigint!
    num_txs: Int
    proposer_address: String
    timestamp: timestamp!
    total_gas: bigint
}

"aggregated selection of \"block\""
type block_aggregate {
    aggregate: block_aggregate_fields
    nodes: [block!]!
}

"aggregate fields of \"block\""
type block_aggregate_fields {
    avg: block_avg_fields
    count(columns: [block_select_column!], distinct: Boolean): Int!
    max: block_max_fields
    min: block_min_fields
    stddev: block_stddev_fields
    stddev_pop: block_stddev_pop_fields
    stddev_samp: block_stddev_samp_fields
    sum: block_sum_fields
    var_pop: block_var_pop_fields
    var_samp: block_var_samp_fields
    variance: block_variance_fields
}

"aggregate avg on columns"
type block_avg_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate max on columns"
type block_max_fields {
    hash: String
    height: bigint
    num_txs: Int
    proposer_address: String
    timestamp: timestamp
    total_gas: bigint
}

"aggregate min on columns"
type block_min_fields {
    hash: String
    height: bigint
    num_txs: Int
    proposer_address: String
    timestamp: timestamp
    total_gas: bigint
}

"response of any mutation on the table \"block\""
type block_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [block!]!
}

"aggregate stddev on columns"
type block_stddev_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate stddev_pop on columns"
type block_stddev_pop_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate stddev_samp on columns"
type block_stddev_samp_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate sum on columns"
type block_sum_fields {
    height: bigint
    num_txs: Int
    total_gas: bigint
}

"aggregate var_pop on columns"
type block_var_pop_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate var_samp on columns"
type block_var_samp_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"aggregate variance on columns"
type block_variance_fields {
    height: Float
    num_txs: Float
    total_gas: Float
}

"columns and relationships of \"chain_link\""
type chain_link {
    "An object relationship"
    chain_config: chain_link_chain_config!
    chain_config_id: bigint!
    "An array relationship"
    chain_link_proofs(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): [chain_link_proof!]!
    "An aggregate relationship"
    chain_link_proofs_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): chain_link_proof_aggregate!
    creation_time: timestamp!
    "An array relationship"
    default_chain_links(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): [default_chain_link!]!
    "An aggregate relationship"
    default_chain_links_aggregate(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): default_chain_link_aggregate!
    external_address: String!
    height: bigint!
    id: Int!
    "An object relationship"
    profile: profile!
    "An object relationship"
    proof: chain_link_proof
    user_address: String!
}

"aggregated selection of \"chain_link\""
type chain_link_aggregate {
    aggregate: chain_link_aggregate_fields
    nodes: [chain_link!]!
}

"aggregate fields of \"chain_link\""
type chain_link_aggregate_fields {
    avg: chain_link_avg_fields
    count(columns: [chain_link_select_column!], distinct: Boolean): Int!
    max: chain_link_max_fields
    min: chain_link_min_fields
    stddev: chain_link_stddev_fields
    stddev_pop: chain_link_stddev_pop_fields
    stddev_samp: chain_link_stddev_samp_fields
    sum: chain_link_sum_fields
    var_pop: chain_link_var_pop_fields
    var_samp: chain_link_var_samp_fields
    variance: chain_link_variance_fields
}

"aggregate avg on columns"
type chain_link_avg_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"columns and relationships of \"chain_link_chain_config\""
type chain_link_chain_config {
    "An array relationship"
    chain_links(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): [chain_link!]!
    "An aggregate relationship"
    chain_links_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): chain_link_aggregate!
    "An array relationship"
    default_chain_links(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): [default_chain_link!]!
    "An aggregate relationship"
    default_chain_links_aggregate(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): default_chain_link_aggregate!
    id: Int!
    name: String!
}

"aggregated selection of \"chain_link_chain_config\""
type chain_link_chain_config_aggregate {
    aggregate: chain_link_chain_config_aggregate_fields
    nodes: [chain_link_chain_config!]!
}

"aggregate fields of \"chain_link_chain_config\""
type chain_link_chain_config_aggregate_fields {
    avg: chain_link_chain_config_avg_fields
    count(columns: [chain_link_chain_config_select_column!], distinct: Boolean): Int!
    max: chain_link_chain_config_max_fields
    min: chain_link_chain_config_min_fields
    stddev: chain_link_chain_config_stddev_fields
    stddev_pop: chain_link_chain_config_stddev_pop_fields
    stddev_samp: chain_link_chain_config_stddev_samp_fields
    sum: chain_link_chain_config_sum_fields
    var_pop: chain_link_chain_config_var_pop_fields
    var_samp: chain_link_chain_config_var_samp_fields
    variance: chain_link_chain_config_variance_fields
}

"aggregate avg on columns"
type chain_link_chain_config_avg_fields {
    id: Float
}

"aggregate max on columns"
type chain_link_chain_config_max_fields {
    id: Int
    name: String
}

"aggregate min on columns"
type chain_link_chain_config_min_fields {
    id: Int
    name: String
}

"response of any mutation on the table \"chain_link_chain_config\""
type chain_link_chain_config_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [chain_link_chain_config!]!
}

"aggregate stddev on columns"
type chain_link_chain_config_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type chain_link_chain_config_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type chain_link_chain_config_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type chain_link_chain_config_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type chain_link_chain_config_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type chain_link_chain_config_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type chain_link_chain_config_variance_fields {
    id: Float
}

"aggregate max on columns"
type chain_link_max_fields {
    chain_config_id: bigint
    creation_time: timestamp
    external_address: String
    height: bigint
    id: Int
    user_address: String
}

"aggregate min on columns"
type chain_link_min_fields {
    chain_config_id: bigint
    creation_time: timestamp
    external_address: String
    height: bigint
    id: Int
    user_address: String
}

"response of any mutation on the table \"chain_link\""
type chain_link_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [chain_link!]!
}

"columns and relationships of \"chain_link_proof\""
type chain_link_proof {
    "An object relationship"
    chain_link: chain_link!
    chain_link_id: bigint!
    height: bigint!
    id: Int!
    plain_text: String!
    public_key(
        "JSON select path"
        path: String
    ): jsonb!
    signature: String!
}

"aggregated selection of \"chain_link_proof\""
type chain_link_proof_aggregate {
    aggregate: chain_link_proof_aggregate_fields
    nodes: [chain_link_proof!]!
}

"aggregate fields of \"chain_link_proof\""
type chain_link_proof_aggregate_fields {
    avg: chain_link_proof_avg_fields
    count(columns: [chain_link_proof_select_column!], distinct: Boolean): Int!
    max: chain_link_proof_max_fields
    min: chain_link_proof_min_fields
    stddev: chain_link_proof_stddev_fields
    stddev_pop: chain_link_proof_stddev_pop_fields
    stddev_samp: chain_link_proof_stddev_samp_fields
    sum: chain_link_proof_sum_fields
    var_pop: chain_link_proof_var_pop_fields
    var_samp: chain_link_proof_var_samp_fields
    variance: chain_link_proof_variance_fields
}

"aggregate avg on columns"
type chain_link_proof_avg_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate max on columns"
type chain_link_proof_max_fields {
    chain_link_id: bigint
    height: bigint
    id: Int
    plain_text: String
    signature: String
}

"aggregate min on columns"
type chain_link_proof_min_fields {
    chain_link_id: bigint
    height: bigint
    id: Int
    plain_text: String
    signature: String
}

"response of any mutation on the table \"chain_link_proof\""
type chain_link_proof_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [chain_link_proof!]!
}

"aggregate stddev on columns"
type chain_link_proof_stddev_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type chain_link_proof_stddev_pop_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type chain_link_proof_stddev_samp_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate sum on columns"
type chain_link_proof_sum_fields {
    chain_link_id: bigint
    height: bigint
    id: Int
}

"aggregate var_pop on columns"
type chain_link_proof_var_pop_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type chain_link_proof_var_samp_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate variance on columns"
type chain_link_proof_variance_fields {
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev on columns"
type chain_link_stddev_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type chain_link_stddev_pop_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type chain_link_stddev_samp_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"aggregate sum on columns"
type chain_link_sum_fields {
    chain_config_id: bigint
    height: bigint
    id: Int
}

"aggregate var_pop on columns"
type chain_link_var_pop_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type chain_link_var_samp_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"aggregate variance on columns"
type chain_link_variance_fields {
    chain_config_id: Float
    height: Float
    id: Float
}

"columns and relationships of \"contract\""
type contract {
    address: String!
    config(
        "JSON select path"
        path: String
    ): jsonb
    height: bigint!
    type: String!
}

"aggregated selection of \"contract\""
type contract_aggregate {
    aggregate: contract_aggregate_fields
    nodes: [contract!]!
}

"aggregate fields of \"contract\""
type contract_aggregate_fields {
    avg: contract_avg_fields
    count(columns: [contract_select_column!], distinct: Boolean): Int!
    max: contract_max_fields
    min: contract_min_fields
    stddev: contract_stddev_fields
    stddev_pop: contract_stddev_pop_fields
    stddev_samp: contract_stddev_samp_fields
    sum: contract_sum_fields
    var_pop: contract_var_pop_fields
    var_samp: contract_var_samp_fields
    variance: contract_variance_fields
}

"aggregate avg on columns"
type contract_avg_fields {
    height: Float
}

"aggregate max on columns"
type contract_max_fields {
    address: String
    height: bigint
    type: String
}

"aggregate min on columns"
type contract_min_fields {
    address: String
    height: bigint
    type: String
}

"response of any mutation on the table \"contract\""
type contract_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [contract!]!
}

"aggregate stddev on columns"
type contract_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type contract_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type contract_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type contract_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type contract_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type contract_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type contract_variance_fields {
    height: Float
}

"columns and relationships of \"default_chain_link\""
type default_chain_link {
    "An object relationship"
    chain_config: chain_link_chain_config!
    chain_config_id: bigint!
    "An object relationship"
    chain_link: chain_link!
    chain_link_id: bigint!
    height: bigint!
    id: Int!
    user_address: String!
}

"aggregated selection of \"default_chain_link\""
type default_chain_link_aggregate {
    aggregate: default_chain_link_aggregate_fields
    nodes: [default_chain_link!]!
}

"aggregate fields of \"default_chain_link\""
type default_chain_link_aggregate_fields {
    avg: default_chain_link_avg_fields
    count(columns: [default_chain_link_select_column!], distinct: Boolean): Int!
    max: default_chain_link_max_fields
    min: default_chain_link_min_fields
    stddev: default_chain_link_stddev_fields
    stddev_pop: default_chain_link_stddev_pop_fields
    stddev_samp: default_chain_link_stddev_samp_fields
    sum: default_chain_link_sum_fields
    var_pop: default_chain_link_var_pop_fields
    var_samp: default_chain_link_var_samp_fields
    variance: default_chain_link_variance_fields
}

"aggregate avg on columns"
type default_chain_link_avg_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate max on columns"
type default_chain_link_max_fields {
    chain_config_id: bigint
    chain_link_id: bigint
    height: bigint
    id: Int
    user_address: String
}

"aggregate min on columns"
type default_chain_link_min_fields {
    chain_config_id: bigint
    chain_link_id: bigint
    height: bigint
    id: Int
    user_address: String
}

"response of any mutation on the table \"default_chain_link\""
type default_chain_link_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [default_chain_link!]!
}

"aggregate stddev on columns"
type default_chain_link_stddev_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type default_chain_link_stddev_pop_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type default_chain_link_stddev_samp_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate sum on columns"
type default_chain_link_sum_fields {
    chain_config_id: bigint
    chain_link_id: bigint
    height: bigint
    id: Int
}

"aggregate var_pop on columns"
type default_chain_link_var_pop_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type default_chain_link_var_samp_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"aggregate variance on columns"
type default_chain_link_variance_fields {
    chain_config_id: Float
    chain_link_id: Float
    height: Float
    id: Float
}

"columns and relationships of \"dtag_transfer_requests\""
type dtag_transfer_requests {
    height: bigint!
    "An object relationship"
    profile: profile!
    "An object relationship"
    profileBySenderAddress: profile!
    receiver_address: String!
    sender_address: String!
}

"aggregated selection of \"dtag_transfer_requests\""
type dtag_transfer_requests_aggregate {
    aggregate: dtag_transfer_requests_aggregate_fields
    nodes: [dtag_transfer_requests!]!
}

"aggregate fields of \"dtag_transfer_requests\""
type dtag_transfer_requests_aggregate_fields {
    avg: dtag_transfer_requests_avg_fields
    count(columns: [dtag_transfer_requests_select_column!], distinct: Boolean): Int!
    max: dtag_transfer_requests_max_fields
    min: dtag_transfer_requests_min_fields
    stddev: dtag_transfer_requests_stddev_fields
    stddev_pop: dtag_transfer_requests_stddev_pop_fields
    stddev_samp: dtag_transfer_requests_stddev_samp_fields
    sum: dtag_transfer_requests_sum_fields
    var_pop: dtag_transfer_requests_var_pop_fields
    var_samp: dtag_transfer_requests_var_samp_fields
    variance: dtag_transfer_requests_variance_fields
}

"aggregate avg on columns"
type dtag_transfer_requests_avg_fields {
    height: Float
}

"aggregate max on columns"
type dtag_transfer_requests_max_fields {
    height: bigint
    receiver_address: String
    sender_address: String
}

"aggregate min on columns"
type dtag_transfer_requests_min_fields {
    height: bigint
    receiver_address: String
    sender_address: String
}

"response of any mutation on the table \"dtag_transfer_requests\""
type dtag_transfer_requests_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [dtag_transfer_requests!]!
}

"aggregate stddev on columns"
type dtag_transfer_requests_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type dtag_transfer_requests_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type dtag_transfer_requests_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type dtag_transfer_requests_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type dtag_transfer_requests_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type dtag_transfer_requests_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type dtag_transfer_requests_variance_fields {
    height: Float
}

"columns and relationships of \"fee_grant\""
type fee_grant {
    allowance(
        "JSON select path"
        path: String
    ): jsonb!
    expiration_date: timestamp
    "An object relationship"
    grantee: profile
    grantee_address: String!
    "An object relationship"
    granter: profile
    granter_address: String!
    height: bigint!
    spend_limit: _coin
}

"aggregated selection of \"fee_grant\""
type fee_grant_aggregate {
    aggregate: fee_grant_aggregate_fields
    nodes: [fee_grant!]!
}

"aggregate fields of \"fee_grant\""
type fee_grant_aggregate_fields {
    avg: fee_grant_avg_fields
    count(columns: [fee_grant_select_column!], distinct: Boolean): Int!
    max: fee_grant_max_fields
    min: fee_grant_min_fields
    stddev: fee_grant_stddev_fields
    stddev_pop: fee_grant_stddev_pop_fields
    stddev_samp: fee_grant_stddev_samp_fields
    sum: fee_grant_sum_fields
    var_pop: fee_grant_var_pop_fields
    var_samp: fee_grant_var_samp_fields
    variance: fee_grant_variance_fields
}

"aggregate avg on columns"
type fee_grant_avg_fields {
    height: Float
}

"aggregate max on columns"
type fee_grant_max_fields {
    expiration_date: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
}

"aggregate min on columns"
type fee_grant_min_fields {
    expiration_date: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
}

"response of any mutation on the table \"fee_grant\""
type fee_grant_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [fee_grant!]!
}

"aggregate stddev on columns"
type fee_grant_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type fee_grant_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type fee_grant_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type fee_grant_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type fee_grant_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type fee_grant_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type fee_grant_variance_fields {
    height: Float
}

"columns and relationships of \"fees_params\""
type fees_params {
    height: bigint!
    one_row_id: Boolean!
    params(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"fees_params\""
type fees_params_aggregate {
    aggregate: fees_params_aggregate_fields
    nodes: [fees_params!]!
}

"aggregate fields of \"fees_params\""
type fees_params_aggregate_fields {
    avg: fees_params_avg_fields
    count(columns: [fees_params_select_column!], distinct: Boolean): Int!
    max: fees_params_max_fields
    min: fees_params_min_fields
    stddev: fees_params_stddev_fields
    stddev_pop: fees_params_stddev_pop_fields
    stddev_samp: fees_params_stddev_samp_fields
    sum: fees_params_sum_fields
    var_pop: fees_params_var_pop_fields
    var_samp: fees_params_var_samp_fields
    variance: fees_params_variance_fields
}

"aggregate avg on columns"
type fees_params_avg_fields {
    height: Float
}

"aggregate max on columns"
type fees_params_max_fields {
    height: bigint
}

"aggregate min on columns"
type fees_params_min_fields {
    height: bigint
}

"response of any mutation on the table \"fees_params\""
type fees_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [fees_params!]!
}

"aggregate stddev on columns"
type fees_params_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type fees_params_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type fees_params_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type fees_params_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type fees_params_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type fees_params_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type fees_params_variance_fields {
    height: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"application_link\""
    delete_application_link(
        "filter the rows which have to be deleted"
        where: application_link_bool_exp!
    ): application_link_mutation_response
    "delete single row from the table: \"application_link\""
    delete_application_link_by_pk(id: Int!): application_link
    "delete data from the table: \"application_link_oracle_request\""
    delete_application_link_oracle_request(
        "filter the rows which have to be deleted"
        where: application_link_oracle_request_bool_exp!
    ): application_link_oracle_request_mutation_response
    "delete single row from the table: \"application_link_oracle_request\""
    delete_application_link_oracle_request_by_pk(id: Int!): application_link_oracle_request
    "delete data from the table: \"application_link_score\""
    delete_application_link_score(
        "filter the rows which have to be deleted"
        where: application_link_score_bool_exp!
    ): application_link_score_mutation_response
    "delete data from the table: \"authz_grant\""
    delete_authz_grant(
        "filter the rows which have to be deleted"
        where: authz_grant_bool_exp!
    ): authz_grant_mutation_response
    "delete data from the table: \"block\""
    delete_block(
        "filter the rows which have to be deleted"
        where: block_bool_exp!
    ): block_mutation_response
    "delete single row from the table: \"block\""
    delete_block_by_pk(height: bigint!): block
    "delete data from the table: \"chain_link\""
    delete_chain_link(
        "filter the rows which have to be deleted"
        where: chain_link_bool_exp!
    ): chain_link_mutation_response
    "delete single row from the table: \"chain_link\""
    delete_chain_link_by_pk(id: Int!): chain_link
    "delete data from the table: \"chain_link_chain_config\""
    delete_chain_link_chain_config(
        "filter the rows which have to be deleted"
        where: chain_link_chain_config_bool_exp!
    ): chain_link_chain_config_mutation_response
    "delete single row from the table: \"chain_link_chain_config\""
    delete_chain_link_chain_config_by_pk(id: Int!): chain_link_chain_config
    "delete data from the table: \"chain_link_proof\""
    delete_chain_link_proof(
        "filter the rows which have to be deleted"
        where: chain_link_proof_bool_exp!
    ): chain_link_proof_mutation_response
    "delete data from the table: \"contract\""
    delete_contract(
        "filter the rows which have to be deleted"
        where: contract_bool_exp!
    ): contract_mutation_response
    "delete single row from the table: \"contract\""
    delete_contract_by_pk(address: String!): contract
    "delete data from the table: \"default_chain_link\""
    delete_default_chain_link(
        "filter the rows which have to be deleted"
        where: default_chain_link_bool_exp!
    ): default_chain_link_mutation_response
    "delete single row from the table: \"default_chain_link\""
    delete_default_chain_link_by_pk(id: Int!): default_chain_link
    "delete data from the table: \"dtag_transfer_requests\""
    delete_dtag_transfer_requests(
        "filter the rows which have to be deleted"
        where: dtag_transfer_requests_bool_exp!
    ): dtag_transfer_requests_mutation_response
    "delete data from the table: \"fee_grant\""
    delete_fee_grant(
        "filter the rows which have to be deleted"
        where: fee_grant_bool_exp!
    ): fee_grant_mutation_response
    "delete data from the table: \"fees_params\""
    delete_fees_params(
        "filter the rows which have to be deleted"
        where: fees_params_bool_exp!
    ): fees_params_mutation_response
    "delete single row from the table: \"fees_params\""
    delete_fees_params_by_pk(one_row_id: Boolean!): fees_params
    "delete data from the table: \"notification\""
    delete_notification(
        "filter the rows which have to be deleted"
        where: notification_bool_exp!
    ): notification_mutation_response
    "delete data from the table: \"poll_answer\""
    delete_poll_answer(
        "filter the rows which have to be deleted"
        where: poll_answer_bool_exp!
    ): poll_answer_mutation_response
    "delete single row from the table: \"poll_answer\""
    delete_poll_answer_by_pk(row_id: Int!): poll_answer
    "delete data from the table: \"post\""
    delete_post(
        "filter the rows which have to be deleted"
        where: post_bool_exp!
    ): post_mutation_response
    "delete data from the table: \"post_attachment\""
    delete_post_attachment(
        "filter the rows which have to be deleted"
        where: post_attachment_bool_exp!
    ): post_attachment_mutation_response
    "delete single row from the table: \"post_attachment\""
    delete_post_attachment_by_pk(row_id: Int!): post_attachment
    "delete single row from the table: \"post\""
    delete_post_by_pk(row_id: Int!): post
    "delete data from the table: \"post_hashtag\""
    delete_post_hashtag(
        "filter the rows which have to be deleted"
        where: post_hashtag_bool_exp!
    ): post_hashtag_mutation_response
    "delete single row from the table: \"post_hashtag\""
    delete_post_hashtag_by_pk(row_id: Int!): post_hashtag
    "delete data from the table: \"post_mention\""
    delete_post_mention(
        "filter the rows which have to be deleted"
        where: post_mention_bool_exp!
    ): post_mention_mutation_response
    "delete single row from the table: \"post_mention\""
    delete_post_mention_by_pk(row_id: Int!): post_mention
    "delete data from the table: \"post_reference\""
    delete_post_reference(
        "filter the rows which have to be deleted"
        where: post_reference_bool_exp!
    ): post_reference_mutation_response
    "delete single row from the table: \"post_reference\""
    delete_post_reference_by_pk(row_id: Int!): post_reference
    "delete data from the table: \"post_tag\""
    delete_post_tag(
        "filter the rows which have to be deleted"
        where: post_tag_bool_exp!
    ): post_tag_mutation_response
    "delete single row from the table: \"post_tag\""
    delete_post_tag_by_pk(row_id: Int!): post_tag
    "delete data from the table: \"post_transaction\""
    delete_post_transaction(
        "filter the rows which have to be deleted"
        where: post_transaction_bool_exp!
    ): post_transaction_mutation_response
    "delete single row from the table: \"post_transaction\""
    delete_post_transaction_by_pk(row_id: Int!): post_transaction
    "delete data from the table: \"post_url\""
    delete_post_url(
        "filter the rows which have to be deleted"
        where: post_url_bool_exp!
    ): post_url_mutation_response
    "delete single row from the table: \"post_url\""
    delete_post_url_by_pk(row_id: Int!): post_url
    "delete data from the table: \"posts_params\""
    delete_posts_params(
        "filter the rows which have to be deleted"
        where: posts_params_bool_exp!
    ): posts_params_mutation_response
    "delete single row from the table: \"posts_params\""
    delete_posts_params_by_pk(one_row_id: Boolean!): posts_params
    "delete data from the table: \"profile\""
    delete_profile(
        "filter the rows which have to be deleted"
        where: profile_bool_exp!
    ): profile_mutation_response
    "delete single row from the table: \"profile\""
    delete_profile_by_pk(address: String!): profile
    "delete data from the table: \"profiles_params\""
    delete_profiles_params(
        "filter the rows which have to be deleted"
        where: profiles_params_bool_exp!
    ): profiles_params_mutation_response
    "delete single row from the table: \"profiles_params\""
    delete_profiles_params_by_pk(one_row_id: Boolean!): profiles_params
    "delete data from the table: \"reaction\""
    delete_reaction(
        "filter the rows which have to be deleted"
        where: reaction_bool_exp!
    ): reaction_mutation_response
    "delete single row from the table: \"reaction\""
    delete_reaction_by_pk(row_id: Int!): reaction
    "delete data from the table: \"report\""
    delete_report(
        "filter the rows which have to be deleted"
        where: report_bool_exp!
    ): report_mutation_response
    "delete single row from the table: \"report\""
    delete_report_by_pk(row_id: Int!): report
    "delete data from the table: \"report_reason\""
    delete_report_reason(
        "filter the rows which have to be deleted"
        where: report_reason_bool_exp!
    ): report_reason_mutation_response
    "delete data from the table: \"reports_params\""
    delete_reports_params(
        "filter the rows which have to be deleted"
        where: reports_params_bool_exp!
    ): reports_params_mutation_response
    "delete single row from the table: \"reports_params\""
    delete_reports_params_by_pk(one_row_id: Boolean!): reports_params
    "delete data from the table: \"subspace\""
    delete_subspace(
        "filter the rows which have to be deleted"
        where: subspace_bool_exp!
    ): subspace_mutation_response
    "delete single row from the table: \"subspace\""
    delete_subspace_by_pk(id: bigint!): subspace
    "delete data from the table: \"subspace_free_text_params\""
    delete_subspace_free_text_params(
        "filter the rows which have to be deleted"
        where: subspace_free_text_params_bool_exp!
    ): subspace_free_text_params_mutation_response
    "delete single row from the table: \"subspace_free_text_params\""
    delete_subspace_free_text_params_by_pk(subspace_id: bigint!): subspace_free_text_params
    "delete data from the table: \"subspace_registered_reaction\""
    delete_subspace_registered_reaction(
        "filter the rows which have to be deleted"
        where: subspace_registered_reaction_bool_exp!
    ): subspace_registered_reaction_mutation_response
    "delete single row from the table: \"subspace_registered_reaction\""
    delete_subspace_registered_reaction_by_pk(row_id: Int!): subspace_registered_reaction
    "delete data from the table: \"subspace_registered_reaction_params\""
    delete_subspace_registered_reaction_params(
        "filter the rows which have to be deleted"
        where: subspace_registered_reaction_params_bool_exp!
    ): subspace_registered_reaction_params_mutation_response
    "delete single row from the table: \"subspace_registered_reaction_params\""
    delete_subspace_registered_reaction_params_by_pk(subspace_id: bigint!): subspace_registered_reaction_params
    "delete data from the table: \"subspace_report_reason\""
    delete_subspace_report_reason(
        "filter the rows which have to be deleted"
        where: subspace_report_reason_bool_exp!
    ): subspace_report_reason_mutation_response
    "delete single row from the table: \"subspace_report_reason\""
    delete_subspace_report_reason_by_pk(row_id: Int!): subspace_report_reason
    "delete data from the table: \"subspace_section\""
    delete_subspace_section(
        "filter the rows which have to be deleted"
        where: subspace_section_bool_exp!
    ): subspace_section_mutation_response
    "delete single row from the table: \"subspace_section\""
    delete_subspace_section_by_pk(row_id: Int!): subspace_section
    "delete data from the table: \"subspace_user_group\""
    delete_subspace_user_group(
        "filter the rows which have to be deleted"
        where: subspace_user_group_bool_exp!
    ): subspace_user_group_mutation_response
    "delete single row from the table: \"subspace_user_group\""
    delete_subspace_user_group_by_pk(row_id: Int!): subspace_user_group
    "delete data from the table: \"subspace_user_group_member\""
    delete_subspace_user_group_member(
        "filter the rows which have to be deleted"
        where: subspace_user_group_member_bool_exp!
    ): subspace_user_group_member_mutation_response
    "delete data from the table: \"subspace_user_permission\""
    delete_subspace_user_permission(
        "filter the rows which have to be deleted"
        where: subspace_user_permission_bool_exp!
    ): subspace_user_permission_mutation_response
    "delete single row from the table: \"subspace_user_permission\""
    delete_subspace_user_permission_by_pk(row_id: Int!): subspace_user_permission
    "delete data from the table: \"tip_post\""
    delete_tip_post(
        "filter the rows which have to be deleted"
        where: tip_post_bool_exp!
    ): tip_post_mutation_response
    "delete data from the table: \"tip_user\""
    delete_tip_user(
        "filter the rows which have to be deleted"
        where: tip_user_bool_exp!
    ): tip_user_mutation_response
    "delete data from the table: \"user_block\""
    delete_user_block(
        "filter the rows which have to be deleted"
        where: user_block_bool_exp!
    ): user_block_mutation_response
    "delete data from the table: \"user_relationship\""
    delete_user_relationship(
        "filter the rows which have to be deleted"
        where: user_relationship_bool_exp!
    ): user_relationship_mutation_response
    "insert data into the table: \"application_link\""
    insert_application_link(
        "the rows to be inserted"
        objects: [application_link_insert_input!]!,
        "on conflict condition"
        on_conflict: application_link_on_conflict
    ): application_link_mutation_response
    "insert a single row into the table: \"application_link\""
    insert_application_link_one(
        "the row to be inserted"
        object: application_link_insert_input!,
        "on conflict condition"
        on_conflict: application_link_on_conflict
    ): application_link
    "insert data into the table: \"application_link_oracle_request\""
    insert_application_link_oracle_request(
        "the rows to be inserted"
        objects: [application_link_oracle_request_insert_input!]!,
        "on conflict condition"
        on_conflict: application_link_oracle_request_on_conflict
    ): application_link_oracle_request_mutation_response
    "insert a single row into the table: \"application_link_oracle_request\""
    insert_application_link_oracle_request_one(
        "the row to be inserted"
        object: application_link_oracle_request_insert_input!,
        "on conflict condition"
        on_conflict: application_link_oracle_request_on_conflict
    ): application_link_oracle_request
    "insert data into the table: \"application_link_score\""
    insert_application_link_score(
        "the rows to be inserted"
        objects: [application_link_score_insert_input!]!,
        "on conflict condition"
        on_conflict: application_link_score_on_conflict
    ): application_link_score_mutation_response
    "insert a single row into the table: \"application_link_score\""
    insert_application_link_score_one(
        "the row to be inserted"
        object: application_link_score_insert_input!,
        "on conflict condition"
        on_conflict: application_link_score_on_conflict
    ): application_link_score
    "insert data into the table: \"authz_grant\""
    insert_authz_grant(
        "the rows to be inserted"
        objects: [authz_grant_insert_input!]!,
        "on conflict condition"
        on_conflict: authz_grant_on_conflict
    ): authz_grant_mutation_response
    "insert a single row into the table: \"authz_grant\""
    insert_authz_grant_one(
        "the row to be inserted"
        object: authz_grant_insert_input!,
        "on conflict condition"
        on_conflict: authz_grant_on_conflict
    ): authz_grant
    "insert data into the table: \"block\""
    insert_block(
        "the rows to be inserted"
        objects: [block_insert_input!]!,
        "on conflict condition"
        on_conflict: block_on_conflict
    ): block_mutation_response
    "insert a single row into the table: \"block\""
    insert_block_one(
        "the row to be inserted"
        object: block_insert_input!,
        "on conflict condition"
        on_conflict: block_on_conflict
    ): block
    "insert data into the table: \"chain_link\""
    insert_chain_link(
        "the rows to be inserted"
        objects: [chain_link_insert_input!]!,
        "on conflict condition"
        on_conflict: chain_link_on_conflict
    ): chain_link_mutation_response
    "insert data into the table: \"chain_link_chain_config\""
    insert_chain_link_chain_config(
        "the rows to be inserted"
        objects: [chain_link_chain_config_insert_input!]!,
        "on conflict condition"
        on_conflict: chain_link_chain_config_on_conflict
    ): chain_link_chain_config_mutation_response
    "insert a single row into the table: \"chain_link_chain_config\""
    insert_chain_link_chain_config_one(
        "the row to be inserted"
        object: chain_link_chain_config_insert_input!,
        "on conflict condition"
        on_conflict: chain_link_chain_config_on_conflict
    ): chain_link_chain_config
    "insert a single row into the table: \"chain_link\""
    insert_chain_link_one(
        "the row to be inserted"
        object: chain_link_insert_input!,
        "on conflict condition"
        on_conflict: chain_link_on_conflict
    ): chain_link
    "insert data into the table: \"chain_link_proof\""
    insert_chain_link_proof(
        "the rows to be inserted"
        objects: [chain_link_proof_insert_input!]!,
        "on conflict condition"
        on_conflict: chain_link_proof_on_conflict
    ): chain_link_proof_mutation_response
    "insert a single row into the table: \"chain_link_proof\""
    insert_chain_link_proof_one(
        "the row to be inserted"
        object: chain_link_proof_insert_input!,
        "on conflict condition"
        on_conflict: chain_link_proof_on_conflict
    ): chain_link_proof
    "insert data into the table: \"contract\""
    insert_contract(
        "the rows to be inserted"
        objects: [contract_insert_input!]!,
        "on conflict condition"
        on_conflict: contract_on_conflict
    ): contract_mutation_response
    "insert a single row into the table: \"contract\""
    insert_contract_one(
        "the row to be inserted"
        object: contract_insert_input!,
        "on conflict condition"
        on_conflict: contract_on_conflict
    ): contract
    "insert data into the table: \"default_chain_link\""
    insert_default_chain_link(
        "the rows to be inserted"
        objects: [default_chain_link_insert_input!]!,
        "on conflict condition"
        on_conflict: default_chain_link_on_conflict
    ): default_chain_link_mutation_response
    "insert a single row into the table: \"default_chain_link\""
    insert_default_chain_link_one(
        "the row to be inserted"
        object: default_chain_link_insert_input!,
        "on conflict condition"
        on_conflict: default_chain_link_on_conflict
    ): default_chain_link
    "insert data into the table: \"dtag_transfer_requests\""
    insert_dtag_transfer_requests(
        "the rows to be inserted"
        objects: [dtag_transfer_requests_insert_input!]!,
        "on conflict condition"
        on_conflict: dtag_transfer_requests_on_conflict
    ): dtag_transfer_requests_mutation_response
    "insert a single row into the table: \"dtag_transfer_requests\""
    insert_dtag_transfer_requests_one(
        "the row to be inserted"
        object: dtag_transfer_requests_insert_input!,
        "on conflict condition"
        on_conflict: dtag_transfer_requests_on_conflict
    ): dtag_transfer_requests
    "insert data into the table: \"fee_grant\""
    insert_fee_grant(
        "the rows to be inserted"
        objects: [fee_grant_insert_input!]!,
        "on conflict condition"
        on_conflict: fee_grant_on_conflict
    ): fee_grant_mutation_response
    "insert a single row into the table: \"fee_grant\""
    insert_fee_grant_one(
        "the row to be inserted"
        object: fee_grant_insert_input!,
        "on conflict condition"
        on_conflict: fee_grant_on_conflict
    ): fee_grant
    "insert data into the table: \"fees_params\""
    insert_fees_params(
        "the rows to be inserted"
        objects: [fees_params_insert_input!]!,
        "on conflict condition"
        on_conflict: fees_params_on_conflict
    ): fees_params_mutation_response
    "insert a single row into the table: \"fees_params\""
    insert_fees_params_one(
        "the row to be inserted"
        object: fees_params_insert_input!,
        "on conflict condition"
        on_conflict: fees_params_on_conflict
    ): fees_params
    "insert data into the table: \"notification\""
    insert_notification(
        "the rows to be inserted"
        objects: [notification_insert_input!]!,
        "on conflict condition"
        on_conflict: notification_on_conflict
    ): notification_mutation_response
    "insert a single row into the table: \"notification\""
    insert_notification_one(
        "the row to be inserted"
        object: notification_insert_input!,
        "on conflict condition"
        on_conflict: notification_on_conflict
    ): notification
    "insert data into the table: \"poll_answer\""
    insert_poll_answer(
        "the rows to be inserted"
        objects: [poll_answer_insert_input!]!,
        "on conflict condition"
        on_conflict: poll_answer_on_conflict
    ): poll_answer_mutation_response
    "insert a single row into the table: \"poll_answer\""
    insert_poll_answer_one(
        "the row to be inserted"
        object: poll_answer_insert_input!,
        "on conflict condition"
        on_conflict: poll_answer_on_conflict
    ): poll_answer
    "insert data into the table: \"post\""
    insert_post(
        "the rows to be inserted"
        objects: [post_insert_input!]!,
        "on conflict condition"
        on_conflict: post_on_conflict
    ): post_mutation_response
    "insert data into the table: \"post_attachment\""
    insert_post_attachment(
        "the rows to be inserted"
        objects: [post_attachment_insert_input!]!,
        "on conflict condition"
        on_conflict: post_attachment_on_conflict
    ): post_attachment_mutation_response
    "insert a single row into the table: \"post_attachment\""
    insert_post_attachment_one(
        "the row to be inserted"
        object: post_attachment_insert_input!,
        "on conflict condition"
        on_conflict: post_attachment_on_conflict
    ): post_attachment
    "insert data into the table: \"post_hashtag\""
    insert_post_hashtag(
        "the rows to be inserted"
        objects: [post_hashtag_insert_input!]!,
        "on conflict condition"
        on_conflict: post_hashtag_on_conflict
    ): post_hashtag_mutation_response
    "insert a single row into the table: \"post_hashtag\""
    insert_post_hashtag_one(
        "the row to be inserted"
        object: post_hashtag_insert_input!,
        "on conflict condition"
        on_conflict: post_hashtag_on_conflict
    ): post_hashtag
    "insert data into the table: \"post_mention\""
    insert_post_mention(
        "the rows to be inserted"
        objects: [post_mention_insert_input!]!,
        "on conflict condition"
        on_conflict: post_mention_on_conflict
    ): post_mention_mutation_response
    "insert a single row into the table: \"post_mention\""
    insert_post_mention_one(
        "the row to be inserted"
        object: post_mention_insert_input!,
        "on conflict condition"
        on_conflict: post_mention_on_conflict
    ): post_mention
    "insert a single row into the table: \"post\""
    insert_post_one(
        "the row to be inserted"
        object: post_insert_input!,
        "on conflict condition"
        on_conflict: post_on_conflict
    ): post
    "insert data into the table: \"post_reference\""
    insert_post_reference(
        "the rows to be inserted"
        objects: [post_reference_insert_input!]!,
        "on conflict condition"
        on_conflict: post_reference_on_conflict
    ): post_reference_mutation_response
    "insert a single row into the table: \"post_reference\""
    insert_post_reference_one(
        "the row to be inserted"
        object: post_reference_insert_input!,
        "on conflict condition"
        on_conflict: post_reference_on_conflict
    ): post_reference
    "insert data into the table: \"post_tag\""
    insert_post_tag(
        "the rows to be inserted"
        objects: [post_tag_insert_input!]!,
        "on conflict condition"
        on_conflict: post_tag_on_conflict
    ): post_tag_mutation_response
    "insert a single row into the table: \"post_tag\""
    insert_post_tag_one(
        "the row to be inserted"
        object: post_tag_insert_input!,
        "on conflict condition"
        on_conflict: post_tag_on_conflict
    ): post_tag
    "insert data into the table: \"post_transaction\""
    insert_post_transaction(
        "the rows to be inserted"
        objects: [post_transaction_insert_input!]!,
        "on conflict condition"
        on_conflict: post_transaction_on_conflict
    ): post_transaction_mutation_response
    "insert a single row into the table: \"post_transaction\""
    insert_post_transaction_one(
        "the row to be inserted"
        object: post_transaction_insert_input!,
        "on conflict condition"
        on_conflict: post_transaction_on_conflict
    ): post_transaction
    "insert data into the table: \"post_url\""
    insert_post_url(
        "the rows to be inserted"
        objects: [post_url_insert_input!]!,
        "on conflict condition"
        on_conflict: post_url_on_conflict
    ): post_url_mutation_response
    "insert a single row into the table: \"post_url\""
    insert_post_url_one(
        "the row to be inserted"
        object: post_url_insert_input!,
        "on conflict condition"
        on_conflict: post_url_on_conflict
    ): post_url
    "insert data into the table: \"posts_params\""
    insert_posts_params(
        "the rows to be inserted"
        objects: [posts_params_insert_input!]!,
        "on conflict condition"
        on_conflict: posts_params_on_conflict
    ): posts_params_mutation_response
    "insert a single row into the table: \"posts_params\""
    insert_posts_params_one(
        "the row to be inserted"
        object: posts_params_insert_input!,
        "on conflict condition"
        on_conflict: posts_params_on_conflict
    ): posts_params
    "insert data into the table: \"profile\""
    insert_profile(
        "the rows to be inserted"
        objects: [profile_insert_input!]!,
        "on conflict condition"
        on_conflict: profile_on_conflict
    ): profile_mutation_response
    "insert a single row into the table: \"profile\""
    insert_profile_one(
        "the row to be inserted"
        object: profile_insert_input!,
        "on conflict condition"
        on_conflict: profile_on_conflict
    ): profile
    "insert data into the table: \"profiles_params\""
    insert_profiles_params(
        "the rows to be inserted"
        objects: [profiles_params_insert_input!]!,
        "on conflict condition"
        on_conflict: profiles_params_on_conflict
    ): profiles_params_mutation_response
    "insert a single row into the table: \"profiles_params\""
    insert_profiles_params_one(
        "the row to be inserted"
        object: profiles_params_insert_input!,
        "on conflict condition"
        on_conflict: profiles_params_on_conflict
    ): profiles_params
    "insert data into the table: \"reaction\""
    insert_reaction(
        "the rows to be inserted"
        objects: [reaction_insert_input!]!,
        "on conflict condition"
        on_conflict: reaction_on_conflict
    ): reaction_mutation_response
    "insert a single row into the table: \"reaction\""
    insert_reaction_one(
        "the row to be inserted"
        object: reaction_insert_input!,
        "on conflict condition"
        on_conflict: reaction_on_conflict
    ): reaction
    "insert data into the table: \"report\""
    insert_report(
        "the rows to be inserted"
        objects: [report_insert_input!]!,
        "on conflict condition"
        on_conflict: report_on_conflict
    ): report_mutation_response
    "insert a single row into the table: \"report\""
    insert_report_one(
        "the row to be inserted"
        object: report_insert_input!,
        "on conflict condition"
        on_conflict: report_on_conflict
    ): report
    "insert data into the table: \"report_reason\""
    insert_report_reason(
        "the rows to be inserted"
        objects: [report_reason_insert_input!]!,
        "on conflict condition"
        on_conflict: report_reason_on_conflict
    ): report_reason_mutation_response
    "insert a single row into the table: \"report_reason\""
    insert_report_reason_one(
        "the row to be inserted"
        object: report_reason_insert_input!,
        "on conflict condition"
        on_conflict: report_reason_on_conflict
    ): report_reason
    "insert data into the table: \"reports_params\""
    insert_reports_params(
        "the rows to be inserted"
        objects: [reports_params_insert_input!]!,
        "on conflict condition"
        on_conflict: reports_params_on_conflict
    ): reports_params_mutation_response
    "insert a single row into the table: \"reports_params\""
    insert_reports_params_one(
        "the row to be inserted"
        object: reports_params_insert_input!,
        "on conflict condition"
        on_conflict: reports_params_on_conflict
    ): reports_params
    "insert data into the table: \"subspace\""
    insert_subspace(
        "the rows to be inserted"
        objects: [subspace_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_on_conflict
    ): subspace_mutation_response
    "insert data into the table: \"subspace_free_text_params\""
    insert_subspace_free_text_params(
        "the rows to be inserted"
        objects: [subspace_free_text_params_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_free_text_params_on_conflict
    ): subspace_free_text_params_mutation_response
    "insert a single row into the table: \"subspace_free_text_params\""
    insert_subspace_free_text_params_one(
        "the row to be inserted"
        object: subspace_free_text_params_insert_input!,
        "on conflict condition"
        on_conflict: subspace_free_text_params_on_conflict
    ): subspace_free_text_params
    "insert a single row into the table: \"subspace\""
    insert_subspace_one(
        "the row to be inserted"
        object: subspace_insert_input!,
        "on conflict condition"
        on_conflict: subspace_on_conflict
    ): subspace
    "insert data into the table: \"subspace_registered_reaction\""
    insert_subspace_registered_reaction(
        "the rows to be inserted"
        objects: [subspace_registered_reaction_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_registered_reaction_on_conflict
    ): subspace_registered_reaction_mutation_response
    "insert a single row into the table: \"subspace_registered_reaction\""
    insert_subspace_registered_reaction_one(
        "the row to be inserted"
        object: subspace_registered_reaction_insert_input!,
        "on conflict condition"
        on_conflict: subspace_registered_reaction_on_conflict
    ): subspace_registered_reaction
    "insert data into the table: \"subspace_registered_reaction_params\""
    insert_subspace_registered_reaction_params(
        "the rows to be inserted"
        objects: [subspace_registered_reaction_params_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_registered_reaction_params_on_conflict
    ): subspace_registered_reaction_params_mutation_response
    "insert a single row into the table: \"subspace_registered_reaction_params\""
    insert_subspace_registered_reaction_params_one(
        "the row to be inserted"
        object: subspace_registered_reaction_params_insert_input!,
        "on conflict condition"
        on_conflict: subspace_registered_reaction_params_on_conflict
    ): subspace_registered_reaction_params
    "insert data into the table: \"subspace_report_reason\""
    insert_subspace_report_reason(
        "the rows to be inserted"
        objects: [subspace_report_reason_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_report_reason_on_conflict
    ): subspace_report_reason_mutation_response
    "insert a single row into the table: \"subspace_report_reason\""
    insert_subspace_report_reason_one(
        "the row to be inserted"
        object: subspace_report_reason_insert_input!,
        "on conflict condition"
        on_conflict: subspace_report_reason_on_conflict
    ): subspace_report_reason
    "insert data into the table: \"subspace_section\""
    insert_subspace_section(
        "the rows to be inserted"
        objects: [subspace_section_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_section_on_conflict
    ): subspace_section_mutation_response
    "insert a single row into the table: \"subspace_section\""
    insert_subspace_section_one(
        "the row to be inserted"
        object: subspace_section_insert_input!,
        "on conflict condition"
        on_conflict: subspace_section_on_conflict
    ): subspace_section
    "insert data into the table: \"subspace_user_group\""
    insert_subspace_user_group(
        "the rows to be inserted"
        objects: [subspace_user_group_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_user_group_on_conflict
    ): subspace_user_group_mutation_response
    "insert data into the table: \"subspace_user_group_member\""
    insert_subspace_user_group_member(
        "the rows to be inserted"
        objects: [subspace_user_group_member_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_user_group_member_on_conflict
    ): subspace_user_group_member_mutation_response
    "insert a single row into the table: \"subspace_user_group_member\""
    insert_subspace_user_group_member_one(
        "the row to be inserted"
        object: subspace_user_group_member_insert_input!,
        "on conflict condition"
        on_conflict: subspace_user_group_member_on_conflict
    ): subspace_user_group_member
    "insert a single row into the table: \"subspace_user_group\""
    insert_subspace_user_group_one(
        "the row to be inserted"
        object: subspace_user_group_insert_input!,
        "on conflict condition"
        on_conflict: subspace_user_group_on_conflict
    ): subspace_user_group
    "insert data into the table: \"subspace_user_permission\""
    insert_subspace_user_permission(
        "the rows to be inserted"
        objects: [subspace_user_permission_insert_input!]!,
        "on conflict condition"
        on_conflict: subspace_user_permission_on_conflict
    ): subspace_user_permission_mutation_response
    "insert a single row into the table: \"subspace_user_permission\""
    insert_subspace_user_permission_one(
        "the row to be inserted"
        object: subspace_user_permission_insert_input!,
        "on conflict condition"
        on_conflict: subspace_user_permission_on_conflict
    ): subspace_user_permission
    "insert data into the table: \"tip_post\""
    insert_tip_post(
        "the rows to be inserted"
        objects: [tip_post_insert_input!]!,
        "on conflict condition"
        on_conflict: tip_post_on_conflict
    ): tip_post_mutation_response
    "insert a single row into the table: \"tip_post\""
    insert_tip_post_one(
        "the row to be inserted"
        object: tip_post_insert_input!,
        "on conflict condition"
        on_conflict: tip_post_on_conflict
    ): tip_post
    "insert data into the table: \"tip_user\""
    insert_tip_user(
        "the rows to be inserted"
        objects: [tip_user_insert_input!]!,
        "on conflict condition"
        on_conflict: tip_user_on_conflict
    ): tip_user_mutation_response
    "insert a single row into the table: \"tip_user\""
    insert_tip_user_one(
        "the row to be inserted"
        object: tip_user_insert_input!,
        "on conflict condition"
        on_conflict: tip_user_on_conflict
    ): tip_user
    "insert data into the table: \"user_block\""
    insert_user_block(
        "the rows to be inserted"
        objects: [user_block_insert_input!]!,
        "on conflict condition"
        on_conflict: user_block_on_conflict
    ): user_block_mutation_response
    "insert a single row into the table: \"user_block\""
    insert_user_block_one(
        "the row to be inserted"
        object: user_block_insert_input!,
        "on conflict condition"
        on_conflict: user_block_on_conflict
    ): user_block
    "insert data into the table: \"user_relationship\""
    insert_user_relationship(
        "the rows to be inserted"
        objects: [user_relationship_insert_input!]!,
        "on conflict condition"
        on_conflict: user_relationship_on_conflict
    ): user_relationship_mutation_response
    "insert a single row into the table: \"user_relationship\""
    insert_user_relationship_one(
        "the row to be inserted"
        object: user_relationship_insert_input!,
        "on conflict condition"
        on_conflict: user_relationship_on_conflict
    ): user_relationship
    "update data of the table: \"application_link\""
    update_application_link(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: application_link_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: application_link_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: application_link_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: application_link_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: application_link_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: application_link_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_link_set_input,
        "filter the rows which have to be updated"
        where: application_link_bool_exp!
    ): application_link_mutation_response
    "update single row of the table: \"application_link\""
    update_application_link_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: application_link_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: application_link_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: application_link_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: application_link_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: application_link_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: application_link_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_link_set_input,
        pk_columns: application_link_pk_columns_input!
    ): application_link
    "update data of the table: \"application_link_oracle_request\""
    update_application_link_oracle_request(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: application_link_oracle_request_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: application_link_oracle_request_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: application_link_oracle_request_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: application_link_oracle_request_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: application_link_oracle_request_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: application_link_oracle_request_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_link_oracle_request_set_input,
        "filter the rows which have to be updated"
        where: application_link_oracle_request_bool_exp!
    ): application_link_oracle_request_mutation_response
    "update single row of the table: \"application_link_oracle_request\""
    update_application_link_oracle_request_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: application_link_oracle_request_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: application_link_oracle_request_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: application_link_oracle_request_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: application_link_oracle_request_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: application_link_oracle_request_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: application_link_oracle_request_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_link_oracle_request_set_input,
        pk_columns: application_link_oracle_request_pk_columns_input!
    ): application_link_oracle_request
    "update data of the table: \"application_link_score\""
    update_application_link_score(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: application_link_score_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: application_link_score_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: application_link_score_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: application_link_score_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: application_link_score_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: application_link_score_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: application_link_score_set_input,
        "filter the rows which have to be updated"
        where: application_link_score_bool_exp!
    ): application_link_score_mutation_response
    "update data of the table: \"authz_grant\""
    update_authz_grant(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: authz_grant_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: authz_grant_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: authz_grant_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: authz_grant_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: authz_grant_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: authz_grant_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: authz_grant_set_input,
        "filter the rows which have to be updated"
        where: authz_grant_bool_exp!
    ): authz_grant_mutation_response
    "update data of the table: \"block\""
    update_block(
        "increments the numeric columns with given value of the filtered values"
        _inc: block_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: block_set_input,
        "filter the rows which have to be updated"
        where: block_bool_exp!
    ): block_mutation_response
    "update single row of the table: \"block\""
    update_block_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: block_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: block_set_input,
        pk_columns: block_pk_columns_input!
    ): block
    "update data of the table: \"chain_link\""
    update_chain_link(
        "increments the numeric columns with given value of the filtered values"
        _inc: chain_link_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: chain_link_set_input,
        "filter the rows which have to be updated"
        where: chain_link_bool_exp!
    ): chain_link_mutation_response
    "update single row of the table: \"chain_link\""
    update_chain_link_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: chain_link_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: chain_link_set_input,
        pk_columns: chain_link_pk_columns_input!
    ): chain_link
    "update data of the table: \"chain_link_chain_config\""
    update_chain_link_chain_config(
        "increments the numeric columns with given value of the filtered values"
        _inc: chain_link_chain_config_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: chain_link_chain_config_set_input,
        "filter the rows which have to be updated"
        where: chain_link_chain_config_bool_exp!
    ): chain_link_chain_config_mutation_response
    "update single row of the table: \"chain_link_chain_config\""
    update_chain_link_chain_config_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: chain_link_chain_config_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: chain_link_chain_config_set_input,
        pk_columns: chain_link_chain_config_pk_columns_input!
    ): chain_link_chain_config
    "update data of the table: \"chain_link_proof\""
    update_chain_link_proof(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: chain_link_proof_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: chain_link_proof_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: chain_link_proof_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: chain_link_proof_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: chain_link_proof_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: chain_link_proof_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: chain_link_proof_set_input,
        "filter the rows which have to be updated"
        where: chain_link_proof_bool_exp!
    ): chain_link_proof_mutation_response
    "update data of the table: \"contract\""
    update_contract(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: contract_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: contract_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: contract_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: contract_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: contract_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: contract_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: contract_set_input,
        "filter the rows which have to be updated"
        where: contract_bool_exp!
    ): contract_mutation_response
    "update single row of the table: \"contract\""
    update_contract_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: contract_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: contract_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: contract_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: contract_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: contract_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: contract_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: contract_set_input,
        pk_columns: contract_pk_columns_input!
    ): contract
    "update data of the table: \"default_chain_link\""
    update_default_chain_link(
        "increments the numeric columns with given value of the filtered values"
        _inc: default_chain_link_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: default_chain_link_set_input,
        "filter the rows which have to be updated"
        where: default_chain_link_bool_exp!
    ): default_chain_link_mutation_response
    "update single row of the table: \"default_chain_link\""
    update_default_chain_link_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: default_chain_link_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: default_chain_link_set_input,
        pk_columns: default_chain_link_pk_columns_input!
    ): default_chain_link
    "update data of the table: \"dtag_transfer_requests\""
    update_dtag_transfer_requests(
        "increments the numeric columns with given value of the filtered values"
        _inc: dtag_transfer_requests_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: dtag_transfer_requests_set_input,
        "filter the rows which have to be updated"
        where: dtag_transfer_requests_bool_exp!
    ): dtag_transfer_requests_mutation_response
    "update data of the table: \"fee_grant\""
    update_fee_grant(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: fee_grant_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: fee_grant_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: fee_grant_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: fee_grant_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: fee_grant_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: fee_grant_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: fee_grant_set_input,
        "filter the rows which have to be updated"
        where: fee_grant_bool_exp!
    ): fee_grant_mutation_response
    "update data of the table: \"fees_params\""
    update_fees_params(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: fees_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: fees_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: fees_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: fees_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: fees_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: fees_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: fees_params_set_input,
        "filter the rows which have to be updated"
        where: fees_params_bool_exp!
    ): fees_params_mutation_response
    "update single row of the table: \"fees_params\""
    update_fees_params_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: fees_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: fees_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: fees_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: fees_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: fees_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: fees_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: fees_params_set_input,
        pk_columns: fees_params_pk_columns_input!
    ): fees_params
    "update data of the table: \"notification\""
    update_notification(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: notification_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: notification_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: notification_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: notification_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: notification_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: notification_set_input,
        "filter the rows which have to be updated"
        where: notification_bool_exp!
    ): notification_mutation_response
    "update data of the table: \"poll_answer\""
    update_poll_answer(
        "increments the numeric columns with given value of the filtered values"
        _inc: poll_answer_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: poll_answer_set_input,
        "filter the rows which have to be updated"
        where: poll_answer_bool_exp!
    ): poll_answer_mutation_response
    "update single row of the table: \"poll_answer\""
    update_poll_answer_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: poll_answer_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: poll_answer_set_input,
        pk_columns: poll_answer_pk_columns_input!
    ): poll_answer
    "update data of the table: \"post\""
    update_post(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_set_input,
        "filter the rows which have to be updated"
        where: post_bool_exp!
    ): post_mutation_response
    "update data of the table: \"post_attachment\""
    update_post_attachment(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: post_attachment_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: post_attachment_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: post_attachment_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: post_attachment_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: post_attachment_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: post_attachment_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_attachment_set_input,
        "filter the rows which have to be updated"
        where: post_attachment_bool_exp!
    ): post_attachment_mutation_response
    "update single row of the table: \"post_attachment\""
    update_post_attachment_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: post_attachment_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: post_attachment_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: post_attachment_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: post_attachment_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: post_attachment_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: post_attachment_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_attachment_set_input,
        pk_columns: post_attachment_pk_columns_input!
    ): post_attachment
    "update single row of the table: \"post\""
    update_post_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_set_input,
        pk_columns: post_pk_columns_input!
    ): post
    "update data of the table: \"post_hashtag\""
    update_post_hashtag(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_hashtag_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_hashtag_set_input,
        "filter the rows which have to be updated"
        where: post_hashtag_bool_exp!
    ): post_hashtag_mutation_response
    "update single row of the table: \"post_hashtag\""
    update_post_hashtag_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_hashtag_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_hashtag_set_input,
        pk_columns: post_hashtag_pk_columns_input!
    ): post_hashtag
    "update data of the table: \"post_mention\""
    update_post_mention(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_mention_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_mention_set_input,
        "filter the rows which have to be updated"
        where: post_mention_bool_exp!
    ): post_mention_mutation_response
    "update single row of the table: \"post_mention\""
    update_post_mention_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_mention_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_mention_set_input,
        pk_columns: post_mention_pk_columns_input!
    ): post_mention
    "update data of the table: \"post_reference\""
    update_post_reference(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_reference_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_reference_set_input,
        "filter the rows which have to be updated"
        where: post_reference_bool_exp!
    ): post_reference_mutation_response
    "update single row of the table: \"post_reference\""
    update_post_reference_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_reference_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_reference_set_input,
        pk_columns: post_reference_pk_columns_input!
    ): post_reference
    "update data of the table: \"post_tag\""
    update_post_tag(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_tag_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_tag_set_input,
        "filter the rows which have to be updated"
        where: post_tag_bool_exp!
    ): post_tag_mutation_response
    "update single row of the table: \"post_tag\""
    update_post_tag_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_tag_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_tag_set_input,
        pk_columns: post_tag_pk_columns_input!
    ): post_tag
    "update data of the table: \"post_transaction\""
    update_post_transaction(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_transaction_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_transaction_set_input,
        "filter the rows which have to be updated"
        where: post_transaction_bool_exp!
    ): post_transaction_mutation_response
    "update single row of the table: \"post_transaction\""
    update_post_transaction_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_transaction_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_transaction_set_input,
        pk_columns: post_transaction_pk_columns_input!
    ): post_transaction
    "update data of the table: \"post_url\""
    update_post_url(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_url_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_url_set_input,
        "filter the rows which have to be updated"
        where: post_url_bool_exp!
    ): post_url_mutation_response
    "update single row of the table: \"post_url\""
    update_post_url_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: post_url_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: post_url_set_input,
        pk_columns: post_url_pk_columns_input!
    ): post_url
    "update data of the table: \"posts_params\""
    update_posts_params(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: posts_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: posts_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: posts_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: posts_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: posts_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: posts_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: posts_params_set_input,
        "filter the rows which have to be updated"
        where: posts_params_bool_exp!
    ): posts_params_mutation_response
    "update single row of the table: \"posts_params\""
    update_posts_params_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: posts_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: posts_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: posts_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: posts_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: posts_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: posts_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: posts_params_set_input,
        pk_columns: posts_params_pk_columns_input!
    ): posts_params
    "update data of the table: \"profile\""
    update_profile(
        "increments the numeric columns with given value of the filtered values"
        _inc: profile_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: profile_set_input,
        "filter the rows which have to be updated"
        where: profile_bool_exp!
    ): profile_mutation_response
    "update single row of the table: \"profile\""
    update_profile_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: profile_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: profile_set_input,
        pk_columns: profile_pk_columns_input!
    ): profile
    "update data of the table: \"profiles_params\""
    update_profiles_params(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: profiles_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: profiles_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: profiles_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: profiles_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: profiles_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: profiles_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: profiles_params_set_input,
        "filter the rows which have to be updated"
        where: profiles_params_bool_exp!
    ): profiles_params_mutation_response
    "update single row of the table: \"profiles_params\""
    update_profiles_params_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: profiles_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: profiles_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: profiles_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: profiles_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: profiles_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: profiles_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: profiles_params_set_input,
        pk_columns: profiles_params_pk_columns_input!
    ): profiles_params
    "update data of the table: \"reaction\""
    update_reaction(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: reaction_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: reaction_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: reaction_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: reaction_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: reaction_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: reaction_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: reaction_set_input,
        "filter the rows which have to be updated"
        where: reaction_bool_exp!
    ): reaction_mutation_response
    "update single row of the table: \"reaction\""
    update_reaction_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: reaction_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: reaction_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: reaction_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: reaction_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: reaction_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: reaction_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: reaction_set_input,
        pk_columns: reaction_pk_columns_input!
    ): reaction
    "update data of the table: \"report\""
    update_report(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: report_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: report_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: report_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: report_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: report_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: report_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: report_set_input,
        "filter the rows which have to be updated"
        where: report_bool_exp!
    ): report_mutation_response
    "update single row of the table: \"report\""
    update_report_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: report_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: report_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: report_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: report_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: report_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: report_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: report_set_input,
        pk_columns: report_pk_columns_input!
    ): report
    "update data of the table: \"report_reason\""
    update_report_reason(
        "increments the numeric columns with given value of the filtered values"
        _inc: report_reason_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: report_reason_set_input,
        "filter the rows which have to be updated"
        where: report_reason_bool_exp!
    ): report_reason_mutation_response
    "update data of the table: \"reports_params\""
    update_reports_params(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: reports_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: reports_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: reports_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: reports_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: reports_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: reports_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: reports_params_set_input,
        "filter the rows which have to be updated"
        where: reports_params_bool_exp!
    ): reports_params_mutation_response
    "update single row of the table: \"reports_params\""
    update_reports_params_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: reports_params_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: reports_params_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: reports_params_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: reports_params_delete_key_input,
        "increments the numeric columns with given value of the filtered values"
        _inc: reports_params_inc_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: reports_params_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: reports_params_set_input,
        pk_columns: reports_params_pk_columns_input!
    ): reports_params
    "update data of the table: \"subspace\""
    update_subspace(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_set_input,
        "filter the rows which have to be updated"
        where: subspace_bool_exp!
    ): subspace_mutation_response
    "update single row of the table: \"subspace\""
    update_subspace_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_set_input,
        pk_columns: subspace_pk_columns_input!
    ): subspace
    "update data of the table: \"subspace_free_text_params\""
    update_subspace_free_text_params(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_free_text_params_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_free_text_params_set_input,
        "filter the rows which have to be updated"
        where: subspace_free_text_params_bool_exp!
    ): subspace_free_text_params_mutation_response
    "update single row of the table: \"subspace_free_text_params\""
    update_subspace_free_text_params_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_free_text_params_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_free_text_params_set_input,
        pk_columns: subspace_free_text_params_pk_columns_input!
    ): subspace_free_text_params
    "update data of the table: \"subspace_registered_reaction\""
    update_subspace_registered_reaction(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_registered_reaction_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_registered_reaction_set_input,
        "filter the rows which have to be updated"
        where: subspace_registered_reaction_bool_exp!
    ): subspace_registered_reaction_mutation_response
    "update single row of the table: \"subspace_registered_reaction\""
    update_subspace_registered_reaction_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_registered_reaction_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_registered_reaction_set_input,
        pk_columns: subspace_registered_reaction_pk_columns_input!
    ): subspace_registered_reaction
    "update data of the table: \"subspace_registered_reaction_params\""
    update_subspace_registered_reaction_params(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_registered_reaction_params_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_registered_reaction_params_set_input,
        "filter the rows which have to be updated"
        where: subspace_registered_reaction_params_bool_exp!
    ): subspace_registered_reaction_params_mutation_response
    "update single row of the table: \"subspace_registered_reaction_params\""
    update_subspace_registered_reaction_params_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_registered_reaction_params_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_registered_reaction_params_set_input,
        pk_columns: subspace_registered_reaction_params_pk_columns_input!
    ): subspace_registered_reaction_params
    "update data of the table: \"subspace_report_reason\""
    update_subspace_report_reason(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_report_reason_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_report_reason_set_input,
        "filter the rows which have to be updated"
        where: subspace_report_reason_bool_exp!
    ): subspace_report_reason_mutation_response
    "update single row of the table: \"subspace_report_reason\""
    update_subspace_report_reason_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_report_reason_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_report_reason_set_input,
        pk_columns: subspace_report_reason_pk_columns_input!
    ): subspace_report_reason
    "update data of the table: \"subspace_section\""
    update_subspace_section(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_section_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_section_set_input,
        "filter the rows which have to be updated"
        where: subspace_section_bool_exp!
    ): subspace_section_mutation_response
    "update single row of the table: \"subspace_section\""
    update_subspace_section_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_section_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_section_set_input,
        pk_columns: subspace_section_pk_columns_input!
    ): subspace_section
    "update data of the table: \"subspace_user_group\""
    update_subspace_user_group(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_user_group_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_user_group_set_input,
        "filter the rows which have to be updated"
        where: subspace_user_group_bool_exp!
    ): subspace_user_group_mutation_response
    "update single row of the table: \"subspace_user_group\""
    update_subspace_user_group_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_user_group_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_user_group_set_input,
        pk_columns: subspace_user_group_pk_columns_input!
    ): subspace_user_group
    "update data of the table: \"subspace_user_group_member\""
    update_subspace_user_group_member(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_user_group_member_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_user_group_member_set_input,
        "filter the rows which have to be updated"
        where: subspace_user_group_member_bool_exp!
    ): subspace_user_group_member_mutation_response
    "update data of the table: \"subspace_user_permission\""
    update_subspace_user_permission(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_user_permission_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_user_permission_set_input,
        "filter the rows which have to be updated"
        where: subspace_user_permission_bool_exp!
    ): subspace_user_permission_mutation_response
    "update single row of the table: \"subspace_user_permission\""
    update_subspace_user_permission_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: subspace_user_permission_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: subspace_user_permission_set_input,
        pk_columns: subspace_user_permission_pk_columns_input!
    ): subspace_user_permission
    "update data of the table: \"tip_post\""
    update_tip_post(
        "increments the numeric columns with given value of the filtered values"
        _inc: tip_post_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: tip_post_set_input,
        "filter the rows which have to be updated"
        where: tip_post_bool_exp!
    ): tip_post_mutation_response
    "update data of the table: \"tip_user\""
    update_tip_user(
        "increments the numeric columns with given value of the filtered values"
        _inc: tip_user_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: tip_user_set_input,
        "filter the rows which have to be updated"
        where: tip_user_bool_exp!
    ): tip_user_mutation_response
    "update data of the table: \"user_block\""
    update_user_block(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_block_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_block_set_input,
        "filter the rows which have to be updated"
        where: user_block_bool_exp!
    ): user_block_mutation_response
    "update data of the table: \"user_relationship\""
    update_user_relationship(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_relationship_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_relationship_set_input,
        "filter the rows which have to be updated"
        where: user_relationship_bool_exp!
    ): user_relationship_mutation_response
}

"columns and relationships of \"notification\""
type notification {
    data(
        "JSON select path"
        path: String
    ): jsonb!
    timestamp: timestamp!
    type: String!
    user_address: String!
}

"aggregated selection of \"notification\""
type notification_aggregate {
    aggregate: notification_aggregate_fields
    nodes: [notification!]!
}

"aggregate fields of \"notification\""
type notification_aggregate_fields {
    count(columns: [notification_select_column!], distinct: Boolean): Int!
    max: notification_max_fields
    min: notification_min_fields
}

"aggregate max on columns"
type notification_max_fields {
    timestamp: timestamp
    type: String
    user_address: String
}

"aggregate min on columns"
type notification_min_fields {
    timestamp: timestamp
    type: String
    user_address: String
}

"response of any mutation on the table \"notification\""
type notification_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [notification!]!
}

"columns and relationships of \"poll_answer\""
type poll_answer {
    answers_indexes: _int8!
    attachment_row_id: bigint!
    height: bigint!
    "An object relationship"
    post_attachment: post_attachment!
    row_id: Int!
    user_address: String!
}

"aggregated selection of \"poll_answer\""
type poll_answer_aggregate {
    aggregate: poll_answer_aggregate_fields
    nodes: [poll_answer!]!
}

"aggregate fields of \"poll_answer\""
type poll_answer_aggregate_fields {
    avg: poll_answer_avg_fields
    count(columns: [poll_answer_select_column!], distinct: Boolean): Int!
    max: poll_answer_max_fields
    min: poll_answer_min_fields
    stddev: poll_answer_stddev_fields
    stddev_pop: poll_answer_stddev_pop_fields
    stddev_samp: poll_answer_stddev_samp_fields
    sum: poll_answer_sum_fields
    var_pop: poll_answer_var_pop_fields
    var_samp: poll_answer_var_samp_fields
    variance: poll_answer_variance_fields
}

"aggregate avg on columns"
type poll_answer_avg_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate max on columns"
type poll_answer_max_fields {
    attachment_row_id: bigint
    height: bigint
    row_id: Int
    user_address: String
}

"aggregate min on columns"
type poll_answer_min_fields {
    attachment_row_id: bigint
    height: bigint
    row_id: Int
    user_address: String
}

"response of any mutation on the table \"poll_answer\""
type poll_answer_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [poll_answer!]!
}

"aggregate stddev on columns"
type poll_answer_stddev_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type poll_answer_stddev_pop_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type poll_answer_stddev_samp_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate sum on columns"
type poll_answer_sum_fields {
    attachment_row_id: bigint
    height: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type poll_answer_var_pop_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate var_samp on columns"
type poll_answer_var_samp_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"aggregate variance on columns"
type poll_answer_variance_fields {
    attachment_row_id: Float
    height: Float
    row_id: Float
}

"columns and relationships of \"post\""
type post {
    "An array relationship"
    attachments(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): [post_attachment!]!
    "An aggregate relationship"
    attachments_aggregate(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): post_attachment_aggregate!
    "An object relationship"
    author: profile
    author_address: String!
    "An array relationship"
    comments(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): [post!]!
    "An aggregate relationship"
    comments_aggregate(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): post_aggregate!
    "An object relationship"
    conversation: post
    conversation_row_id: bigint
    creation_date: timestamp!
    external_id: String
    "An array relationship"
    hashtags(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): [post_hashtag!]!
    "An aggregate relationship"
    hashtags_aggregate(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): post_hashtag_aggregate!
    height: bigint!
    id: bigint!
    last_edited_date: timestamp
    "An array relationship"
    mentions(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): [post_mention!]!
    "An aggregate relationship"
    mentions_aggregate(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): post_mention_aggregate!
    "An array relationship"
    reactions(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): [reaction!]!
    "An aggregate relationship"
    reactions_aggregate(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): reaction_aggregate!
    "An array relationship"
    referees(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): [post_reference!]!
    "An aggregate relationship"
    referees_aggregate(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): post_reference_aggregate!
    "An array relationship"
    references(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): [post_reference!]!
    "An aggregate relationship"
    references_aggregate(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): post_reference_aggregate!
    reply_settings: String!
    row_id: Int!
    "An object relationship"
    section: subspace_section!
    section_row_id: bigint!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
    "An array relationship"
    tags(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): [post_tag!]!
    "An aggregate relationship"
    tags_aggregate(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): post_tag_aggregate!
    text: String
    "An array relationship"
    tips(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): [tip_post!]!
    "An aggregate relationship"
    tips_aggregate(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): tip_post_aggregate!
    "An array relationship"
    transactions(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): [post_transaction!]!
    "An aggregate relationship"
    transactions_aggregate(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): post_transaction_aggregate!
    "An array relationship"
    urls(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): [post_url!]!
    "An aggregate relationship"
    urls_aggregate(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): post_url_aggregate!
}

"aggregated selection of \"post\""
type post_aggregate {
    aggregate: post_aggregate_fields
    nodes: [post!]!
}

"aggregate fields of \"post\""
type post_aggregate_fields {
    avg: post_avg_fields
    count(columns: [post_select_column!], distinct: Boolean): Int!
    max: post_max_fields
    min: post_min_fields
    stddev: post_stddev_fields
    stddev_pop: post_stddev_pop_fields
    stddev_samp: post_stddev_samp_fields
    sum: post_sum_fields
    var_pop: post_var_pop_fields
    var_samp: post_var_samp_fields
    variance: post_variance_fields
}

"columns and relationships of \"post_attachment\""
type post_attachment {
    content(
        "JSON select path"
        path: String
    ): jsonb!
    height: bigint!
    id: bigint!
    "An array relationship"
    poll_answers(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): [poll_answer!]!
    "An aggregate relationship"
    poll_answers_aggregate(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): poll_answer_aggregate!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
}

"aggregated selection of \"post_attachment\""
type post_attachment_aggregate {
    aggregate: post_attachment_aggregate_fields
    nodes: [post_attachment!]!
}

"aggregate fields of \"post_attachment\""
type post_attachment_aggregate_fields {
    avg: post_attachment_avg_fields
    count(columns: [post_attachment_select_column!], distinct: Boolean): Int!
    max: post_attachment_max_fields
    min: post_attachment_min_fields
    stddev: post_attachment_stddev_fields
    stddev_pop: post_attachment_stddev_pop_fields
    stddev_samp: post_attachment_stddev_samp_fields
    sum: post_attachment_sum_fields
    var_pop: post_attachment_var_pop_fields
    var_samp: post_attachment_var_samp_fields
    variance: post_attachment_variance_fields
}

"aggregate avg on columns"
type post_attachment_avg_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate max on columns"
type post_attachment_max_fields {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"aggregate min on columns"
type post_attachment_min_fields {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"response of any mutation on the table \"post_attachment\""
type post_attachment_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_attachment!]!
}

"aggregate stddev on columns"
type post_attachment_stddev_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type post_attachment_stddev_pop_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type post_attachment_stddev_samp_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate sum on columns"
type post_attachment_sum_fields {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type post_attachment_var_pop_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate var_samp on columns"
type post_attachment_var_samp_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate variance on columns"
type post_attachment_variance_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate avg on columns"
type post_avg_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"columns and relationships of \"post_hashtag\""
type post_hashtag {
    end_index: bigint!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
    start_index: bigint!
    tag: String!
}

"aggregated selection of \"post_hashtag\""
type post_hashtag_aggregate {
    aggregate: post_hashtag_aggregate_fields
    nodes: [post_hashtag!]!
}

"aggregate fields of \"post_hashtag\""
type post_hashtag_aggregate_fields {
    avg: post_hashtag_avg_fields
    count(columns: [post_hashtag_select_column!], distinct: Boolean): Int!
    max: post_hashtag_max_fields
    min: post_hashtag_min_fields
    stddev: post_hashtag_stddev_fields
    stddev_pop: post_hashtag_stddev_pop_fields
    stddev_samp: post_hashtag_stddev_samp_fields
    sum: post_hashtag_sum_fields
    var_pop: post_hashtag_var_pop_fields
    var_samp: post_hashtag_var_samp_fields
    variance: post_hashtag_variance_fields
}

"aggregate avg on columns"
type post_hashtag_avg_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate max on columns"
type post_hashtag_max_fields {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    tag: String
}

"aggregate min on columns"
type post_hashtag_min_fields {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    tag: String
}

"response of any mutation on the table \"post_hashtag\""
type post_hashtag_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_hashtag!]!
}

"aggregate stddev on columns"
type post_hashtag_stddev_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_pop on columns"
type post_hashtag_stddev_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_samp on columns"
type post_hashtag_stddev_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate sum on columns"
type post_hashtag_sum_fields {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"aggregate var_pop on columns"
type post_hashtag_var_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate var_samp on columns"
type post_hashtag_var_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate variance on columns"
type post_hashtag_variance_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate max on columns"
type post_max_fields {
    author_address: String
    conversation_row_id: bigint
    creation_date: timestamp
    external_id: String
    height: bigint
    id: bigint
    last_edited_date: timestamp
    reply_settings: String
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
    text: String
}

"columns and relationships of \"post_mention\""
type post_mention {
    end_index: bigint!
    "An object relationship"
    mention: profile
    mention_address: String!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
    start_index: bigint!
}

"aggregated selection of \"post_mention\""
type post_mention_aggregate {
    aggregate: post_mention_aggregate_fields
    nodes: [post_mention!]!
}

"aggregate fields of \"post_mention\""
type post_mention_aggregate_fields {
    avg: post_mention_avg_fields
    count(columns: [post_mention_select_column!], distinct: Boolean): Int!
    max: post_mention_max_fields
    min: post_mention_min_fields
    stddev: post_mention_stddev_fields
    stddev_pop: post_mention_stddev_pop_fields
    stddev_samp: post_mention_stddev_samp_fields
    sum: post_mention_sum_fields
    var_pop: post_mention_var_pop_fields
    var_samp: post_mention_var_samp_fields
    variance: post_mention_variance_fields
}

"aggregate avg on columns"
type post_mention_avg_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate max on columns"
type post_mention_max_fields {
    end_index: bigint
    mention_address: String
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"aggregate min on columns"
type post_mention_min_fields {
    end_index: bigint
    mention_address: String
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"response of any mutation on the table \"post_mention\""
type post_mention_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_mention!]!
}

"aggregate stddev on columns"
type post_mention_stddev_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_pop on columns"
type post_mention_stddev_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_samp on columns"
type post_mention_stddev_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate sum on columns"
type post_mention_sum_fields {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"aggregate var_pop on columns"
type post_mention_var_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate var_samp on columns"
type post_mention_var_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate variance on columns"
type post_mention_variance_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate min on columns"
type post_min_fields {
    author_address: String
    conversation_row_id: bigint
    creation_date: timestamp
    external_id: String
    height: bigint
    id: bigint
    last_edited_date: timestamp
    reply_settings: String
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
    text: String
}

"response of any mutation on the table \"post\""
type post_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post!]!
}

"columns and relationships of \"post_reference\""
type post_reference {
    position_index: bigint
    "An object relationship"
    post: post!
    post_row_id: bigint!
    "An object relationship"
    reference: post!
    reference_row_id: bigint!
    row_id: Int!
    type: String!
}

"aggregated selection of \"post_reference\""
type post_reference_aggregate {
    aggregate: post_reference_aggregate_fields
    nodes: [post_reference!]!
}

"aggregate fields of \"post_reference\""
type post_reference_aggregate_fields {
    avg: post_reference_avg_fields
    count(columns: [post_reference_select_column!], distinct: Boolean): Int!
    max: post_reference_max_fields
    min: post_reference_min_fields
    stddev: post_reference_stddev_fields
    stddev_pop: post_reference_stddev_pop_fields
    stddev_samp: post_reference_stddev_samp_fields
    sum: post_reference_sum_fields
    var_pop: post_reference_var_pop_fields
    var_samp: post_reference_var_samp_fields
    variance: post_reference_variance_fields
}

"aggregate avg on columns"
type post_reference_avg_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate max on columns"
type post_reference_max_fields {
    position_index: bigint
    post_row_id: bigint
    reference_row_id: bigint
    row_id: Int
    type: String
}

"aggregate min on columns"
type post_reference_min_fields {
    position_index: bigint
    post_row_id: bigint
    reference_row_id: bigint
    row_id: Int
    type: String
}

"response of any mutation on the table \"post_reference\""
type post_reference_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_reference!]!
}

"aggregate stddev on columns"
type post_reference_stddev_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type post_reference_stddev_pop_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type post_reference_stddev_samp_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate sum on columns"
type post_reference_sum_fields {
    position_index: bigint
    post_row_id: bigint
    reference_row_id: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type post_reference_var_pop_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate var_samp on columns"
type post_reference_var_samp_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate variance on columns"
type post_reference_variance_fields {
    position_index: Float
    post_row_id: Float
    reference_row_id: Float
    row_id: Float
}

"aggregate stddev on columns"
type post_stddev_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type post_stddev_pop_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type post_stddev_samp_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type post_sum_fields {
    conversation_row_id: bigint
    height: bigint
    id: bigint
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"columns and relationships of \"post_tag\""
type post_tag {
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
    tag: String!
}

"aggregated selection of \"post_tag\""
type post_tag_aggregate {
    aggregate: post_tag_aggregate_fields
    nodes: [post_tag!]!
}

"aggregate fields of \"post_tag\""
type post_tag_aggregate_fields {
    avg: post_tag_avg_fields
    count(columns: [post_tag_select_column!], distinct: Boolean): Int!
    max: post_tag_max_fields
    min: post_tag_min_fields
    stddev: post_tag_stddev_fields
    stddev_pop: post_tag_stddev_pop_fields
    stddev_samp: post_tag_stddev_samp_fields
    sum: post_tag_sum_fields
    var_pop: post_tag_var_pop_fields
    var_samp: post_tag_var_samp_fields
    variance: post_tag_variance_fields
}

"aggregate avg on columns"
type post_tag_avg_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate max on columns"
type post_tag_max_fields {
    post_row_id: bigint
    row_id: Int
    tag: String
}

"aggregate min on columns"
type post_tag_min_fields {
    post_row_id: bigint
    row_id: Int
    tag: String
}

"response of any mutation on the table \"post_tag\""
type post_tag_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_tag!]!
}

"aggregate stddev on columns"
type post_tag_stddev_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type post_tag_stddev_pop_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type post_tag_stddev_samp_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate sum on columns"
type post_tag_sum_fields {
    post_row_id: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type post_tag_var_pop_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate var_samp on columns"
type post_tag_var_samp_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate variance on columns"
type post_tag_variance_fields {
    post_row_id: Float
    row_id: Float
}

"columns and relationships of \"post_transaction\""
type post_transaction {
    hash: String!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
}

"aggregated selection of \"post_transaction\""
type post_transaction_aggregate {
    aggregate: post_transaction_aggregate_fields
    nodes: [post_transaction!]!
}

"aggregate fields of \"post_transaction\""
type post_transaction_aggregate_fields {
    avg: post_transaction_avg_fields
    count(columns: [post_transaction_select_column!], distinct: Boolean): Int!
    max: post_transaction_max_fields
    min: post_transaction_min_fields
    stddev: post_transaction_stddev_fields
    stddev_pop: post_transaction_stddev_pop_fields
    stddev_samp: post_transaction_stddev_samp_fields
    sum: post_transaction_sum_fields
    var_pop: post_transaction_var_pop_fields
    var_samp: post_transaction_var_samp_fields
    variance: post_transaction_variance_fields
}

"aggregate avg on columns"
type post_transaction_avg_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate max on columns"
type post_transaction_max_fields {
    hash: String
    post_row_id: bigint
    row_id: Int
}

"aggregate min on columns"
type post_transaction_min_fields {
    hash: String
    post_row_id: bigint
    row_id: Int
}

"response of any mutation on the table \"post_transaction\""
type post_transaction_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_transaction!]!
}

"aggregate stddev on columns"
type post_transaction_stddev_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type post_transaction_stddev_pop_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type post_transaction_stddev_samp_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate sum on columns"
type post_transaction_sum_fields {
    post_row_id: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type post_transaction_var_pop_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate var_samp on columns"
type post_transaction_var_samp_fields {
    post_row_id: Float
    row_id: Float
}

"aggregate variance on columns"
type post_transaction_variance_fields {
    post_row_id: Float
    row_id: Float
}

"columns and relationships of \"post_url\""
type post_url {
    display_value: String
    end_index: bigint!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
    start_index: bigint!
    url: String!
}

"aggregated selection of \"post_url\""
type post_url_aggregate {
    aggregate: post_url_aggregate_fields
    nodes: [post_url!]!
}

"aggregate fields of \"post_url\""
type post_url_aggregate_fields {
    avg: post_url_avg_fields
    count(columns: [post_url_select_column!], distinct: Boolean): Int!
    max: post_url_max_fields
    min: post_url_min_fields
    stddev: post_url_stddev_fields
    stddev_pop: post_url_stddev_pop_fields
    stddev_samp: post_url_stddev_samp_fields
    sum: post_url_sum_fields
    var_pop: post_url_var_pop_fields
    var_samp: post_url_var_samp_fields
    variance: post_url_variance_fields
}

"aggregate avg on columns"
type post_url_avg_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate max on columns"
type post_url_max_fields {
    display_value: String
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    url: String
}

"aggregate min on columns"
type post_url_min_fields {
    display_value: String
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    url: String
}

"response of any mutation on the table \"post_url\""
type post_url_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [post_url!]!
}

"aggregate stddev on columns"
type post_url_stddev_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_pop on columns"
type post_url_stddev_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate stddev_samp on columns"
type post_url_stddev_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate sum on columns"
type post_url_sum_fields {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"aggregate var_pop on columns"
type post_url_var_pop_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate var_samp on columns"
type post_url_var_samp_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate variance on columns"
type post_url_variance_fields {
    end_index: Float
    post_row_id: Float
    row_id: Float
    start_index: Float
}

"aggregate var_pop on columns"
type post_var_pop_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type post_var_samp_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type post_variance_fields {
    conversation_row_id: Float
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"columns and relationships of \"posts_params\""
type posts_params {
    height: bigint!
    one_row_id: Boolean!
    params(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"posts_params\""
type posts_params_aggregate {
    aggregate: posts_params_aggregate_fields
    nodes: [posts_params!]!
}

"aggregate fields of \"posts_params\""
type posts_params_aggregate_fields {
    avg: posts_params_avg_fields
    count(columns: [posts_params_select_column!], distinct: Boolean): Int!
    max: posts_params_max_fields
    min: posts_params_min_fields
    stddev: posts_params_stddev_fields
    stddev_pop: posts_params_stddev_pop_fields
    stddev_samp: posts_params_stddev_samp_fields
    sum: posts_params_sum_fields
    var_pop: posts_params_var_pop_fields
    var_samp: posts_params_var_samp_fields
    variance: posts_params_variance_fields
}

"aggregate avg on columns"
type posts_params_avg_fields {
    height: Float
}

"aggregate max on columns"
type posts_params_max_fields {
    height: bigint
}

"aggregate min on columns"
type posts_params_min_fields {
    height: bigint
}

"response of any mutation on the table \"posts_params\""
type posts_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [posts_params!]!
}

"aggregate stddev on columns"
type posts_params_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type posts_params_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type posts_params_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type posts_params_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type posts_params_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type posts_params_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type posts_params_variance_fields {
    height: Float
}

"columns and relationships of \"profile\""
type profile {
    address: String!
    "An array relationship"
    applications_links(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): [application_link!]!
    "An aggregate relationship"
    applications_links_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): application_link_aggregate!
    bio: String!
    "An array relationship"
    blocked_users(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): [user_block!]!
    "An aggregate relationship"
    blocked_users_aggregate(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): user_block_aggregate!
    "An array relationship"
    chain_links(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): [chain_link!]!
    "An aggregate relationship"
    chain_links_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): chain_link_aggregate!
    cover_pic: String!
    creation_time: timestamp!
    "An array relationship"
    default_chain_links(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): [default_chain_link!]!
    "An aggregate relationship"
    default_chain_links_aggregate(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): default_chain_link_aggregate!
    dtag: String!
    "An array relationship"
    followage(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): [user_relationship!]!
    "An aggregate relationship"
    followage_aggregate(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): user_relationship_aggregate!
    "An array relationship"
    following(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): [user_relationship!]!
    "An aggregate relationship"
    following_aggregate(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): user_relationship_aggregate!
    height: bigint!
    "An array relationship"
    incoming_dtag_transfer_requests(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): [dtag_transfer_requests!]!
    "An aggregate relationship"
    incoming_dtag_transfer_requests_aggregate(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): dtag_transfer_requests_aggregate!
    nickname: String!
    "An array relationship"
    outgoing_dtag_transfer_requests(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): [dtag_transfer_requests!]!
    "An aggregate relationship"
    outgoing_dtag_transfer_requests_aggregate(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): dtag_transfer_requests_aggregate!
    profile_pic: String!
    "An array relationship"
    user_blocks(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): [user_block!]!
    "An aggregate relationship"
    user_blocks_aggregate(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): user_block_aggregate!
}

"aggregated selection of \"profile\""
type profile_aggregate {
    aggregate: profile_aggregate_fields
    nodes: [profile!]!
}

"aggregate fields of \"profile\""
type profile_aggregate_fields {
    avg: profile_avg_fields
    count(columns: [profile_select_column!], distinct: Boolean): Int!
    max: profile_max_fields
    min: profile_min_fields
    stddev: profile_stddev_fields
    stddev_pop: profile_stddev_pop_fields
    stddev_samp: profile_stddev_samp_fields
    sum: profile_sum_fields
    var_pop: profile_var_pop_fields
    var_samp: profile_var_samp_fields
    variance: profile_variance_fields
}

"aggregate avg on columns"
type profile_avg_fields {
    height: Float
}

"aggregate max on columns"
type profile_max_fields {
    address: String
    bio: String
    cover_pic: String
    creation_time: timestamp
    dtag: String
    height: bigint
    nickname: String
    profile_pic: String
}

"aggregate min on columns"
type profile_min_fields {
    address: String
    bio: String
    cover_pic: String
    creation_time: timestamp
    dtag: String
    height: bigint
    nickname: String
    profile_pic: String
}

"response of any mutation on the table \"profile\""
type profile_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [profile!]!
}

"aggregate stddev on columns"
type profile_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type profile_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type profile_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type profile_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type profile_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type profile_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type profile_variance_fields {
    height: Float
}

"columns and relationships of \"profiles_params\""
type profiles_params {
    height: bigint!
    one_row_id: Boolean!
    params(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"profiles_params\""
type profiles_params_aggregate {
    aggregate: profiles_params_aggregate_fields
    nodes: [profiles_params!]!
}

"aggregate fields of \"profiles_params\""
type profiles_params_aggregate_fields {
    avg: profiles_params_avg_fields
    count(columns: [profiles_params_select_column!], distinct: Boolean): Int!
    max: profiles_params_max_fields
    min: profiles_params_min_fields
    stddev: profiles_params_stddev_fields
    stddev_pop: profiles_params_stddev_pop_fields
    stddev_samp: profiles_params_stddev_samp_fields
    sum: profiles_params_sum_fields
    var_pop: profiles_params_var_pop_fields
    var_samp: profiles_params_var_samp_fields
    variance: profiles_params_variance_fields
}

"aggregate avg on columns"
type profiles_params_avg_fields {
    height: Float
}

"aggregate max on columns"
type profiles_params_max_fields {
    height: bigint
}

"aggregate min on columns"
type profiles_params_min_fields {
    height: bigint
}

"response of any mutation on the table \"profiles_params\""
type profiles_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [profiles_params!]!
}

"aggregate stddev on columns"
type profiles_params_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type profiles_params_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type profiles_params_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type profiles_params_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type profiles_params_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type profiles_params_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type profiles_params_variance_fields {
    height: Float
}

type query_root {
    "fetch data from the table: \"application_link\""
    application_link(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): [application_link!]!
    "fetch aggregated fields from the table: \"application_link\""
    application_link_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): application_link_aggregate!
    "fetch data from the table: \"application_link\" using primary key columns"
    application_link_by_pk(id: Int!): application_link
    "fetch data from the table: \"application_link_oracle_request\""
    application_link_oracle_request(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): [application_link_oracle_request!]!
    "fetch aggregated fields from the table: \"application_link_oracle_request\""
    application_link_oracle_request_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): application_link_oracle_request_aggregate!
    "fetch data from the table: \"application_link_oracle_request\" using primary key columns"
    application_link_oracle_request_by_pk(id: Int!): application_link_oracle_request
    "fetch data from the table: \"application_link_score\""
    application_link_score(
        "distinct select on columns"
        distinct_on: [application_link_score_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_score_order_by!],
        "filter the rows returned"
        where: application_link_score_bool_exp
    ): [application_link_score!]!
    "fetch aggregated fields from the table: \"application_link_score\""
    application_link_score_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_score_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_score_order_by!],
        "filter the rows returned"
        where: application_link_score_bool_exp
    ): application_link_score_aggregate!
    "fetch data from the table: \"authz_grant\""
    authz_grant(
        "distinct select on columns"
        distinct_on: [authz_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [authz_grant_order_by!],
        "filter the rows returned"
        where: authz_grant_bool_exp
    ): [authz_grant!]!
    "fetch aggregated fields from the table: \"authz_grant\""
    authz_grant_aggregate(
        "distinct select on columns"
        distinct_on: [authz_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [authz_grant_order_by!],
        "filter the rows returned"
        where: authz_grant_bool_exp
    ): authz_grant_aggregate!
    "fetch data from the table: \"block\""
    block(
        "distinct select on columns"
        distinct_on: [block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [block_order_by!],
        "filter the rows returned"
        where: block_bool_exp
    ): [block!]!
    "fetch aggregated fields from the table: \"block\""
    block_aggregate(
        "distinct select on columns"
        distinct_on: [block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [block_order_by!],
        "filter the rows returned"
        where: block_bool_exp
    ): block_aggregate!
    "fetch data from the table: \"block\" using primary key columns"
    block_by_pk(height: bigint!): block
    "fetch data from the table: \"chain_link\""
    chain_link(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): [chain_link!]!
    "fetch aggregated fields from the table: \"chain_link\""
    chain_link_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): chain_link_aggregate!
    "fetch data from the table: \"chain_link\" using primary key columns"
    chain_link_by_pk(id: Int!): chain_link
    "fetch data from the table: \"chain_link_chain_config\""
    chain_link_chain_config(
        "distinct select on columns"
        distinct_on: [chain_link_chain_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_chain_config_order_by!],
        "filter the rows returned"
        where: chain_link_chain_config_bool_exp
    ): [chain_link_chain_config!]!
    "fetch aggregated fields from the table: \"chain_link_chain_config\""
    chain_link_chain_config_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_chain_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_chain_config_order_by!],
        "filter the rows returned"
        where: chain_link_chain_config_bool_exp
    ): chain_link_chain_config_aggregate!
    "fetch data from the table: \"chain_link_chain_config\" using primary key columns"
    chain_link_chain_config_by_pk(id: Int!): chain_link_chain_config
    "fetch data from the table: \"chain_link_proof\""
    chain_link_proof(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): [chain_link_proof!]!
    "fetch aggregated fields from the table: \"chain_link_proof\""
    chain_link_proof_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): chain_link_proof_aggregate!
    "fetch data from the table: \"contract\""
    contract(
        "distinct select on columns"
        distinct_on: [contract_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [contract_order_by!],
        "filter the rows returned"
        where: contract_bool_exp
    ): [contract!]!
    "fetch aggregated fields from the table: \"contract\""
    contract_aggregate(
        "distinct select on columns"
        distinct_on: [contract_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [contract_order_by!],
        "filter the rows returned"
        where: contract_bool_exp
    ): contract_aggregate!
    "fetch data from the table: \"contract\" using primary key columns"
    contract_by_pk(address: String!): contract
    "fetch data from the table: \"default_chain_link\""
    default_chain_link(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): [default_chain_link!]!
    "fetch aggregated fields from the table: \"default_chain_link\""
    default_chain_link_aggregate(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): default_chain_link_aggregate!
    "fetch data from the table: \"default_chain_link\" using primary key columns"
    default_chain_link_by_pk(id: Int!): default_chain_link
    "fetch data from the table: \"dtag_transfer_requests\""
    dtag_transfer_requests(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): [dtag_transfer_requests!]!
    "fetch aggregated fields from the table: \"dtag_transfer_requests\""
    dtag_transfer_requests_aggregate(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): dtag_transfer_requests_aggregate!
    "fetch data from the table: \"fee_grant\""
    fee_grant(
        "distinct select on columns"
        distinct_on: [fee_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fee_grant_order_by!],
        "filter the rows returned"
        where: fee_grant_bool_exp
    ): [fee_grant!]!
    "fetch aggregated fields from the table: \"fee_grant\""
    fee_grant_aggregate(
        "distinct select on columns"
        distinct_on: [fee_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fee_grant_order_by!],
        "filter the rows returned"
        where: fee_grant_bool_exp
    ): fee_grant_aggregate!
    "fetch data from the table: \"fees_params\""
    fees_params(
        "distinct select on columns"
        distinct_on: [fees_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fees_params_order_by!],
        "filter the rows returned"
        where: fees_params_bool_exp
    ): [fees_params!]!
    "fetch aggregated fields from the table: \"fees_params\""
    fees_params_aggregate(
        "distinct select on columns"
        distinct_on: [fees_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fees_params_order_by!],
        "filter the rows returned"
        where: fees_params_bool_exp
    ): fees_params_aggregate!
    "fetch data from the table: \"fees_params\" using primary key columns"
    fees_params_by_pk(one_row_id: Boolean!): fees_params
    "fetch data from the table: \"notification\""
    notification(
        "distinct select on columns"
        distinct_on: [notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [notification_order_by!],
        "filter the rows returned"
        where: notification_bool_exp
    ): [notification!]!
    "fetch aggregated fields from the table: \"notification\""
    notification_aggregate(
        "distinct select on columns"
        distinct_on: [notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [notification_order_by!],
        "filter the rows returned"
        where: notification_bool_exp
    ): notification_aggregate!
    "fetch data from the table: \"poll_answer\""
    poll_answer(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): [poll_answer!]!
    "fetch aggregated fields from the table: \"poll_answer\""
    poll_answer_aggregate(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): poll_answer_aggregate!
    "fetch data from the table: \"poll_answer\" using primary key columns"
    poll_answer_by_pk(row_id: Int!): poll_answer
    "fetch data from the table: \"post\""
    post(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): [post!]!
    "fetch aggregated fields from the table: \"post\""
    post_aggregate(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): post_aggregate!
    "fetch data from the table: \"post_attachment\""
    post_attachment(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): [post_attachment!]!
    "fetch aggregated fields from the table: \"post_attachment\""
    post_attachment_aggregate(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): post_attachment_aggregate!
    "fetch data from the table: \"post_attachment\" using primary key columns"
    post_attachment_by_pk(row_id: Int!): post_attachment
    "fetch data from the table: \"post\" using primary key columns"
    post_by_pk(row_id: Int!): post
    "fetch data from the table: \"post_hashtag\""
    post_hashtag(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): [post_hashtag!]!
    "fetch aggregated fields from the table: \"post_hashtag\""
    post_hashtag_aggregate(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): post_hashtag_aggregate!
    "fetch data from the table: \"post_hashtag\" using primary key columns"
    post_hashtag_by_pk(row_id: Int!): post_hashtag
    "fetch data from the table: \"post_mention\""
    post_mention(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): [post_mention!]!
    "fetch aggregated fields from the table: \"post_mention\""
    post_mention_aggregate(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): post_mention_aggregate!
    "fetch data from the table: \"post_mention\" using primary key columns"
    post_mention_by_pk(row_id: Int!): post_mention
    "fetch data from the table: \"post_reference\""
    post_reference(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): [post_reference!]!
    "fetch aggregated fields from the table: \"post_reference\""
    post_reference_aggregate(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): post_reference_aggregate!
    "fetch data from the table: \"post_reference\" using primary key columns"
    post_reference_by_pk(row_id: Int!): post_reference
    "fetch data from the table: \"post_tag\""
    post_tag(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): [post_tag!]!
    "fetch aggregated fields from the table: \"post_tag\""
    post_tag_aggregate(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): post_tag_aggregate!
    "fetch data from the table: \"post_tag\" using primary key columns"
    post_tag_by_pk(row_id: Int!): post_tag
    "fetch data from the table: \"post_transaction\""
    post_transaction(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): [post_transaction!]!
    "fetch aggregated fields from the table: \"post_transaction\""
    post_transaction_aggregate(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): post_transaction_aggregate!
    "fetch data from the table: \"post_transaction\" using primary key columns"
    post_transaction_by_pk(row_id: Int!): post_transaction
    "fetch data from the table: \"post_url\""
    post_url(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): [post_url!]!
    "fetch aggregated fields from the table: \"post_url\""
    post_url_aggregate(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): post_url_aggregate!
    "fetch data from the table: \"post_url\" using primary key columns"
    post_url_by_pk(row_id: Int!): post_url
    "fetch data from the table: \"posts_params\""
    posts_params(
        "distinct select on columns"
        distinct_on: [posts_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [posts_params_order_by!],
        "filter the rows returned"
        where: posts_params_bool_exp
    ): [posts_params!]!
    "fetch aggregated fields from the table: \"posts_params\""
    posts_params_aggregate(
        "distinct select on columns"
        distinct_on: [posts_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [posts_params_order_by!],
        "filter the rows returned"
        where: posts_params_bool_exp
    ): posts_params_aggregate!
    "fetch data from the table: \"posts_params\" using primary key columns"
    posts_params_by_pk(one_row_id: Boolean!): posts_params
    "fetch data from the table: \"profile\""
    profile(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): [profile!]!
    "fetch aggregated fields from the table: \"profile\""
    profile_aggregate(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): profile_aggregate!
    "fetch data from the table: \"profile\" using primary key columns"
    profile_by_pk(address: String!): profile
    "fetch data from the table: \"profiles_params\""
    profiles_params(
        "distinct select on columns"
        distinct_on: [profiles_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profiles_params_order_by!],
        "filter the rows returned"
        where: profiles_params_bool_exp
    ): [profiles_params!]!
    "fetch aggregated fields from the table: \"profiles_params\""
    profiles_params_aggregate(
        "distinct select on columns"
        distinct_on: [profiles_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profiles_params_order_by!],
        "filter the rows returned"
        where: profiles_params_bool_exp
    ): profiles_params_aggregate!
    "fetch data from the table: \"profiles_params\" using primary key columns"
    profiles_params_by_pk(one_row_id: Boolean!): profiles_params
    "fetch data from the table: \"reaction\""
    reaction(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): [reaction!]!
    "fetch aggregated fields from the table: \"reaction\""
    reaction_aggregate(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): reaction_aggregate!
    "fetch data from the table: \"reaction\" using primary key columns"
    reaction_by_pk(row_id: Int!): reaction
    "fetch data from the table: \"report\""
    report(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): [report!]!
    "fetch aggregated fields from the table: \"report\""
    report_aggregate(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): report_aggregate!
    "fetch data from the table: \"report\" using primary key columns"
    report_by_pk(row_id: Int!): report
    "fetch data from the table: \"report_reason\""
    report_reason(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): [report_reason!]!
    "fetch aggregated fields from the table: \"report_reason\""
    report_reason_aggregate(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): report_reason_aggregate!
    "fetch data from the table: \"reports_params\""
    reports_params(
        "distinct select on columns"
        distinct_on: [reports_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reports_params_order_by!],
        "filter the rows returned"
        where: reports_params_bool_exp
    ): [reports_params!]!
    "fetch aggregated fields from the table: \"reports_params\""
    reports_params_aggregate(
        "distinct select on columns"
        distinct_on: [reports_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reports_params_order_by!],
        "filter the rows returned"
        where: reports_params_bool_exp
    ): reports_params_aggregate!
    "fetch data from the table: \"reports_params\" using primary key columns"
    reports_params_by_pk(one_row_id: Boolean!): reports_params
    "fetch data from the table: \"subspace\""
    subspace(
        "distinct select on columns"
        distinct_on: [subspace_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_order_by!],
        "filter the rows returned"
        where: subspace_bool_exp
    ): [subspace!]!
    "fetch aggregated fields from the table: \"subspace\""
    subspace_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_order_by!],
        "filter the rows returned"
        where: subspace_bool_exp
    ): subspace_aggregate!
    "fetch data from the table: \"subspace\" using primary key columns"
    subspace_by_pk(id: bigint!): subspace
    "fetch data from the table: \"subspace_free_text_params\""
    subspace_free_text_params(
        "distinct select on columns"
        distinct_on: [subspace_free_text_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_free_text_params_order_by!],
        "filter the rows returned"
        where: subspace_free_text_params_bool_exp
    ): [subspace_free_text_params!]!
    "fetch aggregated fields from the table: \"subspace_free_text_params\""
    subspace_free_text_params_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_free_text_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_free_text_params_order_by!],
        "filter the rows returned"
        where: subspace_free_text_params_bool_exp
    ): subspace_free_text_params_aggregate!
    "fetch data from the table: \"subspace_free_text_params\" using primary key columns"
    subspace_free_text_params_by_pk(subspace_id: bigint!): subspace_free_text_params
    "fetch data from the table: \"subspace_registered_reaction\""
    subspace_registered_reaction(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): [subspace_registered_reaction!]!
    "fetch aggregated fields from the table: \"subspace_registered_reaction\""
    subspace_registered_reaction_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): subspace_registered_reaction_aggregate!
    "fetch data from the table: \"subspace_registered_reaction\" using primary key columns"
    subspace_registered_reaction_by_pk(row_id: Int!): subspace_registered_reaction
    "fetch data from the table: \"subspace_registered_reaction_params\""
    subspace_registered_reaction_params(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_params_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_params_bool_exp
    ): [subspace_registered_reaction_params!]!
    "fetch aggregated fields from the table: \"subspace_registered_reaction_params\""
    subspace_registered_reaction_params_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_params_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_params_bool_exp
    ): subspace_registered_reaction_params_aggregate!
    "fetch data from the table: \"subspace_registered_reaction_params\" using primary key columns"
    subspace_registered_reaction_params_by_pk(subspace_id: bigint!): subspace_registered_reaction_params
    "fetch data from the table: \"subspace_report_reason\""
    subspace_report_reason(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): [subspace_report_reason!]!
    "fetch aggregated fields from the table: \"subspace_report_reason\""
    subspace_report_reason_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): subspace_report_reason_aggregate!
    "fetch data from the table: \"subspace_report_reason\" using primary key columns"
    subspace_report_reason_by_pk(row_id: Int!): subspace_report_reason
    "fetch data from the table: \"subspace_section\""
    subspace_section(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): [subspace_section!]!
    "fetch aggregated fields from the table: \"subspace_section\""
    subspace_section_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): subspace_section_aggregate!
    "fetch data from the table: \"subspace_section\" using primary key columns"
    subspace_section_by_pk(row_id: Int!): subspace_section
    "fetch data from the table: \"subspace_user_group\""
    subspace_user_group(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): [subspace_user_group!]!
    "fetch aggregated fields from the table: \"subspace_user_group\""
    subspace_user_group_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): subspace_user_group_aggregate!
    "fetch data from the table: \"subspace_user_group\" using primary key columns"
    subspace_user_group_by_pk(row_id: Int!): subspace_user_group
    "fetch data from the table: \"subspace_user_group_member\""
    subspace_user_group_member(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): [subspace_user_group_member!]!
    "fetch aggregated fields from the table: \"subspace_user_group_member\""
    subspace_user_group_member_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): subspace_user_group_member_aggregate!
    "fetch data from the table: \"subspace_user_permission\""
    subspace_user_permission(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): [subspace_user_permission!]!
    "fetch aggregated fields from the table: \"subspace_user_permission\""
    subspace_user_permission_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): subspace_user_permission_aggregate!
    "fetch data from the table: \"subspace_user_permission\" using primary key columns"
    subspace_user_permission_by_pk(row_id: Int!): subspace_user_permission
    "fetch data from the table: \"tip_post\""
    tip_post(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): [tip_post!]!
    "fetch aggregated fields from the table: \"tip_post\""
    tip_post_aggregate(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): tip_post_aggregate!
    "fetch data from the table: \"tip_user\""
    tip_user(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): [tip_user!]!
    "fetch aggregated fields from the table: \"tip_user\""
    tip_user_aggregate(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): tip_user_aggregate!
    "fetch data from the table: \"user_block\""
    user_block(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): [user_block!]!
    "fetch aggregated fields from the table: \"user_block\""
    user_block_aggregate(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): user_block_aggregate!
    "fetch data from the table: \"user_relationship\""
    user_relationship(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): [user_relationship!]!
    "fetch aggregated fields from the table: \"user_relationship\""
    user_relationship_aggregate(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): user_relationship_aggregate!
}

"columns and relationships of \"reaction\""
type reaction {
    "An object relationship"
    author: profile
    author_address: String!
    height: bigint!
    id: bigint!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    row_id: Int!
    value(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"reaction\""
type reaction_aggregate {
    aggregate: reaction_aggregate_fields
    nodes: [reaction!]!
}

"aggregate fields of \"reaction\""
type reaction_aggregate_fields {
    avg: reaction_avg_fields
    count(columns: [reaction_select_column!], distinct: Boolean): Int!
    max: reaction_max_fields
    min: reaction_min_fields
    stddev: reaction_stddev_fields
    stddev_pop: reaction_stddev_pop_fields
    stddev_samp: reaction_stddev_samp_fields
    sum: reaction_sum_fields
    var_pop: reaction_var_pop_fields
    var_samp: reaction_var_samp_fields
    variance: reaction_variance_fields
}

"aggregate avg on columns"
type reaction_avg_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate max on columns"
type reaction_max_fields {
    author_address: String
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"aggregate min on columns"
type reaction_min_fields {
    author_address: String
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"response of any mutation on the table \"reaction\""
type reaction_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [reaction!]!
}

"aggregate stddev on columns"
type reaction_stddev_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type reaction_stddev_pop_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type reaction_stddev_samp_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate sum on columns"
type reaction_sum_fields {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type reaction_var_pop_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate var_samp on columns"
type reaction_var_samp_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"aggregate variance on columns"
type reaction_variance_fields {
    height: Float
    id: Float
    post_row_id: Float
    row_id: Float
}

"columns and relationships of \"report\""
type report {
    creation_date: timestamp!
    height: bigint!
    id: bigint!
    message: String
    "An array relationship"
    reasons(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): [report_reason!]!
    "An aggregate relationship"
    reasons_aggregate(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): report_reason_aggregate!
    reporter_address: String!
    row_id: Int!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
    target(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"report\""
type report_aggregate {
    aggregate: report_aggregate_fields
    nodes: [report!]!
}

"aggregate fields of \"report\""
type report_aggregate_fields {
    avg: report_avg_fields
    count(columns: [report_select_column!], distinct: Boolean): Int!
    max: report_max_fields
    min: report_min_fields
    stddev: report_stddev_fields
    stddev_pop: report_stddev_pop_fields
    stddev_samp: report_stddev_samp_fields
    sum: report_sum_fields
    var_pop: report_var_pop_fields
    var_samp: report_var_samp_fields
    variance: report_variance_fields
}

"aggregate avg on columns"
type report_avg_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type report_max_fields {
    creation_date: timestamp
    height: bigint
    id: bigint
    message: String
    reporter_address: String
    row_id: Int
    subspace_id: bigint
}

"aggregate min on columns"
type report_min_fields {
    creation_date: timestamp
    height: bigint
    id: bigint
    message: String
    reporter_address: String
    row_id: Int
    subspace_id: bigint
}

"response of any mutation on the table \"report\""
type report_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [report!]!
}

"columns and relationships of \"report_reason\""
type report_reason {
    "An object relationship"
    reason: subspace_report_reason!
    reason_row_id: bigint!
    "An object relationship"
    report: report!
    report_row_id: bigint!
}

"aggregated selection of \"report_reason\""
type report_reason_aggregate {
    aggregate: report_reason_aggregate_fields
    nodes: [report_reason!]!
}

"aggregate fields of \"report_reason\""
type report_reason_aggregate_fields {
    avg: report_reason_avg_fields
    count(columns: [report_reason_select_column!], distinct: Boolean): Int!
    max: report_reason_max_fields
    min: report_reason_min_fields
    stddev: report_reason_stddev_fields
    stddev_pop: report_reason_stddev_pop_fields
    stddev_samp: report_reason_stddev_samp_fields
    sum: report_reason_sum_fields
    var_pop: report_reason_var_pop_fields
    var_samp: report_reason_var_samp_fields
    variance: report_reason_variance_fields
}

"aggregate avg on columns"
type report_reason_avg_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate max on columns"
type report_reason_max_fields {
    reason_row_id: bigint
    report_row_id: bigint
}

"aggregate min on columns"
type report_reason_min_fields {
    reason_row_id: bigint
    report_row_id: bigint
}

"response of any mutation on the table \"report_reason\""
type report_reason_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [report_reason!]!
}

"aggregate stddev on columns"
type report_reason_stddev_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate stddev_pop on columns"
type report_reason_stddev_pop_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate stddev_samp on columns"
type report_reason_stddev_samp_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate sum on columns"
type report_reason_sum_fields {
    reason_row_id: bigint
    report_row_id: bigint
}

"aggregate var_pop on columns"
type report_reason_var_pop_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate var_samp on columns"
type report_reason_var_samp_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate variance on columns"
type report_reason_variance_fields {
    reason_row_id: Float
    report_row_id: Float
}

"aggregate stddev on columns"
type report_stddev_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type report_stddev_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type report_stddev_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type report_sum_fields {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"aggregate var_pop on columns"
type report_var_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type report_var_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type report_variance_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"columns and relationships of \"reports_params\""
type reports_params {
    height: bigint!
    one_row_id: Boolean!
    params(
        "JSON select path"
        path: String
    ): jsonb!
}

"aggregated selection of \"reports_params\""
type reports_params_aggregate {
    aggregate: reports_params_aggregate_fields
    nodes: [reports_params!]!
}

"aggregate fields of \"reports_params\""
type reports_params_aggregate_fields {
    avg: reports_params_avg_fields
    count(columns: [reports_params_select_column!], distinct: Boolean): Int!
    max: reports_params_max_fields
    min: reports_params_min_fields
    stddev: reports_params_stddev_fields
    stddev_pop: reports_params_stddev_pop_fields
    stddev_samp: reports_params_stddev_samp_fields
    sum: reports_params_sum_fields
    var_pop: reports_params_var_pop_fields
    var_samp: reports_params_var_samp_fields
    variance: reports_params_variance_fields
}

"aggregate avg on columns"
type reports_params_avg_fields {
    height: Float
}

"aggregate max on columns"
type reports_params_max_fields {
    height: bigint
}

"aggregate min on columns"
type reports_params_min_fields {
    height: bigint
}

"response of any mutation on the table \"reports_params\""
type reports_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [reports_params!]!
}

"aggregate stddev on columns"
type reports_params_stddev_fields {
    height: Float
}

"aggregate stddev_pop on columns"
type reports_params_stddev_pop_fields {
    height: Float
}

"aggregate stddev_samp on columns"
type reports_params_stddev_samp_fields {
    height: Float
}

"aggregate sum on columns"
type reports_params_sum_fields {
    height: bigint
}

"aggregate var_pop on columns"
type reports_params_var_pop_fields {
    height: Float
}

"aggregate var_samp on columns"
type reports_params_var_samp_fields {
    height: Float
}

"aggregate variance on columns"
type reports_params_variance_fields {
    height: Float
}

type subscription_root {
    "fetch data from the table: \"application_link\""
    application_link(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): [application_link!]!
    "fetch aggregated fields from the table: \"application_link\""
    application_link_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_order_by!],
        "filter the rows returned"
        where: application_link_bool_exp
    ): application_link_aggregate!
    "fetch data from the table: \"application_link\" using primary key columns"
    application_link_by_pk(id: Int!): application_link
    "fetch data from the table: \"application_link_oracle_request\""
    application_link_oracle_request(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): [application_link_oracle_request!]!
    "fetch aggregated fields from the table: \"application_link_oracle_request\""
    application_link_oracle_request_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_oracle_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_oracle_request_order_by!],
        "filter the rows returned"
        where: application_link_oracle_request_bool_exp
    ): application_link_oracle_request_aggregate!
    "fetch data from the table: \"application_link_oracle_request\" using primary key columns"
    application_link_oracle_request_by_pk(id: Int!): application_link_oracle_request
    "fetch data from the table: \"application_link_score\""
    application_link_score(
        "distinct select on columns"
        distinct_on: [application_link_score_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_score_order_by!],
        "filter the rows returned"
        where: application_link_score_bool_exp
    ): [application_link_score!]!
    "fetch aggregated fields from the table: \"application_link_score\""
    application_link_score_aggregate(
        "distinct select on columns"
        distinct_on: [application_link_score_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [application_link_score_order_by!],
        "filter the rows returned"
        where: application_link_score_bool_exp
    ): application_link_score_aggregate!
    "fetch data from the table: \"authz_grant\""
    authz_grant(
        "distinct select on columns"
        distinct_on: [authz_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [authz_grant_order_by!],
        "filter the rows returned"
        where: authz_grant_bool_exp
    ): [authz_grant!]!
    "fetch aggregated fields from the table: \"authz_grant\""
    authz_grant_aggregate(
        "distinct select on columns"
        distinct_on: [authz_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [authz_grant_order_by!],
        "filter the rows returned"
        where: authz_grant_bool_exp
    ): authz_grant_aggregate!
    "fetch data from the table: \"block\""
    block(
        "distinct select on columns"
        distinct_on: [block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [block_order_by!],
        "filter the rows returned"
        where: block_bool_exp
    ): [block!]!
    "fetch aggregated fields from the table: \"block\""
    block_aggregate(
        "distinct select on columns"
        distinct_on: [block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [block_order_by!],
        "filter the rows returned"
        where: block_bool_exp
    ): block_aggregate!
    "fetch data from the table: \"block\" using primary key columns"
    block_by_pk(height: bigint!): block
    "fetch data from the table: \"chain_link\""
    chain_link(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): [chain_link!]!
    "fetch aggregated fields from the table: \"chain_link\""
    chain_link_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_order_by!],
        "filter the rows returned"
        where: chain_link_bool_exp
    ): chain_link_aggregate!
    "fetch data from the table: \"chain_link\" using primary key columns"
    chain_link_by_pk(id: Int!): chain_link
    "fetch data from the table: \"chain_link_chain_config\""
    chain_link_chain_config(
        "distinct select on columns"
        distinct_on: [chain_link_chain_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_chain_config_order_by!],
        "filter the rows returned"
        where: chain_link_chain_config_bool_exp
    ): [chain_link_chain_config!]!
    "fetch aggregated fields from the table: \"chain_link_chain_config\""
    chain_link_chain_config_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_chain_config_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_chain_config_order_by!],
        "filter the rows returned"
        where: chain_link_chain_config_bool_exp
    ): chain_link_chain_config_aggregate!
    "fetch data from the table: \"chain_link_chain_config\" using primary key columns"
    chain_link_chain_config_by_pk(id: Int!): chain_link_chain_config
    "fetch data from the table: \"chain_link_proof\""
    chain_link_proof(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): [chain_link_proof!]!
    "fetch aggregated fields from the table: \"chain_link_proof\""
    chain_link_proof_aggregate(
        "distinct select on columns"
        distinct_on: [chain_link_proof_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [chain_link_proof_order_by!],
        "filter the rows returned"
        where: chain_link_proof_bool_exp
    ): chain_link_proof_aggregate!
    "fetch data from the table: \"contract\""
    contract(
        "distinct select on columns"
        distinct_on: [contract_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [contract_order_by!],
        "filter the rows returned"
        where: contract_bool_exp
    ): [contract!]!
    "fetch aggregated fields from the table: \"contract\""
    contract_aggregate(
        "distinct select on columns"
        distinct_on: [contract_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [contract_order_by!],
        "filter the rows returned"
        where: contract_bool_exp
    ): contract_aggregate!
    "fetch data from the table: \"contract\" using primary key columns"
    contract_by_pk(address: String!): contract
    "fetch data from the table: \"default_chain_link\""
    default_chain_link(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): [default_chain_link!]!
    "fetch aggregated fields from the table: \"default_chain_link\""
    default_chain_link_aggregate(
        "distinct select on columns"
        distinct_on: [default_chain_link_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [default_chain_link_order_by!],
        "filter the rows returned"
        where: default_chain_link_bool_exp
    ): default_chain_link_aggregate!
    "fetch data from the table: \"default_chain_link\" using primary key columns"
    default_chain_link_by_pk(id: Int!): default_chain_link
    "fetch data from the table: \"dtag_transfer_requests\""
    dtag_transfer_requests(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): [dtag_transfer_requests!]!
    "fetch aggregated fields from the table: \"dtag_transfer_requests\""
    dtag_transfer_requests_aggregate(
        "distinct select on columns"
        distinct_on: [dtag_transfer_requests_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [dtag_transfer_requests_order_by!],
        "filter the rows returned"
        where: dtag_transfer_requests_bool_exp
    ): dtag_transfer_requests_aggregate!
    "fetch data from the table: \"fee_grant\""
    fee_grant(
        "distinct select on columns"
        distinct_on: [fee_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fee_grant_order_by!],
        "filter the rows returned"
        where: fee_grant_bool_exp
    ): [fee_grant!]!
    "fetch aggregated fields from the table: \"fee_grant\""
    fee_grant_aggregate(
        "distinct select on columns"
        distinct_on: [fee_grant_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fee_grant_order_by!],
        "filter the rows returned"
        where: fee_grant_bool_exp
    ): fee_grant_aggregate!
    "fetch data from the table: \"fees_params\""
    fees_params(
        "distinct select on columns"
        distinct_on: [fees_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fees_params_order_by!],
        "filter the rows returned"
        where: fees_params_bool_exp
    ): [fees_params!]!
    "fetch aggregated fields from the table: \"fees_params\""
    fees_params_aggregate(
        "distinct select on columns"
        distinct_on: [fees_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [fees_params_order_by!],
        "filter the rows returned"
        where: fees_params_bool_exp
    ): fees_params_aggregate!
    "fetch data from the table: \"fees_params\" using primary key columns"
    fees_params_by_pk(one_row_id: Boolean!): fees_params
    "fetch data from the table: \"notification\""
    notification(
        "distinct select on columns"
        distinct_on: [notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [notification_order_by!],
        "filter the rows returned"
        where: notification_bool_exp
    ): [notification!]!
    "fetch aggregated fields from the table: \"notification\""
    notification_aggregate(
        "distinct select on columns"
        distinct_on: [notification_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [notification_order_by!],
        "filter the rows returned"
        where: notification_bool_exp
    ): notification_aggregate!
    "fetch data from the table: \"poll_answer\""
    poll_answer(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): [poll_answer!]!
    "fetch aggregated fields from the table: \"poll_answer\""
    poll_answer_aggregate(
        "distinct select on columns"
        distinct_on: [poll_answer_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [poll_answer_order_by!],
        "filter the rows returned"
        where: poll_answer_bool_exp
    ): poll_answer_aggregate!
    "fetch data from the table: \"poll_answer\" using primary key columns"
    poll_answer_by_pk(row_id: Int!): poll_answer
    "fetch data from the table: \"post\""
    post(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): [post!]!
    "fetch aggregated fields from the table: \"post\""
    post_aggregate(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): post_aggregate!
    "fetch data from the table: \"post_attachment\""
    post_attachment(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): [post_attachment!]!
    "fetch aggregated fields from the table: \"post_attachment\""
    post_attachment_aggregate(
        "distinct select on columns"
        distinct_on: [post_attachment_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_attachment_order_by!],
        "filter the rows returned"
        where: post_attachment_bool_exp
    ): post_attachment_aggregate!
    "fetch data from the table: \"post_attachment\" using primary key columns"
    post_attachment_by_pk(row_id: Int!): post_attachment
    "fetch data from the table: \"post\" using primary key columns"
    post_by_pk(row_id: Int!): post
    "fetch data from the table: \"post_hashtag\""
    post_hashtag(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): [post_hashtag!]!
    "fetch aggregated fields from the table: \"post_hashtag\""
    post_hashtag_aggregate(
        "distinct select on columns"
        distinct_on: [post_hashtag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_hashtag_order_by!],
        "filter the rows returned"
        where: post_hashtag_bool_exp
    ): post_hashtag_aggregate!
    "fetch data from the table: \"post_hashtag\" using primary key columns"
    post_hashtag_by_pk(row_id: Int!): post_hashtag
    "fetch data from the table: \"post_mention\""
    post_mention(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): [post_mention!]!
    "fetch aggregated fields from the table: \"post_mention\""
    post_mention_aggregate(
        "distinct select on columns"
        distinct_on: [post_mention_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_mention_order_by!],
        "filter the rows returned"
        where: post_mention_bool_exp
    ): post_mention_aggregate!
    "fetch data from the table: \"post_mention\" using primary key columns"
    post_mention_by_pk(row_id: Int!): post_mention
    "fetch data from the table: \"post_reference\""
    post_reference(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): [post_reference!]!
    "fetch aggregated fields from the table: \"post_reference\""
    post_reference_aggregate(
        "distinct select on columns"
        distinct_on: [post_reference_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_reference_order_by!],
        "filter the rows returned"
        where: post_reference_bool_exp
    ): post_reference_aggregate!
    "fetch data from the table: \"post_reference\" using primary key columns"
    post_reference_by_pk(row_id: Int!): post_reference
    "fetch data from the table: \"post_tag\""
    post_tag(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): [post_tag!]!
    "fetch aggregated fields from the table: \"post_tag\""
    post_tag_aggregate(
        "distinct select on columns"
        distinct_on: [post_tag_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_tag_order_by!],
        "filter the rows returned"
        where: post_tag_bool_exp
    ): post_tag_aggregate!
    "fetch data from the table: \"post_tag\" using primary key columns"
    post_tag_by_pk(row_id: Int!): post_tag
    "fetch data from the table: \"post_transaction\""
    post_transaction(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): [post_transaction!]!
    "fetch aggregated fields from the table: \"post_transaction\""
    post_transaction_aggregate(
        "distinct select on columns"
        distinct_on: [post_transaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_transaction_order_by!],
        "filter the rows returned"
        where: post_transaction_bool_exp
    ): post_transaction_aggregate!
    "fetch data from the table: \"post_transaction\" using primary key columns"
    post_transaction_by_pk(row_id: Int!): post_transaction
    "fetch data from the table: \"post_url\""
    post_url(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): [post_url!]!
    "fetch aggregated fields from the table: \"post_url\""
    post_url_aggregate(
        "distinct select on columns"
        distinct_on: [post_url_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_url_order_by!],
        "filter the rows returned"
        where: post_url_bool_exp
    ): post_url_aggregate!
    "fetch data from the table: \"post_url\" using primary key columns"
    post_url_by_pk(row_id: Int!): post_url
    "fetch data from the table: \"posts_params\""
    posts_params(
        "distinct select on columns"
        distinct_on: [posts_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [posts_params_order_by!],
        "filter the rows returned"
        where: posts_params_bool_exp
    ): [posts_params!]!
    "fetch aggregated fields from the table: \"posts_params\""
    posts_params_aggregate(
        "distinct select on columns"
        distinct_on: [posts_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [posts_params_order_by!],
        "filter the rows returned"
        where: posts_params_bool_exp
    ): posts_params_aggregate!
    "fetch data from the table: \"posts_params\" using primary key columns"
    posts_params_by_pk(one_row_id: Boolean!): posts_params
    "fetch data from the table: \"profile\""
    profile(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): [profile!]!
    "fetch aggregated fields from the table: \"profile\""
    profile_aggregate(
        "distinct select on columns"
        distinct_on: [profile_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profile_order_by!],
        "filter the rows returned"
        where: profile_bool_exp
    ): profile_aggregate!
    "fetch data from the table: \"profile\" using primary key columns"
    profile_by_pk(address: String!): profile
    "fetch data from the table: \"profiles_params\""
    profiles_params(
        "distinct select on columns"
        distinct_on: [profiles_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profiles_params_order_by!],
        "filter the rows returned"
        where: profiles_params_bool_exp
    ): [profiles_params!]!
    "fetch aggregated fields from the table: \"profiles_params\""
    profiles_params_aggregate(
        "distinct select on columns"
        distinct_on: [profiles_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [profiles_params_order_by!],
        "filter the rows returned"
        where: profiles_params_bool_exp
    ): profiles_params_aggregate!
    "fetch data from the table: \"profiles_params\" using primary key columns"
    profiles_params_by_pk(one_row_id: Boolean!): profiles_params
    "fetch data from the table: \"reaction\""
    reaction(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): [reaction!]!
    "fetch aggregated fields from the table: \"reaction\""
    reaction_aggregate(
        "distinct select on columns"
        distinct_on: [reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reaction_order_by!],
        "filter the rows returned"
        where: reaction_bool_exp
    ): reaction_aggregate!
    "fetch data from the table: \"reaction\" using primary key columns"
    reaction_by_pk(row_id: Int!): reaction
    "fetch data from the table: \"report\""
    report(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): [report!]!
    "fetch aggregated fields from the table: \"report\""
    report_aggregate(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): report_aggregate!
    "fetch data from the table: \"report\" using primary key columns"
    report_by_pk(row_id: Int!): report
    "fetch data from the table: \"report_reason\""
    report_reason(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): [report_reason!]!
    "fetch aggregated fields from the table: \"report_reason\""
    report_reason_aggregate(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): report_reason_aggregate!
    "fetch data from the table: \"reports_params\""
    reports_params(
        "distinct select on columns"
        distinct_on: [reports_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reports_params_order_by!],
        "filter the rows returned"
        where: reports_params_bool_exp
    ): [reports_params!]!
    "fetch aggregated fields from the table: \"reports_params\""
    reports_params_aggregate(
        "distinct select on columns"
        distinct_on: [reports_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reports_params_order_by!],
        "filter the rows returned"
        where: reports_params_bool_exp
    ): reports_params_aggregate!
    "fetch data from the table: \"reports_params\" using primary key columns"
    reports_params_by_pk(one_row_id: Boolean!): reports_params
    "fetch data from the table: \"subspace\""
    subspace(
        "distinct select on columns"
        distinct_on: [subspace_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_order_by!],
        "filter the rows returned"
        where: subspace_bool_exp
    ): [subspace!]!
    "fetch aggregated fields from the table: \"subspace\""
    subspace_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_order_by!],
        "filter the rows returned"
        where: subspace_bool_exp
    ): subspace_aggregate!
    "fetch data from the table: \"subspace\" using primary key columns"
    subspace_by_pk(id: bigint!): subspace
    "fetch data from the table: \"subspace_free_text_params\""
    subspace_free_text_params(
        "distinct select on columns"
        distinct_on: [subspace_free_text_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_free_text_params_order_by!],
        "filter the rows returned"
        where: subspace_free_text_params_bool_exp
    ): [subspace_free_text_params!]!
    "fetch aggregated fields from the table: \"subspace_free_text_params\""
    subspace_free_text_params_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_free_text_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_free_text_params_order_by!],
        "filter the rows returned"
        where: subspace_free_text_params_bool_exp
    ): subspace_free_text_params_aggregate!
    "fetch data from the table: \"subspace_free_text_params\" using primary key columns"
    subspace_free_text_params_by_pk(subspace_id: bigint!): subspace_free_text_params
    "fetch data from the table: \"subspace_registered_reaction\""
    subspace_registered_reaction(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): [subspace_registered_reaction!]!
    "fetch aggregated fields from the table: \"subspace_registered_reaction\""
    subspace_registered_reaction_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): subspace_registered_reaction_aggregate!
    "fetch data from the table: \"subspace_registered_reaction\" using primary key columns"
    subspace_registered_reaction_by_pk(row_id: Int!): subspace_registered_reaction
    "fetch data from the table: \"subspace_registered_reaction_params\""
    subspace_registered_reaction_params(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_params_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_params_bool_exp
    ): [subspace_registered_reaction_params!]!
    "fetch aggregated fields from the table: \"subspace_registered_reaction_params\""
    subspace_registered_reaction_params_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_params_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_params_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_params_bool_exp
    ): subspace_registered_reaction_params_aggregate!
    "fetch data from the table: \"subspace_registered_reaction_params\" using primary key columns"
    subspace_registered_reaction_params_by_pk(subspace_id: bigint!): subspace_registered_reaction_params
    "fetch data from the table: \"subspace_report_reason\""
    subspace_report_reason(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): [subspace_report_reason!]!
    "fetch aggregated fields from the table: \"subspace_report_reason\""
    subspace_report_reason_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): subspace_report_reason_aggregate!
    "fetch data from the table: \"subspace_report_reason\" using primary key columns"
    subspace_report_reason_by_pk(row_id: Int!): subspace_report_reason
    "fetch data from the table: \"subspace_section\""
    subspace_section(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): [subspace_section!]!
    "fetch aggregated fields from the table: \"subspace_section\""
    subspace_section_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): subspace_section_aggregate!
    "fetch data from the table: \"subspace_section\" using primary key columns"
    subspace_section_by_pk(row_id: Int!): subspace_section
    "fetch data from the table: \"subspace_user_group\""
    subspace_user_group(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): [subspace_user_group!]!
    "fetch aggregated fields from the table: \"subspace_user_group\""
    subspace_user_group_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): subspace_user_group_aggregate!
    "fetch data from the table: \"subspace_user_group\" using primary key columns"
    subspace_user_group_by_pk(row_id: Int!): subspace_user_group
    "fetch data from the table: \"subspace_user_group_member\""
    subspace_user_group_member(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): [subspace_user_group_member!]!
    "fetch aggregated fields from the table: \"subspace_user_group_member\""
    subspace_user_group_member_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): subspace_user_group_member_aggregate!
    "fetch data from the table: \"subspace_user_permission\""
    subspace_user_permission(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): [subspace_user_permission!]!
    "fetch aggregated fields from the table: \"subspace_user_permission\""
    subspace_user_permission_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): subspace_user_permission_aggregate!
    "fetch data from the table: \"subspace_user_permission\" using primary key columns"
    subspace_user_permission_by_pk(row_id: Int!): subspace_user_permission
    "fetch data from the table: \"tip_post\""
    tip_post(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): [tip_post!]!
    "fetch aggregated fields from the table: \"tip_post\""
    tip_post_aggregate(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): tip_post_aggregate!
    "fetch data from the table: \"tip_user\""
    tip_user(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): [tip_user!]!
    "fetch aggregated fields from the table: \"tip_user\""
    tip_user_aggregate(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): tip_user_aggregate!
    "fetch data from the table: \"user_block\""
    user_block(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): [user_block!]!
    "fetch aggregated fields from the table: \"user_block\""
    user_block_aggregate(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): user_block_aggregate!
    "fetch data from the table: \"user_relationship\""
    user_relationship(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): [user_relationship!]!
    "fetch aggregated fields from the table: \"user_relationship\""
    user_relationship_aggregate(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): user_relationship_aggregate!
}

"columns and relationships of \"subspace\""
type subspace {
    creation_time: timestamp!
    creator_address: String!
    description: String
    "An object relationship"
    free_text_reactions_params: subspace_free_text_params!
    height: bigint!
    id: bigint!
    name: String!
    owner_address: String!
    "An array relationship"
    posts(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): [post!]!
    "An aggregate relationship"
    posts_aggregate(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): post_aggregate!
    "An array relationship"
    registered_reactions(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): [subspace_registered_reaction!]!
    "An aggregate relationship"
    registered_reactions_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_registered_reaction_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_registered_reaction_order_by!],
        "filter the rows returned"
        where: subspace_registered_reaction_bool_exp
    ): subspace_registered_reaction_aggregate!
    "An object relationship"
    registered_reactions_params: subspace_registered_reaction_params
    "An array relationship"
    report_reasons(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): [subspace_report_reason!]!
    "An aggregate relationship"
    report_reasons_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_report_reason_order_by!],
        "filter the rows returned"
        where: subspace_report_reason_bool_exp
    ): subspace_report_reason_aggregate!
    "An array relationship"
    reports(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): [report!]!
    "An aggregate relationship"
    reports_aggregate(
        "distinct select on columns"
        distinct_on: [report_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_order_by!],
        "filter the rows returned"
        where: report_bool_exp
    ): report_aggregate!
    "An array relationship"
    sections(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): [subspace_section!]!
    "An aggregate relationship"
    sections_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): subspace_section_aggregate!
    "An array relationship"
    tip_posts(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): [tip_post!]!
    "An aggregate relationship"
    tip_posts_aggregate(
        "distinct select on columns"
        distinct_on: [tip_post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_post_order_by!],
        "filter the rows returned"
        where: tip_post_bool_exp
    ): tip_post_aggregate!
    "An array relationship"
    tip_users(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): [tip_user!]!
    "An aggregate relationship"
    tip_users_aggregate(
        "distinct select on columns"
        distinct_on: [tip_user_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tip_user_order_by!],
        "filter the rows returned"
        where: tip_user_bool_exp
    ): tip_user_aggregate!
    treasury_address: String
    "An array relationship"
    user_blocks(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): [user_block!]!
    "An aggregate relationship"
    user_blocks_aggregate(
        "distinct select on columns"
        distinct_on: [user_block_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_block_order_by!],
        "filter the rows returned"
        where: user_block_bool_exp
    ): user_block_aggregate!
    "An array relationship"
    user_groups(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): [subspace_user_group!]!
    "An aggregate relationship"
    user_groups_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): subspace_user_group_aggregate!
    "An array relationship"
    user_relationships(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): [user_relationship!]!
    "An aggregate relationship"
    user_relationships_aggregate(
        "distinct select on columns"
        distinct_on: [user_relationship_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_relationship_order_by!],
        "filter the rows returned"
        where: user_relationship_bool_exp
    ): user_relationship_aggregate!
}

"aggregated selection of \"subspace\""
type subspace_aggregate {
    aggregate: subspace_aggregate_fields
    nodes: [subspace!]!
}

"aggregate fields of \"subspace\""
type subspace_aggregate_fields {
    avg: subspace_avg_fields
    count(columns: [subspace_select_column!], distinct: Boolean): Int!
    max: subspace_max_fields
    min: subspace_min_fields
    stddev: subspace_stddev_fields
    stddev_pop: subspace_stddev_pop_fields
    stddev_samp: subspace_stddev_samp_fields
    sum: subspace_sum_fields
    var_pop: subspace_var_pop_fields
    var_samp: subspace_var_samp_fields
    variance: subspace_variance_fields
}

"aggregate avg on columns"
type subspace_avg_fields {
    height: Float
    id: Float
}

"columns and relationships of \"subspace_free_text_params\""
type subspace_free_text_params {
    enabled: Boolean!
    height: bigint!
    max_length: bigint!
    reg_ex: String
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"subspace_free_text_params\""
type subspace_free_text_params_aggregate {
    aggregate: subspace_free_text_params_aggregate_fields
    nodes: [subspace_free_text_params!]!
}

"aggregate fields of \"subspace_free_text_params\""
type subspace_free_text_params_aggregate_fields {
    avg: subspace_free_text_params_avg_fields
    count(columns: [subspace_free_text_params_select_column!], distinct: Boolean): Int!
    max: subspace_free_text_params_max_fields
    min: subspace_free_text_params_min_fields
    stddev: subspace_free_text_params_stddev_fields
    stddev_pop: subspace_free_text_params_stddev_pop_fields
    stddev_samp: subspace_free_text_params_stddev_samp_fields
    sum: subspace_free_text_params_sum_fields
    var_pop: subspace_free_text_params_var_pop_fields
    var_samp: subspace_free_text_params_var_samp_fields
    variance: subspace_free_text_params_variance_fields
}

"aggregate avg on columns"
type subspace_free_text_params_avg_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_free_text_params_max_fields {
    height: bigint
    max_length: bigint
    reg_ex: String
    subspace_id: bigint
}

"aggregate min on columns"
type subspace_free_text_params_min_fields {
    height: bigint
    max_length: bigint
    reg_ex: String
    subspace_id: bigint
}

"response of any mutation on the table \"subspace_free_text_params\""
type subspace_free_text_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_free_text_params!]!
}

"aggregate stddev on columns"
type subspace_free_text_params_stddev_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_free_text_params_stddev_pop_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_free_text_params_stddev_samp_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_free_text_params_sum_fields {
    height: bigint
    max_length: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_free_text_params_var_pop_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_free_text_params_var_samp_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_free_text_params_variance_fields {
    height: Float
    max_length: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_max_fields {
    creation_time: timestamp
    creator_address: String
    description: String
    height: bigint
    id: bigint
    name: String
    owner_address: String
    treasury_address: String
}

"aggregate min on columns"
type subspace_min_fields {
    creation_time: timestamp
    creator_address: String
    description: String
    height: bigint
    id: bigint
    name: String
    owner_address: String
    treasury_address: String
}

"response of any mutation on the table \"subspace\""
type subspace_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace!]!
}

"columns and relationships of \"subspace_registered_reaction\""
type subspace_registered_reaction {
    display_value: String!
    height: bigint!
    id: bigint!
    row_id: Int!
    shorthand_code: String!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"subspace_registered_reaction\""
type subspace_registered_reaction_aggregate {
    aggregate: subspace_registered_reaction_aggregate_fields
    nodes: [subspace_registered_reaction!]!
}

"aggregate fields of \"subspace_registered_reaction\""
type subspace_registered_reaction_aggregate_fields {
    avg: subspace_registered_reaction_avg_fields
    count(columns: [subspace_registered_reaction_select_column!], distinct: Boolean): Int!
    max: subspace_registered_reaction_max_fields
    min: subspace_registered_reaction_min_fields
    stddev: subspace_registered_reaction_stddev_fields
    stddev_pop: subspace_registered_reaction_stddev_pop_fields
    stddev_samp: subspace_registered_reaction_stddev_samp_fields
    sum: subspace_registered_reaction_sum_fields
    var_pop: subspace_registered_reaction_var_pop_fields
    var_samp: subspace_registered_reaction_var_samp_fields
    variance: subspace_registered_reaction_variance_fields
}

"aggregate avg on columns"
type subspace_registered_reaction_avg_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_registered_reaction_max_fields {
    display_value: String
    height: bigint
    id: bigint
    row_id: Int
    shorthand_code: String
    subspace_id: bigint
}

"aggregate min on columns"
type subspace_registered_reaction_min_fields {
    display_value: String
    height: bigint
    id: bigint
    row_id: Int
    shorthand_code: String
    subspace_id: bigint
}

"response of any mutation on the table \"subspace_registered_reaction\""
type subspace_registered_reaction_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_registered_reaction!]!
}

"columns and relationships of \"subspace_registered_reaction_params\""
type subspace_registered_reaction_params {
    enabled: Boolean!
    height: bigint!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"subspace_registered_reaction_params\""
type subspace_registered_reaction_params_aggregate {
    aggregate: subspace_registered_reaction_params_aggregate_fields
    nodes: [subspace_registered_reaction_params!]!
}

"aggregate fields of \"subspace_registered_reaction_params\""
type subspace_registered_reaction_params_aggregate_fields {
    avg: subspace_registered_reaction_params_avg_fields
    count(columns: [subspace_registered_reaction_params_select_column!], distinct: Boolean): Int!
    max: subspace_registered_reaction_params_max_fields
    min: subspace_registered_reaction_params_min_fields
    stddev: subspace_registered_reaction_params_stddev_fields
    stddev_pop: subspace_registered_reaction_params_stddev_pop_fields
    stddev_samp: subspace_registered_reaction_params_stddev_samp_fields
    sum: subspace_registered_reaction_params_sum_fields
    var_pop: subspace_registered_reaction_params_var_pop_fields
    var_samp: subspace_registered_reaction_params_var_samp_fields
    variance: subspace_registered_reaction_params_variance_fields
}

"aggregate avg on columns"
type subspace_registered_reaction_params_avg_fields {
    height: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_registered_reaction_params_max_fields {
    height: bigint
    subspace_id: bigint
}

"aggregate min on columns"
type subspace_registered_reaction_params_min_fields {
    height: bigint
    subspace_id: bigint
}

"response of any mutation on the table \"subspace_registered_reaction_params\""
type subspace_registered_reaction_params_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_registered_reaction_params!]!
}

"aggregate stddev on columns"
type subspace_registered_reaction_params_stddev_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_registered_reaction_params_stddev_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_registered_reaction_params_stddev_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_registered_reaction_params_sum_fields {
    height: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_registered_reaction_params_var_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_registered_reaction_params_var_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_registered_reaction_params_variance_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev on columns"
type subspace_registered_reaction_stddev_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_registered_reaction_stddev_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_registered_reaction_stddev_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_registered_reaction_sum_fields {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_registered_reaction_var_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_registered_reaction_var_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_registered_reaction_variance_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"columns and relationships of \"subspace_report_reason\""
type subspace_report_reason {
    description: String
    height: bigint!
    id: bigint!
    "An array relationship"
    report_reasons(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): [report_reason!]!
    "An aggregate relationship"
    report_reasons_aggregate(
        "distinct select on columns"
        distinct_on: [report_reason_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [report_reason_order_by!],
        "filter the rows returned"
        where: report_reason_bool_exp
    ): report_reason_aggregate!
    row_id: Int!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
    title: String!
}

"aggregated selection of \"subspace_report_reason\""
type subspace_report_reason_aggregate {
    aggregate: subspace_report_reason_aggregate_fields
    nodes: [subspace_report_reason!]!
}

"aggregate fields of \"subspace_report_reason\""
type subspace_report_reason_aggregate_fields {
    avg: subspace_report_reason_avg_fields
    count(columns: [subspace_report_reason_select_column!], distinct: Boolean): Int!
    max: subspace_report_reason_max_fields
    min: subspace_report_reason_min_fields
    stddev: subspace_report_reason_stddev_fields
    stddev_pop: subspace_report_reason_stddev_pop_fields
    stddev_samp: subspace_report_reason_stddev_samp_fields
    sum: subspace_report_reason_sum_fields
    var_pop: subspace_report_reason_var_pop_fields
    var_samp: subspace_report_reason_var_samp_fields
    variance: subspace_report_reason_variance_fields
}

"aggregate avg on columns"
type subspace_report_reason_avg_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_report_reason_max_fields {
    description: String
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
    title: String
}

"aggregate min on columns"
type subspace_report_reason_min_fields {
    description: String
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
    title: String
}

"response of any mutation on the table \"subspace_report_reason\""
type subspace_report_reason_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_report_reason!]!
}

"aggregate stddev on columns"
type subspace_report_reason_stddev_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_report_reason_stddev_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_report_reason_stddev_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_report_reason_sum_fields {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_report_reason_var_pop_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_report_reason_var_samp_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_report_reason_variance_fields {
    height: Float
    id: Float
    row_id: Float
    subspace_id: Float
}

"columns and relationships of \"subspace_section\""
type subspace_section {
    "An array relationship"
    children(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): [subspace_section!]!
    "An aggregate relationship"
    children_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_section_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_section_order_by!],
        "filter the rows returned"
        where: subspace_section_bool_exp
    ): subspace_section_aggregate!
    description: String
    height: bigint!
    id: bigint!
    name: String!
    "An object relationship"
    parent: subspace_section
    parent_row_id: bigint
    "An array relationship"
    posts(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): [post!]!
    "An aggregate relationship"
    posts_aggregate(
        "distinct select on columns"
        distinct_on: [post_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [post_order_by!],
        "filter the rows returned"
        where: post_bool_exp
    ): post_aggregate!
    row_id: Int!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
    "An array relationship"
    user_groups(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): [subspace_user_group!]!
    "An aggregate relationship"
    user_groups_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_order_by!],
        "filter the rows returned"
        where: subspace_user_group_bool_exp
    ): subspace_user_group_aggregate!
    "An array relationship"
    user_permissions(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): [subspace_user_permission!]!
    "An aggregate relationship"
    user_permissions_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_permission_order_by!],
        "filter the rows returned"
        where: subspace_user_permission_bool_exp
    ): subspace_user_permission_aggregate!
}

"aggregated selection of \"subspace_section\""
type subspace_section_aggregate {
    aggregate: subspace_section_aggregate_fields
    nodes: [subspace_section!]!
}

"aggregate fields of \"subspace_section\""
type subspace_section_aggregate_fields {
    avg: subspace_section_avg_fields
    count(columns: [subspace_section_select_column!], distinct: Boolean): Int!
    max: subspace_section_max_fields
    min: subspace_section_min_fields
    stddev: subspace_section_stddev_fields
    stddev_pop: subspace_section_stddev_pop_fields
    stddev_samp: subspace_section_stddev_samp_fields
    sum: subspace_section_sum_fields
    var_pop: subspace_section_var_pop_fields
    var_samp: subspace_section_var_samp_fields
    variance: subspace_section_variance_fields
}

"aggregate avg on columns"
type subspace_section_avg_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_section_max_fields {
    description: String
    height: bigint
    id: bigint
    name: String
    parent_row_id: bigint
    row_id: Int
    subspace_id: bigint
}

"aggregate min on columns"
type subspace_section_min_fields {
    description: String
    height: bigint
    id: bigint
    name: String
    parent_row_id: bigint
    row_id: Int
    subspace_id: bigint
}

"response of any mutation on the table \"subspace_section\""
type subspace_section_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_section!]!
}

"aggregate stddev on columns"
type subspace_section_stddev_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_section_stddev_pop_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_section_stddev_samp_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_section_sum_fields {
    height: bigint
    id: bigint
    parent_row_id: bigint
    row_id: Int
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_section_var_pop_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_section_var_samp_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_section_variance_fields {
    height: Float
    id: Float
    parent_row_id: Float
    row_id: Float
    subspace_id: Float
}

"aggregate stddev on columns"
type subspace_stddev_fields {
    height: Float
    id: Float
}

"aggregate stddev_pop on columns"
type subspace_stddev_pop_fields {
    height: Float
    id: Float
}

"aggregate stddev_samp on columns"
type subspace_stddev_samp_fields {
    height: Float
    id: Float
}

"aggregate sum on columns"
type subspace_sum_fields {
    height: bigint
    id: bigint
}

"columns and relationships of \"subspace_user_group\""
type subspace_user_group {
    description: String
    height: bigint!
    id: bigint!
    "An array relationship"
    members(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): [subspace_user_group_member!]!
    "An aggregate relationship"
    members_aggregate(
        "distinct select on columns"
        distinct_on: [subspace_user_group_member_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [subspace_user_group_member_order_by!],
        "filter the rows returned"
        where: subspace_user_group_member_bool_exp
    ): subspace_user_group_member_aggregate!
    name: String!
    permissions: _text
    row_id: Int!
    "An object relationship"
    section: subspace_section!
    section_row_id: bigint!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"subspace_user_group\""
type subspace_user_group_aggregate {
    aggregate: subspace_user_group_aggregate_fields
    nodes: [subspace_user_group!]!
}

"aggregate fields of \"subspace_user_group\""
type subspace_user_group_aggregate_fields {
    avg: subspace_user_group_avg_fields
    count(columns: [subspace_user_group_select_column!], distinct: Boolean): Int!
    max: subspace_user_group_max_fields
    min: subspace_user_group_min_fields
    stddev: subspace_user_group_stddev_fields
    stddev_pop: subspace_user_group_stddev_pop_fields
    stddev_samp: subspace_user_group_stddev_samp_fields
    sum: subspace_user_group_sum_fields
    var_pop: subspace_user_group_var_pop_fields
    var_samp: subspace_user_group_var_samp_fields
    variance: subspace_user_group_variance_fields
}

"aggregate avg on columns"
type subspace_user_group_avg_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type subspace_user_group_max_fields {
    description: String
    height: bigint
    id: bigint
    name: String
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"columns and relationships of \"subspace_user_group_member\""
type subspace_user_group_member {
    "An object relationship"
    group: subspace_user_group!
    group_row_id: bigint!
    height: bigint!
    member_address: String!
    row_id: Int!
}

"aggregated selection of \"subspace_user_group_member\""
type subspace_user_group_member_aggregate {
    aggregate: subspace_user_group_member_aggregate_fields
    nodes: [subspace_user_group_member!]!
}

"aggregate fields of \"subspace_user_group_member\""
type subspace_user_group_member_aggregate_fields {
    avg: subspace_user_group_member_avg_fields
    count(columns: [subspace_user_group_member_select_column!], distinct: Boolean): Int!
    max: subspace_user_group_member_max_fields
    min: subspace_user_group_member_min_fields
    stddev: subspace_user_group_member_stddev_fields
    stddev_pop: subspace_user_group_member_stddev_pop_fields
    stddev_samp: subspace_user_group_member_stddev_samp_fields
    sum: subspace_user_group_member_sum_fields
    var_pop: subspace_user_group_member_var_pop_fields
    var_samp: subspace_user_group_member_var_samp_fields
    variance: subspace_user_group_member_variance_fields
}

"aggregate avg on columns"
type subspace_user_group_member_avg_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate max on columns"
type subspace_user_group_member_max_fields {
    group_row_id: bigint
    height: bigint
    member_address: String
    row_id: Int
}

"aggregate min on columns"
type subspace_user_group_member_min_fields {
    group_row_id: bigint
    height: bigint
    member_address: String
    row_id: Int
}

"response of any mutation on the table \"subspace_user_group_member\""
type subspace_user_group_member_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_user_group_member!]!
}

"aggregate stddev on columns"
type subspace_user_group_member_stddev_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate stddev_pop on columns"
type subspace_user_group_member_stddev_pop_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate stddev_samp on columns"
type subspace_user_group_member_stddev_samp_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate sum on columns"
type subspace_user_group_member_sum_fields {
    group_row_id: bigint
    height: bigint
    row_id: Int
}

"aggregate var_pop on columns"
type subspace_user_group_member_var_pop_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate var_samp on columns"
type subspace_user_group_member_var_samp_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate variance on columns"
type subspace_user_group_member_variance_fields {
    group_row_id: Float
    height: Float
    row_id: Float
}

"aggregate min on columns"
type subspace_user_group_min_fields {
    description: String
    height: bigint
    id: bigint
    name: String
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"response of any mutation on the table \"subspace_user_group\""
type subspace_user_group_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_user_group!]!
}

"aggregate stddev on columns"
type subspace_user_group_stddev_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type subspace_user_group_stddev_pop_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type subspace_user_group_stddev_samp_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type subspace_user_group_sum_fields {
    height: bigint
    id: bigint
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type subspace_user_group_var_pop_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type subspace_user_group_var_samp_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type subspace_user_group_variance_fields {
    height: Float
    id: Float
    row_id: Float
    section_row_id: Float
    subspace_id: Float
}

"columns and relationships of \"subspace_user_permission\""
type subspace_user_permission {
    height: bigint!
    permissions: _text!
    row_id: Int!
    "An object relationship"
    section: subspace_section!
    section_row_id: bigint!
    user_address: String!
}

"aggregated selection of \"subspace_user_permission\""
type subspace_user_permission_aggregate {
    aggregate: subspace_user_permission_aggregate_fields
    nodes: [subspace_user_permission!]!
}

"aggregate fields of \"subspace_user_permission\""
type subspace_user_permission_aggregate_fields {
    avg: subspace_user_permission_avg_fields
    count(columns: [subspace_user_permission_select_column!], distinct: Boolean): Int!
    max: subspace_user_permission_max_fields
    min: subspace_user_permission_min_fields
    stddev: subspace_user_permission_stddev_fields
    stddev_pop: subspace_user_permission_stddev_pop_fields
    stddev_samp: subspace_user_permission_stddev_samp_fields
    sum: subspace_user_permission_sum_fields
    var_pop: subspace_user_permission_var_pop_fields
    var_samp: subspace_user_permission_var_samp_fields
    variance: subspace_user_permission_variance_fields
}

"aggregate avg on columns"
type subspace_user_permission_avg_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate max on columns"
type subspace_user_permission_max_fields {
    height: bigint
    row_id: Int
    section_row_id: bigint
    user_address: String
}

"aggregate min on columns"
type subspace_user_permission_min_fields {
    height: bigint
    row_id: Int
    section_row_id: bigint
    user_address: String
}

"response of any mutation on the table \"subspace_user_permission\""
type subspace_user_permission_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [subspace_user_permission!]!
}

"aggregate stddev on columns"
type subspace_user_permission_stddev_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate stddev_pop on columns"
type subspace_user_permission_stddev_pop_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate stddev_samp on columns"
type subspace_user_permission_stddev_samp_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate sum on columns"
type subspace_user_permission_sum_fields {
    height: bigint
    row_id: Int
    section_row_id: bigint
}

"aggregate var_pop on columns"
type subspace_user_permission_var_pop_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate var_samp on columns"
type subspace_user_permission_var_samp_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate variance on columns"
type subspace_user_permission_variance_fields {
    height: Float
    row_id: Float
    section_row_id: Float
}

"aggregate var_pop on columns"
type subspace_var_pop_fields {
    height: Float
    id: Float
}

"aggregate var_samp on columns"
type subspace_var_samp_fields {
    height: Float
    id: Float
}

"aggregate variance on columns"
type subspace_variance_fields {
    height: Float
    id: Float
}

"columns and relationships of \"tip_post\""
type tip_post {
    amount: _coin
    height: bigint!
    "An object relationship"
    post: post!
    post_row_id: bigint!
    "An object relationship"
    sender: profile
    sender_address: String!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"tip_post\""
type tip_post_aggregate {
    aggregate: tip_post_aggregate_fields
    nodes: [tip_post!]!
}

"aggregate fields of \"tip_post\""
type tip_post_aggregate_fields {
    avg: tip_post_avg_fields
    count(columns: [tip_post_select_column!], distinct: Boolean): Int!
    max: tip_post_max_fields
    min: tip_post_min_fields
    stddev: tip_post_stddev_fields
    stddev_pop: tip_post_stddev_pop_fields
    stddev_samp: tip_post_stddev_samp_fields
    sum: tip_post_sum_fields
    var_pop: tip_post_var_pop_fields
    var_samp: tip_post_var_samp_fields
    variance: tip_post_variance_fields
}

"aggregate avg on columns"
type tip_post_avg_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate max on columns"
type tip_post_max_fields {
    height: bigint
    post_row_id: bigint
    sender_address: String
    subspace_id: bigint
}

"aggregate min on columns"
type tip_post_min_fields {
    height: bigint
    post_row_id: bigint
    sender_address: String
    subspace_id: bigint
}

"response of any mutation on the table \"tip_post\""
type tip_post_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [tip_post!]!
}

"aggregate stddev on columns"
type tip_post_stddev_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type tip_post_stddev_pop_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type tip_post_stddev_samp_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate sum on columns"
type tip_post_sum_fields {
    height: bigint
    post_row_id: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type tip_post_var_pop_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type tip_post_var_samp_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"aggregate variance on columns"
type tip_post_variance_fields {
    height: Float
    post_row_id: Float
    subspace_id: Float
}

"columns and relationships of \"tip_user\""
type tip_user {
    amount: _coin
    height: bigint!
    "An object relationship"
    receiver: profile
    receiver_address: String!
    "An object relationship"
    sender: profile
    sender_address: String!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"tip_user\""
type tip_user_aggregate {
    aggregate: tip_user_aggregate_fields
    nodes: [tip_user!]!
}

"aggregate fields of \"tip_user\""
type tip_user_aggregate_fields {
    avg: tip_user_avg_fields
    count(columns: [tip_user_select_column!], distinct: Boolean): Int!
    max: tip_user_max_fields
    min: tip_user_min_fields
    stddev: tip_user_stddev_fields
    stddev_pop: tip_user_stddev_pop_fields
    stddev_samp: tip_user_stddev_samp_fields
    sum: tip_user_sum_fields
    var_pop: tip_user_var_pop_fields
    var_samp: tip_user_var_samp_fields
    variance: tip_user_variance_fields
}

"aggregate avg on columns"
type tip_user_avg_fields {
    height: Float
    subspace_id: Float
}

"aggregate max on columns"
type tip_user_max_fields {
    height: bigint
    receiver_address: String
    sender_address: String
    subspace_id: bigint
}

"aggregate min on columns"
type tip_user_min_fields {
    height: bigint
    receiver_address: String
    sender_address: String
    subspace_id: bigint
}

"response of any mutation on the table \"tip_user\""
type tip_user_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [tip_user!]!
}

"aggregate stddev on columns"
type tip_user_stddev_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type tip_user_stddev_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type tip_user_stddev_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate sum on columns"
type tip_user_sum_fields {
    height: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type tip_user_var_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type tip_user_var_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate variance on columns"
type tip_user_variance_fields {
    height: Float
    subspace_id: Float
}

"columns and relationships of \"user_block\""
type user_block {
    "An object relationship"
    blocked: profile!
    blocked_address: String!
    "An object relationship"
    blocker: profile!
    blocker_address: String!
    height: bigint!
    reason: String
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"user_block\""
type user_block_aggregate {
    aggregate: user_block_aggregate_fields
    nodes: [user_block!]!
}

"aggregate fields of \"user_block\""
type user_block_aggregate_fields {
    avg: user_block_avg_fields
    count(columns: [user_block_select_column!], distinct: Boolean): Int!
    max: user_block_max_fields
    min: user_block_min_fields
    stddev: user_block_stddev_fields
    stddev_pop: user_block_stddev_pop_fields
    stddev_samp: user_block_stddev_samp_fields
    sum: user_block_sum_fields
    var_pop: user_block_var_pop_fields
    var_samp: user_block_var_samp_fields
    variance: user_block_variance_fields
}

"aggregate avg on columns"
type user_block_avg_fields {
    height: Float
    subspace_id: Float
}

"aggregate max on columns"
type user_block_max_fields {
    blocked_address: String
    blocker_address: String
    height: bigint
    reason: String
    subspace_id: bigint
}

"aggregate min on columns"
type user_block_min_fields {
    blocked_address: String
    blocker_address: String
    height: bigint
    reason: String
    subspace_id: bigint
}

"response of any mutation on the table \"user_block\""
type user_block_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_block!]!
}

"aggregate stddev on columns"
type user_block_stddev_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type user_block_stddev_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type user_block_stddev_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate sum on columns"
type user_block_sum_fields {
    height: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type user_block_var_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type user_block_var_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate variance on columns"
type user_block_variance_fields {
    height: Float
    subspace_id: Float
}

"columns and relationships of \"user_relationship\""
type user_relationship {
    "An object relationship"
    counterparty: profile
    counterparty_address: String!
    "An object relationship"
    creator: profile
    creator_address: String!
    height: bigint!
    "An object relationship"
    subspace: subspace!
    subspace_id: bigint!
}

"aggregated selection of \"user_relationship\""
type user_relationship_aggregate {
    aggregate: user_relationship_aggregate_fields
    nodes: [user_relationship!]!
}

"aggregate fields of \"user_relationship\""
type user_relationship_aggregate_fields {
    avg: user_relationship_avg_fields
    count(columns: [user_relationship_select_column!], distinct: Boolean): Int!
    max: user_relationship_max_fields
    min: user_relationship_min_fields
    stddev: user_relationship_stddev_fields
    stddev_pop: user_relationship_stddev_pop_fields
    stddev_samp: user_relationship_stddev_samp_fields
    sum: user_relationship_sum_fields
    var_pop: user_relationship_var_pop_fields
    var_samp: user_relationship_var_samp_fields
    variance: user_relationship_variance_fields
}

"aggregate avg on columns"
type user_relationship_avg_fields {
    height: Float
    subspace_id: Float
}

"aggregate max on columns"
type user_relationship_max_fields {
    counterparty_address: String
    creator_address: String
    height: bigint
    subspace_id: bigint
}

"aggregate min on columns"
type user_relationship_min_fields {
    counterparty_address: String
    creator_address: String
    height: bigint
    subspace_id: bigint
}

"response of any mutation on the table \"user_relationship\""
type user_relationship_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_relationship!]!
}

"aggregate stddev on columns"
type user_relationship_stddev_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_pop on columns"
type user_relationship_stddev_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate stddev_samp on columns"
type user_relationship_stddev_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate sum on columns"
type user_relationship_sum_fields {
    height: bigint
    subspace_id: bigint
}

"aggregate var_pop on columns"
type user_relationship_var_pop_fields {
    height: Float
    subspace_id: Float
}

"aggregate var_samp on columns"
type user_relationship_var_samp_fields {
    height: Float
    subspace_id: Float
}

"aggregate variance on columns"
type user_relationship_variance_fields {
    height: Float
    subspace_id: Float
}

"unique or primary key constraints on table \"application_link\""
enum application_link_constraint {
    "unique or primary key constraint"
    application_link_pkey
    "unique or primary key constraint"
    unique_application_link
}

"unique or primary key constraints on table \"application_link_oracle_request\""
enum application_link_oracle_request_constraint {
    "unique or primary key constraint"
    application_link_oracle_request_pkey
    "unique or primary key constraint"
    unique_oracle_request
}

"select columns of table \"application_link_oracle_request\""
enum application_link_oracle_request_select_column {
    "column name"
    application_link_id
    "column name"
    call_data
    "column name"
    client_id
    "column name"
    height
    "column name"
    id
    "column name"
    request_id
    "column name"
    script_id
}

"update columns of table \"application_link_oracle_request\""
enum application_link_oracle_request_update_column {
    "column name"
    application_link_id
    "column name"
    call_data
    "column name"
    client_id
    "column name"
    height
    "column name"
    id
    "column name"
    request_id
    "column name"
    script_id
}

"unique or primary key constraints on table \"application_link_score\""
enum application_link_score_constraint {
    "unique or primary key constraint"
    application_link_score_application_link_row_id_key
}

"select columns of table \"application_link_score\""
enum application_link_score_select_column {
    "column name"
    application_link_row_id
    "column name"
    details
    "column name"
    id
    "column name"
    score
    "column name"
    timestamp
}

"update columns of table \"application_link_score\""
enum application_link_score_update_column {
    "column name"
    application_link_row_id
    "column name"
    details
    "column name"
    id
    "column name"
    score
    "column name"
    timestamp
}

"select columns of table \"application_link\""
enum application_link_select_column {
    "column name"
    application
    "column name"
    creation_time
    "column name"
    expiration_time
    "column name"
    height
    "column name"
    id
    "column name"
    result
    "column name"
    state
    "column name"
    user_address
    "column name"
    username
}

"update columns of table \"application_link\""
enum application_link_update_column {
    "column name"
    application
    "column name"
    creation_time
    "column name"
    expiration_time
    "column name"
    height
    "column name"
    id
    "column name"
    result
    "column name"
    state
    "column name"
    user_address
    "column name"
    username
}

"unique or primary key constraints on table \"authz_grant\""
enum authz_grant_constraint {
    "unique or primary key constraint"
    unique_msg_type_authorization
}

"select columns of table \"authz_grant\""
enum authz_grant_select_column {
    "column name"
    authorization
    "column name"
    expiration
    "column name"
    grantee_address
    "column name"
    granter_address
    "column name"
    height
    "column name"
    msg_type_url
}

"update columns of table \"authz_grant\""
enum authz_grant_update_column {
    "column name"
    authorization
    "column name"
    expiration
    "column name"
    grantee_address
    "column name"
    granter_address
    "column name"
    height
    "column name"
    msg_type_url
}

"unique or primary key constraints on table \"block\""
enum block_constraint {
    "unique or primary key constraint"
    block_hash_key
    "unique or primary key constraint"
    block_pkey
}

"select columns of table \"block\""
enum block_select_column {
    "column name"
    hash
    "column name"
    height
    "column name"
    num_txs
    "column name"
    proposer_address
    "column name"
    timestamp
    "column name"
    total_gas
}

"update columns of table \"block\""
enum block_update_column {
    "column name"
    hash
    "column name"
    height
    "column name"
    num_txs
    "column name"
    proposer_address
    "column name"
    timestamp
    "column name"
    total_gas
}

"unique or primary key constraints on table \"chain_link_chain_config\""
enum chain_link_chain_config_constraint {
    "unique or primary key constraint"
    chain_link_chain_config_pkey
    "unique or primary key constraint"
    unique_chain_config
}

"select columns of table \"chain_link_chain_config\""
enum chain_link_chain_config_select_column {
    "column name"
    id
    "column name"
    name
}

"update columns of table \"chain_link_chain_config\""
enum chain_link_chain_config_update_column {
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"chain_link\""
enum chain_link_constraint {
    "unique or primary key constraint"
    chain_link_pkey
    "unique or primary key constraint"
    unique_chain_link
}

"unique or primary key constraints on table \"chain_link_proof\""
enum chain_link_proof_constraint {
    "unique or primary key constraint"
    unique_proof_for_link
}

"select columns of table \"chain_link_proof\""
enum chain_link_proof_select_column {
    "column name"
    chain_link_id
    "column name"
    height
    "column name"
    id
    "column name"
    plain_text
    "column name"
    public_key
    "column name"
    signature
}

"update columns of table \"chain_link_proof\""
enum chain_link_proof_update_column {
    "column name"
    chain_link_id
    "column name"
    height
    "column name"
    id
    "column name"
    plain_text
    "column name"
    public_key
    "column name"
    signature
}

"select columns of table \"chain_link\""
enum chain_link_select_column {
    "column name"
    chain_config_id
    "column name"
    creation_time
    "column name"
    external_address
    "column name"
    height
    "column name"
    id
    "column name"
    user_address
}

"update columns of table \"chain_link\""
enum chain_link_update_column {
    "column name"
    chain_config_id
    "column name"
    creation_time
    "column name"
    external_address
    "column name"
    height
    "column name"
    id
    "column name"
    user_address
}

"unique or primary key constraints on table \"contract\""
enum contract_constraint {
    "unique or primary key constraint"
    contract_pkey
}

"select columns of table \"contract\""
enum contract_select_column {
    "column name"
    address
    "column name"
    config
    "column name"
    height
    "column name"
    type
}

"update columns of table \"contract\""
enum contract_update_column {
    "column name"
    address
    "column name"
    config
    "column name"
    height
    "column name"
    type
}

"unique or primary key constraints on table \"default_chain_link\""
enum default_chain_link_constraint {
    "unique or primary key constraint"
    default_chain_link_pkey
    "unique or primary key constraint"
    unique_default_chain_link
}

"select columns of table \"default_chain_link\""
enum default_chain_link_select_column {
    "column name"
    chain_config_id
    "column name"
    chain_link_id
    "column name"
    height
    "column name"
    id
    "column name"
    user_address
}

"update columns of table \"default_chain_link\""
enum default_chain_link_update_column {
    "column name"
    chain_config_id
    "column name"
    chain_link_id
    "column name"
    height
    "column name"
    id
    "column name"
    user_address
}

"unique or primary key constraints on table \"dtag_transfer_requests\""
enum dtag_transfer_requests_constraint {
    "unique or primary key constraint"
    unique_request
}

"select columns of table \"dtag_transfer_requests\""
enum dtag_transfer_requests_select_column {
    "column name"
    height
    "column name"
    receiver_address
    "column name"
    sender_address
}

"update columns of table \"dtag_transfer_requests\""
enum dtag_transfer_requests_update_column {
    "column name"
    height
    "column name"
    receiver_address
    "column name"
    sender_address
}

"unique or primary key constraints on table \"fee_grant\""
enum fee_grant_constraint {
    "unique or primary key constraint"
    unique_fee_grant
}

"select columns of table \"fee_grant\""
enum fee_grant_select_column {
    "column name"
    allowance
    "column name"
    expiration_date
    "column name"
    grantee_address
    "column name"
    granter_address
    "column name"
    height
    "column name"
    spend_limit
}

"update columns of table \"fee_grant\""
enum fee_grant_update_column {
    "column name"
    allowance
    "column name"
    expiration_date
    "column name"
    grantee_address
    "column name"
    granter_address
    "column name"
    height
    "column name"
    spend_limit
}

"unique or primary key constraints on table \"fees_params\""
enum fees_params_constraint {
    "unique or primary key constraint"
    fees_params_pkey
}

"select columns of table \"fees_params\""
enum fees_params_select_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"update columns of table \"fees_params\""
enum fees_params_update_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"unique or primary key constraints on table \"notification\""
enum notification_constraint {
    "unique or primary key constraint"
    unique_user_notification
}

"select columns of table \"notification\""
enum notification_select_column {
    "column name"
    data
    "column name"
    timestamp
    "column name"
    type
    "column name"
    user_address
}

"update columns of table \"notification\""
enum notification_update_column {
    "column name"
    data
    "column name"
    timestamp
    "column name"
    type
    "column name"
    user_address
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"poll_answer\""
enum poll_answer_constraint {
    "unique or primary key constraint"
    poll_answer_pkey
    "unique or primary key constraint"
    unique_user_answer
}

"select columns of table \"poll_answer\""
enum poll_answer_select_column {
    "column name"
    answers_indexes
    "column name"
    attachment_row_id
    "column name"
    height
    "column name"
    row_id
    "column name"
    user_address
}

"update columns of table \"poll_answer\""
enum poll_answer_update_column {
    "column name"
    answers_indexes
    "column name"
    attachment_row_id
    "column name"
    height
    "column name"
    row_id
    "column name"
    user_address
}

"unique or primary key constraints on table \"post_attachment\""
enum post_attachment_constraint {
    "unique or primary key constraint"
    post_attachment_pkey
    "unique or primary key constraint"
    unique_post_attachment
}

"select columns of table \"post_attachment\""
enum post_attachment_select_column {
    "column name"
    content
    "column name"
    height
    "column name"
    id
    "column name"
    post_row_id
    "column name"
    row_id
}

"update columns of table \"post_attachment\""
enum post_attachment_update_column {
    "column name"
    content
    "column name"
    height
    "column name"
    id
    "column name"
    post_row_id
    "column name"
    row_id
}

"unique or primary key constraints on table \"post\""
enum post_constraint {
    "unique or primary key constraint"
    post_pkey
    "unique or primary key constraint"
    unique_subspace_post
}

"unique or primary key constraints on table \"post_hashtag\""
enum post_hashtag_constraint {
    "unique or primary key constraint"
    post_hashtag_pkey
}

"select columns of table \"post_hashtag\""
enum post_hashtag_select_column {
    "column name"
    end_index
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
    "column name"
    tag
}

"update columns of table \"post_hashtag\""
enum post_hashtag_update_column {
    "column name"
    end_index
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
    "column name"
    tag
}

"unique or primary key constraints on table \"post_mention\""
enum post_mention_constraint {
    "unique or primary key constraint"
    post_mention_pkey
}

"select columns of table \"post_mention\""
enum post_mention_select_column {
    "column name"
    end_index
    "column name"
    mention_address
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
}

"update columns of table \"post_mention\""
enum post_mention_update_column {
    "column name"
    end_index
    "column name"
    mention_address
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
}

"unique or primary key constraints on table \"post_reference\""
enum post_reference_constraint {
    "unique or primary key constraint"
    post_reference_pkey
}

"select columns of table \"post_reference\""
enum post_reference_select_column {
    "column name"
    position_index
    "column name"
    post_row_id
    "column name"
    reference_row_id
    "column name"
    row_id
    "column name"
    type
}

"update columns of table \"post_reference\""
enum post_reference_update_column {
    "column name"
    position_index
    "column name"
    post_row_id
    "column name"
    reference_row_id
    "column name"
    row_id
    "column name"
    type
}

"select columns of table \"post\""
enum post_select_column {
    "column name"
    author_address
    "column name"
    conversation_row_id
    "column name"
    creation_date
    "column name"
    external_id
    "column name"
    height
    "column name"
    id
    "column name"
    last_edited_date
    "column name"
    reply_settings
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    subspace_id
    "column name"
    text
}

"unique or primary key constraints on table \"post_tag\""
enum post_tag_constraint {
    "unique or primary key constraint"
    post_tag_pkey
}

"select columns of table \"post_tag\""
enum post_tag_select_column {
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    tag
}

"update columns of table \"post_tag\""
enum post_tag_update_column {
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    tag
}

"unique or primary key constraints on table \"post_transaction\""
enum post_transaction_constraint {
    "unique or primary key constraint"
    post_tx_hash_pkey
    "unique or primary key constraint"
    unique_post_hash
}

"select columns of table \"post_transaction\""
enum post_transaction_select_column {
    "column name"
    hash
    "column name"
    post_row_id
    "column name"
    row_id
}

"update columns of table \"post_transaction\""
enum post_transaction_update_column {
    "column name"
    hash
    "column name"
    post_row_id
    "column name"
    row_id
}

"update columns of table \"post\""
enum post_update_column {
    "column name"
    author_address
    "column name"
    conversation_row_id
    "column name"
    creation_date
    "column name"
    external_id
    "column name"
    height
    "column name"
    id
    "column name"
    last_edited_date
    "column name"
    reply_settings
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    subspace_id
    "column name"
    text
}

"unique or primary key constraints on table \"post_url\""
enum post_url_constraint {
    "unique or primary key constraint"
    post_url_pkey
}

"select columns of table \"post_url\""
enum post_url_select_column {
    "column name"
    display_value
    "column name"
    end_index
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
    "column name"
    url
}

"update columns of table \"post_url\""
enum post_url_update_column {
    "column name"
    display_value
    "column name"
    end_index
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    start_index
    "column name"
    url
}

"unique or primary key constraints on table \"posts_params\""
enum posts_params_constraint {
    "unique or primary key constraint"
    posts_params_pkey
}

"select columns of table \"posts_params\""
enum posts_params_select_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"update columns of table \"posts_params\""
enum posts_params_update_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"unique or primary key constraints on table \"profile\""
enum profile_constraint {
    "unique or primary key constraint"
    profile_pkey
}

"select columns of table \"profile\""
enum profile_select_column {
    "column name"
    address
    "column name"
    bio
    "column name"
    cover_pic
    "column name"
    creation_time
    "column name"
    dtag
    "column name"
    height
    "column name"
    nickname
    "column name"
    profile_pic
}

"update columns of table \"profile\""
enum profile_update_column {
    "column name"
    address
    "column name"
    bio
    "column name"
    cover_pic
    "column name"
    creation_time
    "column name"
    dtag
    "column name"
    height
    "column name"
    nickname
    "column name"
    profile_pic
}

"unique or primary key constraints on table \"profiles_params\""
enum profiles_params_constraint {
    "unique or primary key constraint"
    profiles_params_pkey
}

"select columns of table \"profiles_params\""
enum profiles_params_select_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"update columns of table \"profiles_params\""
enum profiles_params_update_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"unique or primary key constraints on table \"reaction\""
enum reaction_constraint {
    "unique or primary key constraint"
    reaction_pkey
    "unique or primary key constraint"
    unique_post_reaction
}

"select columns of table \"reaction\""
enum reaction_select_column {
    "column name"
    author_address
    "column name"
    height
    "column name"
    id
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    value
}

"update columns of table \"reaction\""
enum reaction_update_column {
    "column name"
    author_address
    "column name"
    height
    "column name"
    id
    "column name"
    post_row_id
    "column name"
    row_id
    "column name"
    value
}

"unique or primary key constraints on table \"report\""
enum report_constraint {
    "unique or primary key constraint"
    report_pkey
    "unique or primary key constraint"
    unique_subspace_report
}

"unique or primary key constraints on table \"report_reason\""
enum report_reason_constraint {
    "unique or primary key constraint"
    unique_report_reason
}

"select columns of table \"report_reason\""
enum report_reason_select_column {
    "column name"
    reason_row_id
    "column name"
    report_row_id
}

"update columns of table \"report_reason\""
enum report_reason_update_column {
    "column name"
    reason_row_id
    "column name"
    report_row_id
}

"select columns of table \"report\""
enum report_select_column {
    "column name"
    creation_date
    "column name"
    height
    "column name"
    id
    "column name"
    message
    "column name"
    reporter_address
    "column name"
    row_id
    "column name"
    subspace_id
    "column name"
    target
}

"update columns of table \"report\""
enum report_update_column {
    "column name"
    creation_date
    "column name"
    height
    "column name"
    id
    "column name"
    message
    "column name"
    reporter_address
    "column name"
    row_id
    "column name"
    subspace_id
    "column name"
    target
}

"unique or primary key constraints on table \"reports_params\""
enum reports_params_constraint {
    "unique or primary key constraint"
    reports_params_pkey
}

"select columns of table \"reports_params\""
enum reports_params_select_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"update columns of table \"reports_params\""
enum reports_params_update_column {
    "column name"
    height
    "column name"
    one_row_id
    "column name"
    params
}

"unique or primary key constraints on table \"subspace\""
enum subspace_constraint {
    "unique or primary key constraint"
    subspace_pkey
}

"unique or primary key constraints on table \"subspace_free_text_params\""
enum subspace_free_text_params_constraint {
    "unique or primary key constraint"
    subspace_free_text_params_pkey
}

"select columns of table \"subspace_free_text_params\""
enum subspace_free_text_params_select_column {
    "column name"
    enabled
    "column name"
    height
    "column name"
    max_length
    "column name"
    reg_ex
    "column name"
    subspace_id
}

"update columns of table \"subspace_free_text_params\""
enum subspace_free_text_params_update_column {
    "column name"
    enabled
    "column name"
    height
    "column name"
    max_length
    "column name"
    reg_ex
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"subspace_registered_reaction\""
enum subspace_registered_reaction_constraint {
    "unique or primary key constraint"
    subspace_registered_reaction_pkey
    "unique or primary key constraint"
    unique_subspace_registered_reaction
}

"unique or primary key constraints on table \"subspace_registered_reaction_params\""
enum subspace_registered_reaction_params_constraint {
    "unique or primary key constraint"
    subspace_registered_reaction_params_pkey
}

"select columns of table \"subspace_registered_reaction_params\""
enum subspace_registered_reaction_params_select_column {
    "column name"
    enabled
    "column name"
    height
    "column name"
    subspace_id
}

"update columns of table \"subspace_registered_reaction_params\""
enum subspace_registered_reaction_params_update_column {
    "column name"
    enabled
    "column name"
    height
    "column name"
    subspace_id
}

"select columns of table \"subspace_registered_reaction\""
enum subspace_registered_reaction_select_column {
    "column name"
    display_value
    "column name"
    height
    "column name"
    id
    "column name"
    row_id
    "column name"
    shorthand_code
    "column name"
    subspace_id
}

"update columns of table \"subspace_registered_reaction\""
enum subspace_registered_reaction_update_column {
    "column name"
    display_value
    "column name"
    height
    "column name"
    id
    "column name"
    row_id
    "column name"
    shorthand_code
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"subspace_report_reason\""
enum subspace_report_reason_constraint {
    "unique or primary key constraint"
    subspace_report_reason_pkey
    "unique or primary key constraint"
    unique_subspace_reason
}

"select columns of table \"subspace_report_reason\""
enum subspace_report_reason_select_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    row_id
    "column name"
    subspace_id
    "column name"
    title
}

"update columns of table \"subspace_report_reason\""
enum subspace_report_reason_update_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    row_id
    "column name"
    subspace_id
    "column name"
    title
}

"unique or primary key constraints on table \"subspace_section\""
enum subspace_section_constraint {
    "unique or primary key constraint"
    subspace_section_pkey
    "unique or primary key constraint"
    unique_subspace_section
}

"select columns of table \"subspace_section\""
enum subspace_section_select_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    parent_row_id
    "column name"
    row_id
    "column name"
    subspace_id
}

"update columns of table \"subspace_section\""
enum subspace_section_update_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    parent_row_id
    "column name"
    row_id
    "column name"
    subspace_id
}

"select columns of table \"subspace\""
enum subspace_select_column {
    "column name"
    creation_time
    "column name"
    creator_address
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    owner_address
    "column name"
    treasury_address
}

"update columns of table \"subspace\""
enum subspace_update_column {
    "column name"
    creation_time
    "column name"
    creator_address
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    owner_address
    "column name"
    treasury_address
}

"unique or primary key constraints on table \"subspace_user_group\""
enum subspace_user_group_constraint {
    "unique or primary key constraint"
    subspace_user_group_pkey
    "unique or primary key constraint"
    unique_subspace_user_group
}

"unique or primary key constraints on table \"subspace_user_group_member\""
enum subspace_user_group_member_constraint {
    "unique or primary key constraint"
    unique_subspace_group_membership
}

"select columns of table \"subspace_user_group_member\""
enum subspace_user_group_member_select_column {
    "column name"
    group_row_id
    "column name"
    height
    "column name"
    member_address
    "column name"
    row_id
}

"update columns of table \"subspace_user_group_member\""
enum subspace_user_group_member_update_column {
    "column name"
    group_row_id
    "column name"
    height
    "column name"
    member_address
    "column name"
    row_id
}

"select columns of table \"subspace_user_group\""
enum subspace_user_group_select_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    permissions
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    subspace_id
}

"update columns of table \"subspace_user_group\""
enum subspace_user_group_update_column {
    "column name"
    description
    "column name"
    height
    "column name"
    id
    "column name"
    name
    "column name"
    permissions
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"subspace_user_permission\""
enum subspace_user_permission_constraint {
    "unique or primary key constraint"
    subspace_user_permission_pkey
    "unique or primary key constraint"
    unique_subspace_permission
}

"select columns of table \"subspace_user_permission\""
enum subspace_user_permission_select_column {
    "column name"
    height
    "column name"
    permissions
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    user_address
}

"update columns of table \"subspace_user_permission\""
enum subspace_user_permission_update_column {
    "column name"
    height
    "column name"
    permissions
    "column name"
    row_id
    "column name"
    section_row_id
    "column name"
    user_address
}

"unique or primary key constraints on table \"tip_post\""
enum tip_post_constraint {
    "unique or primary key constraint"
    unique_sender_post_tip
}

"select columns of table \"tip_post\""
enum tip_post_select_column {
    "column name"
    amount
    "column name"
    height
    "column name"
    post_row_id
    "column name"
    sender_address
    "column name"
    subspace_id
}

"update columns of table \"tip_post\""
enum tip_post_update_column {
    "column name"
    amount
    "column name"
    height
    "column name"
    post_row_id
    "column name"
    sender_address
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"tip_user\""
enum tip_user_constraint {
    "unique or primary key constraint"
    unique_sender_user_tip
}

"select columns of table \"tip_user\""
enum tip_user_select_column {
    "column name"
    amount
    "column name"
    height
    "column name"
    receiver_address
    "column name"
    sender_address
    "column name"
    subspace_id
}

"update columns of table \"tip_user\""
enum tip_user_update_column {
    "column name"
    amount
    "column name"
    height
    "column name"
    receiver_address
    "column name"
    sender_address
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"user_block\""
enum user_block_constraint {
    "unique or primary key constraint"
    unique_blockage
}

"select columns of table \"user_block\""
enum user_block_select_column {
    "column name"
    blocked_address
    "column name"
    blocker_address
    "column name"
    height
    "column name"
    reason
    "column name"
    subspace_id
}

"update columns of table \"user_block\""
enum user_block_update_column {
    "column name"
    blocked_address
    "column name"
    blocker_address
    "column name"
    height
    "column name"
    reason
    "column name"
    subspace_id
}

"unique or primary key constraints on table \"user_relationship\""
enum user_relationship_constraint {
    "unique or primary key constraint"
    unique_relationship
}

"select columns of table \"user_relationship\""
enum user_relationship_select_column {
    "column name"
    counterparty_address
    "column name"
    creator_address
    "column name"
    height
    "column name"
    subspace_id
}

"update columns of table \"user_relationship\""
enum user_relationship_update_column {
    "column name"
    counterparty_address
    "column name"
    creator_address
    "column name"
    height
    "column name"
    subspace_id
}

scalar _coin

scalar _int8

scalar _text

scalar bigint

scalar jsonb

scalar timestamp

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"_coin\". All fields are combined with logical 'AND'."
input _coin_comparison_exp {
    _eq: _coin
    _gt: _coin
    _gte: _coin
    _in: [_coin!]
    _is_null: Boolean
    _lt: _coin
    _lte: _coin
    _neq: _coin
    _nin: [_coin!]
}

"Boolean expression to compare columns of type \"_int8\". All fields are combined with logical 'AND'."
input _int8_comparison_exp {
    _eq: _int8
    _gt: _int8
    _gte: _int8
    _in: [_int8!]
    _is_null: Boolean
    _lt: _int8
    _lte: _int8
    _neq: _int8
    _nin: [_int8!]
}

"Boolean expression to compare columns of type \"_text\". All fields are combined with logical 'AND'."
input _text_comparison_exp {
    _eq: _text
    _gt: _text
    _gte: _text
    _in: [_text!]
    _is_null: Boolean
    _lt: _text
    _lte: _text
    _neq: _text
    _nin: [_text!]
}

"order by aggregate values of table \"application_link\""
input application_link_aggregate_order_by {
    avg: application_link_avg_order_by
    count: order_by
    max: application_link_max_order_by
    min: application_link_min_order_by
    stddev: application_link_stddev_order_by
    stddev_pop: application_link_stddev_pop_order_by
    stddev_samp: application_link_stddev_samp_order_by
    sum: application_link_sum_order_by
    var_pop: application_link_var_pop_order_by
    var_samp: application_link_var_samp_order_by
    variance: application_link_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input application_link_append_input {
    result: jsonb
}

"input type for inserting array relation for remote table \"application_link\""
input application_link_arr_rel_insert_input {
    data: [application_link_insert_input!]!
    "on conflict condition"
    on_conflict: application_link_on_conflict
}

"order by avg() on columns of table \"application_link\""
input application_link_avg_order_by {
    height: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"application_link\". All fields are combined with a logical 'AND'."
input application_link_bool_exp {
    _and: [application_link_bool_exp!]
    _not: application_link_bool_exp
    _or: [application_link_bool_exp!]
    application: String_comparison_exp
    application_link_oracle_requests: application_link_oracle_request_bool_exp
    creation_time: timestamp_comparison_exp
    expiration_time: timestamp_comparison_exp
    height: bigint_comparison_exp
    id: Int_comparison_exp
    oracle_request: application_link_oracle_request_bool_exp
    profile: profile_bool_exp
    result: jsonb_comparison_exp
    score: application_link_score_bool_exp
    state: String_comparison_exp
    user_address: String_comparison_exp
    username: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input application_link_delete_at_path_input {
    result: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input application_link_delete_elem_input {
    result: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input application_link_delete_key_input {
    result: String
}

"input type for incrementing numeric columns in table \"application_link\""
input application_link_inc_input {
    height: bigint
    id: Int
}

"input type for inserting data into table \"application_link\""
input application_link_insert_input {
    application: String
    application_link_oracle_requests: application_link_oracle_request_arr_rel_insert_input
    creation_time: timestamp
    expiration_time: timestamp
    height: bigint
    id: Int
    oracle_request: application_link_oracle_request_obj_rel_insert_input
    profile: profile_obj_rel_insert_input
    result: jsonb
    score: application_link_score_obj_rel_insert_input
    state: String
    user_address: String
    username: String
}

"order by max() on columns of table \"application_link\""
input application_link_max_order_by {
    application: order_by
    creation_time: order_by
    expiration_time: order_by
    height: order_by
    id: order_by
    state: order_by
    user_address: order_by
    username: order_by
}

"order by min() on columns of table \"application_link\""
input application_link_min_order_by {
    application: order_by
    creation_time: order_by
    expiration_time: order_by
    height: order_by
    id: order_by
    state: order_by
    user_address: order_by
    username: order_by
}

"input type for inserting object relation for remote table \"application_link\""
input application_link_obj_rel_insert_input {
    data: application_link_insert_input!
    "on conflict condition"
    on_conflict: application_link_on_conflict
}

"on conflict condition type for table \"application_link\""
input application_link_on_conflict {
    constraint: application_link_constraint!
    update_columns: [application_link_update_column!]! = []
    where: application_link_bool_exp
}

"order by aggregate values of table \"application_link_oracle_request\""
input application_link_oracle_request_aggregate_order_by {
    avg: application_link_oracle_request_avg_order_by
    count: order_by
    max: application_link_oracle_request_max_order_by
    min: application_link_oracle_request_min_order_by
    stddev: application_link_oracle_request_stddev_order_by
    stddev_pop: application_link_oracle_request_stddev_pop_order_by
    stddev_samp: application_link_oracle_request_stddev_samp_order_by
    sum: application_link_oracle_request_sum_order_by
    var_pop: application_link_oracle_request_var_pop_order_by
    var_samp: application_link_oracle_request_var_samp_order_by
    variance: application_link_oracle_request_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input application_link_oracle_request_append_input {
    call_data: jsonb
}

"input type for inserting array relation for remote table \"application_link_oracle_request\""
input application_link_oracle_request_arr_rel_insert_input {
    data: [application_link_oracle_request_insert_input!]!
    "on conflict condition"
    on_conflict: application_link_oracle_request_on_conflict
}

"order by avg() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_avg_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"application_link_oracle_request\". All fields are combined with a logical 'AND'."
input application_link_oracle_request_bool_exp {
    _and: [application_link_oracle_request_bool_exp!]
    _not: application_link_oracle_request_bool_exp
    _or: [application_link_oracle_request_bool_exp!]
    application_link: application_link_bool_exp
    application_link_id: bigint_comparison_exp
    call_data: jsonb_comparison_exp
    client_id: String_comparison_exp
    height: bigint_comparison_exp
    id: Int_comparison_exp
    request_id: String_comparison_exp
    script_id: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input application_link_oracle_request_delete_at_path_input {
    call_data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input application_link_oracle_request_delete_elem_input {
    call_data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input application_link_oracle_request_delete_key_input {
    call_data: String
}

"input type for incrementing numeric columns in table \"application_link_oracle_request\""
input application_link_oracle_request_inc_input {
    application_link_id: bigint
    height: bigint
    id: Int
}

"input type for inserting data into table \"application_link_oracle_request\""
input application_link_oracle_request_insert_input {
    application_link: application_link_obj_rel_insert_input
    application_link_id: bigint
    call_data: jsonb
    client_id: String
    height: bigint
    id: Int
    request_id: String
    script_id: String
}

"order by max() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_max_order_by {
    application_link_id: order_by
    client_id: order_by
    height: order_by
    id: order_by
    request_id: order_by
    script_id: order_by
}

"order by min() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_min_order_by {
    application_link_id: order_by
    client_id: order_by
    height: order_by
    id: order_by
    request_id: order_by
    script_id: order_by
}

"input type for inserting object relation for remote table \"application_link_oracle_request\""
input application_link_oracle_request_obj_rel_insert_input {
    data: application_link_oracle_request_insert_input!
    "on conflict condition"
    on_conflict: application_link_oracle_request_on_conflict
}

"on conflict condition type for table \"application_link_oracle_request\""
input application_link_oracle_request_on_conflict {
    constraint: application_link_oracle_request_constraint!
    update_columns: [application_link_oracle_request_update_column!]! = []
    where: application_link_oracle_request_bool_exp
}

"Ordering options when selecting data from \"application_link_oracle_request\"."
input application_link_oracle_request_order_by {
    application_link: application_link_order_by
    application_link_id: order_by
    call_data: order_by
    client_id: order_by
    height: order_by
    id: order_by
    request_id: order_by
    script_id: order_by
}

"primary key columns input for table: application_link_oracle_request"
input application_link_oracle_request_pk_columns_input {
    id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input application_link_oracle_request_prepend_input {
    call_data: jsonb
}

"input type for updating data in table \"application_link_oracle_request\""
input application_link_oracle_request_set_input {
    application_link_id: bigint
    call_data: jsonb
    client_id: String
    height: bigint
    id: Int
    request_id: String
    script_id: String
}

"order by stddev() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_pop_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_stddev_samp_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by sum() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_sum_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_pop() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_var_pop_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_samp() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_var_samp_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"order by variance() on columns of table \"application_link_oracle_request\""
input application_link_oracle_request_variance_order_by {
    application_link_id: order_by
    height: order_by
    id: order_by
}

"Ordering options when selecting data from \"application_link\"."
input application_link_order_by {
    application: order_by
    application_link_oracle_requests_aggregate: application_link_oracle_request_aggregate_order_by
    creation_time: order_by
    expiration_time: order_by
    height: order_by
    id: order_by
    oracle_request: application_link_oracle_request_order_by
    profile: profile_order_by
    result: order_by
    score: application_link_score_order_by
    state: order_by
    user_address: order_by
    username: order_by
}

"primary key columns input for table: application_link"
input application_link_pk_columns_input {
    id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input application_link_prepend_input {
    result: jsonb
}

"append existing jsonb value of filtered columns with new jsonb value"
input application_link_score_append_input {
    details: jsonb
}

"Boolean expression to filter rows from the table \"application_link_score\". All fields are combined with a logical 'AND'."
input application_link_score_bool_exp {
    _and: [application_link_score_bool_exp!]
    _not: application_link_score_bool_exp
    _or: [application_link_score_bool_exp!]
    application_link: application_link_bool_exp
    application_link_row_id: bigint_comparison_exp
    details: jsonb_comparison_exp
    id: Int_comparison_exp
    score: Int_comparison_exp
    timestamp: timestamp_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input application_link_score_delete_at_path_input {
    details: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input application_link_score_delete_elem_input {
    details: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input application_link_score_delete_key_input {
    details: String
}

"input type for incrementing numeric columns in table \"application_link_score\""
input application_link_score_inc_input {
    application_link_row_id: bigint
    id: Int
    score: Int
}

"input type for inserting data into table \"application_link_score\""
input application_link_score_insert_input {
    application_link: application_link_obj_rel_insert_input
    application_link_row_id: bigint
    details: jsonb
    id: Int
    score: Int
    timestamp: timestamp
}

"input type for inserting object relation for remote table \"application_link_score\""
input application_link_score_obj_rel_insert_input {
    data: application_link_score_insert_input!
    "on conflict condition"
    on_conflict: application_link_score_on_conflict
}

"on conflict condition type for table \"application_link_score\""
input application_link_score_on_conflict {
    constraint: application_link_score_constraint!
    update_columns: [application_link_score_update_column!]! = []
    where: application_link_score_bool_exp
}

"Ordering options when selecting data from \"application_link_score\"."
input application_link_score_order_by {
    application_link: application_link_order_by
    application_link_row_id: order_by
    details: order_by
    id: order_by
    score: order_by
    timestamp: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input application_link_score_prepend_input {
    details: jsonb
}

"input type for updating data in table \"application_link_score\""
input application_link_score_set_input {
    application_link_row_id: bigint
    details: jsonb
    id: Int
    score: Int
    timestamp: timestamp
}

"input type for updating data in table \"application_link\""
input application_link_set_input {
    application: String
    creation_time: timestamp
    expiration_time: timestamp
    height: bigint
    id: Int
    result: jsonb
    state: String
    user_address: String
    username: String
}

"order by stddev() on columns of table \"application_link\""
input application_link_stddev_order_by {
    height: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"application_link\""
input application_link_stddev_pop_order_by {
    height: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"application_link\""
input application_link_stddev_samp_order_by {
    height: order_by
    id: order_by
}

"order by sum() on columns of table \"application_link\""
input application_link_sum_order_by {
    height: order_by
    id: order_by
}

"order by var_pop() on columns of table \"application_link\""
input application_link_var_pop_order_by {
    height: order_by
    id: order_by
}

"order by var_samp() on columns of table \"application_link\""
input application_link_var_samp_order_by {
    height: order_by
    id: order_by
}

"order by variance() on columns of table \"application_link\""
input application_link_variance_order_by {
    height: order_by
    id: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input authz_grant_append_input {
    authorization: jsonb
}

"Boolean expression to filter rows from the table \"authz_grant\". All fields are combined with a logical 'AND'."
input authz_grant_bool_exp {
    _and: [authz_grant_bool_exp!]
    _not: authz_grant_bool_exp
    _or: [authz_grant_bool_exp!]
    authorization: jsonb_comparison_exp
    expiration: timestamp_comparison_exp
    grantee: profile_bool_exp
    grantee_address: String_comparison_exp
    granter: profile_bool_exp
    granter_address: String_comparison_exp
    height: bigint_comparison_exp
    msg_type_url: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input authz_grant_delete_at_path_input {
    authorization: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input authz_grant_delete_elem_input {
    authorization: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input authz_grant_delete_key_input {
    authorization: String
}

"input type for incrementing numeric columns in table \"authz_grant\""
input authz_grant_inc_input {
    height: bigint
}

"input type for inserting data into table \"authz_grant\""
input authz_grant_insert_input {
    authorization: jsonb
    expiration: timestamp
    grantee: profile_obj_rel_insert_input
    grantee_address: String
    granter: profile_obj_rel_insert_input
    granter_address: String
    height: bigint
    msg_type_url: String
}

"on conflict condition type for table \"authz_grant\""
input authz_grant_on_conflict {
    constraint: authz_grant_constraint!
    update_columns: [authz_grant_update_column!]! = []
    where: authz_grant_bool_exp
}

"Ordering options when selecting data from \"authz_grant\"."
input authz_grant_order_by {
    authorization: order_by
    expiration: order_by
    grantee: profile_order_by
    grantee_address: order_by
    granter: profile_order_by
    granter_address: order_by
    height: order_by
    msg_type_url: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input authz_grant_prepend_input {
    authorization: jsonb
}

"input type for updating data in table \"authz_grant\""
input authz_grant_set_input {
    authorization: jsonb
    expiration: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
    msg_type_url: String
}

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
    _eq: bigint
    _gt: bigint
    _gte: bigint
    _in: [bigint!]
    _is_null: Boolean
    _lt: bigint
    _lte: bigint
    _neq: bigint
    _nin: [bigint!]
}

"Boolean expression to filter rows from the table \"block\". All fields are combined with a logical 'AND'."
input block_bool_exp {
    _and: [block_bool_exp!]
    _not: block_bool_exp
    _or: [block_bool_exp!]
    hash: String_comparison_exp
    height: bigint_comparison_exp
    num_txs: Int_comparison_exp
    proposer_address: String_comparison_exp
    timestamp: timestamp_comparison_exp
    total_gas: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"block\""
input block_inc_input {
    height: bigint
    num_txs: Int
    total_gas: bigint
}

"input type for inserting data into table \"block\""
input block_insert_input {
    hash: String
    height: bigint
    num_txs: Int
    proposer_address: String
    timestamp: timestamp
    total_gas: bigint
}

"on conflict condition type for table \"block\""
input block_on_conflict {
    constraint: block_constraint!
    update_columns: [block_update_column!]! = []
    where: block_bool_exp
}

"Ordering options when selecting data from \"block\"."
input block_order_by {
    hash: order_by
    height: order_by
    num_txs: order_by
    proposer_address: order_by
    timestamp: order_by
    total_gas: order_by
}

"primary key columns input for table: block"
input block_pk_columns_input {
    height: bigint!
}

"input type for updating data in table \"block\""
input block_set_input {
    hash: String
    height: bigint
    num_txs: Int
    proposer_address: String
    timestamp: timestamp
    total_gas: bigint
}

"order by aggregate values of table \"chain_link\""
input chain_link_aggregate_order_by {
    avg: chain_link_avg_order_by
    count: order_by
    max: chain_link_max_order_by
    min: chain_link_min_order_by
    stddev: chain_link_stddev_order_by
    stddev_pop: chain_link_stddev_pop_order_by
    stddev_samp: chain_link_stddev_samp_order_by
    sum: chain_link_sum_order_by
    var_pop: chain_link_var_pop_order_by
    var_samp: chain_link_var_samp_order_by
    variance: chain_link_variance_order_by
}

"input type for inserting array relation for remote table \"chain_link\""
input chain_link_arr_rel_insert_input {
    data: [chain_link_insert_input!]!
    "on conflict condition"
    on_conflict: chain_link_on_conflict
}

"order by avg() on columns of table \"chain_link\""
input chain_link_avg_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"chain_link\". All fields are combined with a logical 'AND'."
input chain_link_bool_exp {
    _and: [chain_link_bool_exp!]
    _not: chain_link_bool_exp
    _or: [chain_link_bool_exp!]
    chain_config: chain_link_chain_config_bool_exp
    chain_config_id: bigint_comparison_exp
    chain_link_proofs: chain_link_proof_bool_exp
    creation_time: timestamp_comparison_exp
    default_chain_links: default_chain_link_bool_exp
    external_address: String_comparison_exp
    height: bigint_comparison_exp
    id: Int_comparison_exp
    profile: profile_bool_exp
    proof: chain_link_proof_bool_exp
    user_address: String_comparison_exp
}

"Boolean expression to filter rows from the table \"chain_link_chain_config\". All fields are combined with a logical 'AND'."
input chain_link_chain_config_bool_exp {
    _and: [chain_link_chain_config_bool_exp!]
    _not: chain_link_chain_config_bool_exp
    _or: [chain_link_chain_config_bool_exp!]
    chain_links: chain_link_bool_exp
    default_chain_links: default_chain_link_bool_exp
    id: Int_comparison_exp
    name: String_comparison_exp
}

"input type for incrementing numeric columns in table \"chain_link_chain_config\""
input chain_link_chain_config_inc_input {
    id: Int
}

"input type for inserting data into table \"chain_link_chain_config\""
input chain_link_chain_config_insert_input {
    chain_links: chain_link_arr_rel_insert_input
    default_chain_links: default_chain_link_arr_rel_insert_input
    id: Int
    name: String
}

"input type for inserting object relation for remote table \"chain_link_chain_config\""
input chain_link_chain_config_obj_rel_insert_input {
    data: chain_link_chain_config_insert_input!
    "on conflict condition"
    on_conflict: chain_link_chain_config_on_conflict
}

"on conflict condition type for table \"chain_link_chain_config\""
input chain_link_chain_config_on_conflict {
    constraint: chain_link_chain_config_constraint!
    update_columns: [chain_link_chain_config_update_column!]! = []
    where: chain_link_chain_config_bool_exp
}

"Ordering options when selecting data from \"chain_link_chain_config\"."
input chain_link_chain_config_order_by {
    chain_links_aggregate: chain_link_aggregate_order_by
    default_chain_links_aggregate: default_chain_link_aggregate_order_by
    id: order_by
    name: order_by
}

"primary key columns input for table: chain_link_chain_config"
input chain_link_chain_config_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"chain_link_chain_config\""
input chain_link_chain_config_set_input {
    id: Int
    name: String
}

"input type for incrementing numeric columns in table \"chain_link\""
input chain_link_inc_input {
    chain_config_id: bigint
    height: bigint
    id: Int
}

"input type for inserting data into table \"chain_link\""
input chain_link_insert_input {
    chain_config: chain_link_chain_config_obj_rel_insert_input
    chain_config_id: bigint
    chain_link_proofs: chain_link_proof_arr_rel_insert_input
    creation_time: timestamp
    default_chain_links: default_chain_link_arr_rel_insert_input
    external_address: String
    height: bigint
    id: Int
    profile: profile_obj_rel_insert_input
    proof: chain_link_proof_obj_rel_insert_input
    user_address: String
}

"order by max() on columns of table \"chain_link\""
input chain_link_max_order_by {
    chain_config_id: order_by
    creation_time: order_by
    external_address: order_by
    height: order_by
    id: order_by
    user_address: order_by
}

"order by min() on columns of table \"chain_link\""
input chain_link_min_order_by {
    chain_config_id: order_by
    creation_time: order_by
    external_address: order_by
    height: order_by
    id: order_by
    user_address: order_by
}

"input type for inserting object relation for remote table \"chain_link\""
input chain_link_obj_rel_insert_input {
    data: chain_link_insert_input!
    "on conflict condition"
    on_conflict: chain_link_on_conflict
}

"on conflict condition type for table \"chain_link\""
input chain_link_on_conflict {
    constraint: chain_link_constraint!
    update_columns: [chain_link_update_column!]! = []
    where: chain_link_bool_exp
}

"Ordering options when selecting data from \"chain_link\"."
input chain_link_order_by {
    chain_config: chain_link_chain_config_order_by
    chain_config_id: order_by
    chain_link_proofs_aggregate: chain_link_proof_aggregate_order_by
    creation_time: order_by
    default_chain_links_aggregate: default_chain_link_aggregate_order_by
    external_address: order_by
    height: order_by
    id: order_by
    profile: profile_order_by
    proof: chain_link_proof_order_by
    user_address: order_by
}

"primary key columns input for table: chain_link"
input chain_link_pk_columns_input {
    id: Int!
}

"order by aggregate values of table \"chain_link_proof\""
input chain_link_proof_aggregate_order_by {
    avg: chain_link_proof_avg_order_by
    count: order_by
    max: chain_link_proof_max_order_by
    min: chain_link_proof_min_order_by
    stddev: chain_link_proof_stddev_order_by
    stddev_pop: chain_link_proof_stddev_pop_order_by
    stddev_samp: chain_link_proof_stddev_samp_order_by
    sum: chain_link_proof_sum_order_by
    var_pop: chain_link_proof_var_pop_order_by
    var_samp: chain_link_proof_var_samp_order_by
    variance: chain_link_proof_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input chain_link_proof_append_input {
    public_key: jsonb
}

"input type for inserting array relation for remote table \"chain_link_proof\""
input chain_link_proof_arr_rel_insert_input {
    data: [chain_link_proof_insert_input!]!
    "on conflict condition"
    on_conflict: chain_link_proof_on_conflict
}

"order by avg() on columns of table \"chain_link_proof\""
input chain_link_proof_avg_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"chain_link_proof\". All fields are combined with a logical 'AND'."
input chain_link_proof_bool_exp {
    _and: [chain_link_proof_bool_exp!]
    _not: chain_link_proof_bool_exp
    _or: [chain_link_proof_bool_exp!]
    chain_link: chain_link_bool_exp
    chain_link_id: bigint_comparison_exp
    height: bigint_comparison_exp
    id: Int_comparison_exp
    plain_text: String_comparison_exp
    public_key: jsonb_comparison_exp
    signature: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input chain_link_proof_delete_at_path_input {
    public_key: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input chain_link_proof_delete_elem_input {
    public_key: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input chain_link_proof_delete_key_input {
    public_key: String
}

"input type for incrementing numeric columns in table \"chain_link_proof\""
input chain_link_proof_inc_input {
    chain_link_id: bigint
    height: bigint
    id: Int
}

"input type for inserting data into table \"chain_link_proof\""
input chain_link_proof_insert_input {
    chain_link: chain_link_obj_rel_insert_input
    chain_link_id: bigint
    height: bigint
    id: Int
    plain_text: String
    public_key: jsonb
    signature: String
}

"order by max() on columns of table \"chain_link_proof\""
input chain_link_proof_max_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
    plain_text: order_by
    signature: order_by
}

"order by min() on columns of table \"chain_link_proof\""
input chain_link_proof_min_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
    plain_text: order_by
    signature: order_by
}

"input type for inserting object relation for remote table \"chain_link_proof\""
input chain_link_proof_obj_rel_insert_input {
    data: chain_link_proof_insert_input!
    "on conflict condition"
    on_conflict: chain_link_proof_on_conflict
}

"on conflict condition type for table \"chain_link_proof\""
input chain_link_proof_on_conflict {
    constraint: chain_link_proof_constraint!
    update_columns: [chain_link_proof_update_column!]! = []
    where: chain_link_proof_bool_exp
}

"Ordering options when selecting data from \"chain_link_proof\"."
input chain_link_proof_order_by {
    chain_link: chain_link_order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
    plain_text: order_by
    public_key: order_by
    signature: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input chain_link_proof_prepend_input {
    public_key: jsonb
}

"input type for updating data in table \"chain_link_proof\""
input chain_link_proof_set_input {
    chain_link_id: bigint
    height: bigint
    id: Int
    plain_text: String
    public_key: jsonb
    signature: String
}

"order by stddev() on columns of table \"chain_link_proof\""
input chain_link_proof_stddev_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"chain_link_proof\""
input chain_link_proof_stddev_pop_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"chain_link_proof\""
input chain_link_proof_stddev_samp_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by sum() on columns of table \"chain_link_proof\""
input chain_link_proof_sum_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_pop() on columns of table \"chain_link_proof\""
input chain_link_proof_var_pop_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_samp() on columns of table \"chain_link_proof\""
input chain_link_proof_var_samp_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by variance() on columns of table \"chain_link_proof\""
input chain_link_proof_variance_order_by {
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"input type for updating data in table \"chain_link\""
input chain_link_set_input {
    chain_config_id: bigint
    creation_time: timestamp
    external_address: String
    height: bigint
    id: Int
    user_address: String
}

"order by stddev() on columns of table \"chain_link\""
input chain_link_stddev_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"chain_link\""
input chain_link_stddev_pop_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"chain_link\""
input chain_link_stddev_samp_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by sum() on columns of table \"chain_link\""
input chain_link_sum_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by var_pop() on columns of table \"chain_link\""
input chain_link_var_pop_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by var_samp() on columns of table \"chain_link\""
input chain_link_var_samp_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"order by variance() on columns of table \"chain_link\""
input chain_link_variance_order_by {
    chain_config_id: order_by
    height: order_by
    id: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input contract_append_input {
    config: jsonb
}

"Boolean expression to filter rows from the table \"contract\". All fields are combined with a logical 'AND'."
input contract_bool_exp {
    _and: [contract_bool_exp!]
    _not: contract_bool_exp
    _or: [contract_bool_exp!]
    address: String_comparison_exp
    config: jsonb_comparison_exp
    height: bigint_comparison_exp
    type: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input contract_delete_at_path_input {
    config: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input contract_delete_elem_input {
    config: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input contract_delete_key_input {
    config: String
}

"input type for incrementing numeric columns in table \"contract\""
input contract_inc_input {
    height: bigint
}

"input type for inserting data into table \"contract\""
input contract_insert_input {
    address: String
    config: jsonb
    height: bigint
    type: String
}

"on conflict condition type for table \"contract\""
input contract_on_conflict {
    constraint: contract_constraint!
    update_columns: [contract_update_column!]! = []
    where: contract_bool_exp
}

"Ordering options when selecting data from \"contract\"."
input contract_order_by {
    address: order_by
    config: order_by
    height: order_by
    type: order_by
}

"primary key columns input for table: contract"
input contract_pk_columns_input {
    address: String!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input contract_prepend_input {
    config: jsonb
}

"input type for updating data in table \"contract\""
input contract_set_input {
    address: String
    config: jsonb
    height: bigint
    type: String
}

"order by aggregate values of table \"default_chain_link\""
input default_chain_link_aggregate_order_by {
    avg: default_chain_link_avg_order_by
    count: order_by
    max: default_chain_link_max_order_by
    min: default_chain_link_min_order_by
    stddev: default_chain_link_stddev_order_by
    stddev_pop: default_chain_link_stddev_pop_order_by
    stddev_samp: default_chain_link_stddev_samp_order_by
    sum: default_chain_link_sum_order_by
    var_pop: default_chain_link_var_pop_order_by
    var_samp: default_chain_link_var_samp_order_by
    variance: default_chain_link_variance_order_by
}

"input type for inserting array relation for remote table \"default_chain_link\""
input default_chain_link_arr_rel_insert_input {
    data: [default_chain_link_insert_input!]!
    "on conflict condition"
    on_conflict: default_chain_link_on_conflict
}

"order by avg() on columns of table \"default_chain_link\""
input default_chain_link_avg_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"default_chain_link\". All fields are combined with a logical 'AND'."
input default_chain_link_bool_exp {
    _and: [default_chain_link_bool_exp!]
    _not: default_chain_link_bool_exp
    _or: [default_chain_link_bool_exp!]
    chain_config: chain_link_chain_config_bool_exp
    chain_config_id: bigint_comparison_exp
    chain_link: chain_link_bool_exp
    chain_link_id: bigint_comparison_exp
    height: bigint_comparison_exp
    id: Int_comparison_exp
    user_address: String_comparison_exp
}

"input type for incrementing numeric columns in table \"default_chain_link\""
input default_chain_link_inc_input {
    chain_config_id: bigint
    chain_link_id: bigint
    height: bigint
    id: Int
}

"input type for inserting data into table \"default_chain_link\""
input default_chain_link_insert_input {
    chain_config: chain_link_chain_config_obj_rel_insert_input
    chain_config_id: bigint
    chain_link: chain_link_obj_rel_insert_input
    chain_link_id: bigint
    height: bigint
    id: Int
    user_address: String
}

"order by max() on columns of table \"default_chain_link\""
input default_chain_link_max_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
    user_address: order_by
}

"order by min() on columns of table \"default_chain_link\""
input default_chain_link_min_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
    user_address: order_by
}

"on conflict condition type for table \"default_chain_link\""
input default_chain_link_on_conflict {
    constraint: default_chain_link_constraint!
    update_columns: [default_chain_link_update_column!]! = []
    where: default_chain_link_bool_exp
}

"Ordering options when selecting data from \"default_chain_link\"."
input default_chain_link_order_by {
    chain_config: chain_link_chain_config_order_by
    chain_config_id: order_by
    chain_link: chain_link_order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
    user_address: order_by
}

"primary key columns input for table: default_chain_link"
input default_chain_link_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"default_chain_link\""
input default_chain_link_set_input {
    chain_config_id: bigint
    chain_link_id: bigint
    height: bigint
    id: Int
    user_address: String
}

"order by stddev() on columns of table \"default_chain_link\""
input default_chain_link_stddev_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"default_chain_link\""
input default_chain_link_stddev_pop_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"default_chain_link\""
input default_chain_link_stddev_samp_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by sum() on columns of table \"default_chain_link\""
input default_chain_link_sum_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_pop() on columns of table \"default_chain_link\""
input default_chain_link_var_pop_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by var_samp() on columns of table \"default_chain_link\""
input default_chain_link_var_samp_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by variance() on columns of table \"default_chain_link\""
input default_chain_link_variance_order_by {
    chain_config_id: order_by
    chain_link_id: order_by
    height: order_by
    id: order_by
}

"order by aggregate values of table \"dtag_transfer_requests\""
input dtag_transfer_requests_aggregate_order_by {
    avg: dtag_transfer_requests_avg_order_by
    count: order_by
    max: dtag_transfer_requests_max_order_by
    min: dtag_transfer_requests_min_order_by
    stddev: dtag_transfer_requests_stddev_order_by
    stddev_pop: dtag_transfer_requests_stddev_pop_order_by
    stddev_samp: dtag_transfer_requests_stddev_samp_order_by
    sum: dtag_transfer_requests_sum_order_by
    var_pop: dtag_transfer_requests_var_pop_order_by
    var_samp: dtag_transfer_requests_var_samp_order_by
    variance: dtag_transfer_requests_variance_order_by
}

"input type for inserting array relation for remote table \"dtag_transfer_requests\""
input dtag_transfer_requests_arr_rel_insert_input {
    data: [dtag_transfer_requests_insert_input!]!
    "on conflict condition"
    on_conflict: dtag_transfer_requests_on_conflict
}

"order by avg() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_avg_order_by {
    height: order_by
}

"Boolean expression to filter rows from the table \"dtag_transfer_requests\". All fields are combined with a logical 'AND'."
input dtag_transfer_requests_bool_exp {
    _and: [dtag_transfer_requests_bool_exp!]
    _not: dtag_transfer_requests_bool_exp
    _or: [dtag_transfer_requests_bool_exp!]
    height: bigint_comparison_exp
    profile: profile_bool_exp
    profileBySenderAddress: profile_bool_exp
    receiver_address: String_comparison_exp
    sender_address: String_comparison_exp
}

"input type for incrementing numeric columns in table \"dtag_transfer_requests\""
input dtag_transfer_requests_inc_input {
    height: bigint
}

"input type for inserting data into table \"dtag_transfer_requests\""
input dtag_transfer_requests_insert_input {
    height: bigint
    profile: profile_obj_rel_insert_input
    profileBySenderAddress: profile_obj_rel_insert_input
    receiver_address: String
    sender_address: String
}

"order by max() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_max_order_by {
    height: order_by
    receiver_address: order_by
    sender_address: order_by
}

"order by min() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_min_order_by {
    height: order_by
    receiver_address: order_by
    sender_address: order_by
}

"on conflict condition type for table \"dtag_transfer_requests\""
input dtag_transfer_requests_on_conflict {
    constraint: dtag_transfer_requests_constraint!
    update_columns: [dtag_transfer_requests_update_column!]! = []
    where: dtag_transfer_requests_bool_exp
}

"Ordering options when selecting data from \"dtag_transfer_requests\"."
input dtag_transfer_requests_order_by {
    height: order_by
    profile: profile_order_by
    profileBySenderAddress: profile_order_by
    receiver_address: order_by
    sender_address: order_by
}

"input type for updating data in table \"dtag_transfer_requests\""
input dtag_transfer_requests_set_input {
    height: bigint
    receiver_address: String
    sender_address: String
}

"order by stddev() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_order_by {
    height: order_by
}

"order by stddev_pop() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_pop_order_by {
    height: order_by
}

"order by stddev_samp() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_stddev_samp_order_by {
    height: order_by
}

"order by sum() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_sum_order_by {
    height: order_by
}

"order by var_pop() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_var_pop_order_by {
    height: order_by
}

"order by var_samp() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_var_samp_order_by {
    height: order_by
}

"order by variance() on columns of table \"dtag_transfer_requests\""
input dtag_transfer_requests_variance_order_by {
    height: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input fee_grant_append_input {
    allowance: jsonb
}

"Boolean expression to filter rows from the table \"fee_grant\". All fields are combined with a logical 'AND'."
input fee_grant_bool_exp {
    _and: [fee_grant_bool_exp!]
    _not: fee_grant_bool_exp
    _or: [fee_grant_bool_exp!]
    allowance: jsonb_comparison_exp
    expiration_date: timestamp_comparison_exp
    grantee: profile_bool_exp
    grantee_address: String_comparison_exp
    granter: profile_bool_exp
    granter_address: String_comparison_exp
    height: bigint_comparison_exp
    spend_limit: _coin_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input fee_grant_delete_at_path_input {
    allowance: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input fee_grant_delete_elem_input {
    allowance: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input fee_grant_delete_key_input {
    allowance: String
}

"input type for incrementing numeric columns in table \"fee_grant\""
input fee_grant_inc_input {
    height: bigint
}

"input type for inserting data into table \"fee_grant\""
input fee_grant_insert_input {
    allowance: jsonb
    expiration_date: timestamp
    grantee: profile_obj_rel_insert_input
    grantee_address: String
    granter: profile_obj_rel_insert_input
    granter_address: String
    height: bigint
    spend_limit: _coin
}

"on conflict condition type for table \"fee_grant\""
input fee_grant_on_conflict {
    constraint: fee_grant_constraint!
    update_columns: [fee_grant_update_column!]! = []
    where: fee_grant_bool_exp
}

"Ordering options when selecting data from \"fee_grant\"."
input fee_grant_order_by {
    allowance: order_by
    expiration_date: order_by
    grantee: profile_order_by
    grantee_address: order_by
    granter: profile_order_by
    granter_address: order_by
    height: order_by
    spend_limit: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input fee_grant_prepend_input {
    allowance: jsonb
}

"input type for updating data in table \"fee_grant\""
input fee_grant_set_input {
    allowance: jsonb
    expiration_date: timestamp
    grantee_address: String
    granter_address: String
    height: bigint
    spend_limit: _coin
}

"append existing jsonb value of filtered columns with new jsonb value"
input fees_params_append_input {
    params: jsonb
}

"Boolean expression to filter rows from the table \"fees_params\". All fields are combined with a logical 'AND'."
input fees_params_bool_exp {
    _and: [fees_params_bool_exp!]
    _not: fees_params_bool_exp
    _or: [fees_params_bool_exp!]
    height: bigint_comparison_exp
    one_row_id: Boolean_comparison_exp
    params: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input fees_params_delete_at_path_input {
    params: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input fees_params_delete_elem_input {
    params: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input fees_params_delete_key_input {
    params: String
}

"input type for incrementing numeric columns in table \"fees_params\""
input fees_params_inc_input {
    height: bigint
}

"input type for inserting data into table \"fees_params\""
input fees_params_insert_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"on conflict condition type for table \"fees_params\""
input fees_params_on_conflict {
    constraint: fees_params_constraint!
    update_columns: [fees_params_update_column!]! = []
    where: fees_params_bool_exp
}

"Ordering options when selecting data from \"fees_params\"."
input fees_params_order_by {
    height: order_by
    one_row_id: order_by
    params: order_by
}

"primary key columns input for table: fees_params"
input fees_params_pk_columns_input {
    one_row_id: Boolean!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input fees_params_prepend_input {
    params: jsonb
}

"input type for updating data in table \"fees_params\""
input fees_params_set_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"append existing jsonb value of filtered columns with new jsonb value"
input notification_append_input {
    data: jsonb
}

"Boolean expression to filter rows from the table \"notification\". All fields are combined with a logical 'AND'."
input notification_bool_exp {
    _and: [notification_bool_exp!]
    _not: notification_bool_exp
    _or: [notification_bool_exp!]
    data: jsonb_comparison_exp
    timestamp: timestamp_comparison_exp
    type: String_comparison_exp
    user_address: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input notification_delete_at_path_input {
    data: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input notification_delete_elem_input {
    data: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input notification_delete_key_input {
    data: String
}

"input type for inserting data into table \"notification\""
input notification_insert_input {
    data: jsonb
    timestamp: timestamp
    type: String
    user_address: String
}

"on conflict condition type for table \"notification\""
input notification_on_conflict {
    constraint: notification_constraint!
    update_columns: [notification_update_column!]! = []
    where: notification_bool_exp
}

"Ordering options when selecting data from \"notification\"."
input notification_order_by {
    data: order_by
    timestamp: order_by
    type: order_by
    user_address: order_by
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input notification_prepend_input {
    data: jsonb
}

"input type for updating data in table \"notification\""
input notification_set_input {
    data: jsonb
    timestamp: timestamp
    type: String
    user_address: String
}

"order by aggregate values of table \"poll_answer\""
input poll_answer_aggregate_order_by {
    avg: poll_answer_avg_order_by
    count: order_by
    max: poll_answer_max_order_by
    min: poll_answer_min_order_by
    stddev: poll_answer_stddev_order_by
    stddev_pop: poll_answer_stddev_pop_order_by
    stddev_samp: poll_answer_stddev_samp_order_by
    sum: poll_answer_sum_order_by
    var_pop: poll_answer_var_pop_order_by
    var_samp: poll_answer_var_samp_order_by
    variance: poll_answer_variance_order_by
}

"input type for inserting array relation for remote table \"poll_answer\""
input poll_answer_arr_rel_insert_input {
    data: [poll_answer_insert_input!]!
    "on conflict condition"
    on_conflict: poll_answer_on_conflict
}

"order by avg() on columns of table \"poll_answer\""
input poll_answer_avg_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"poll_answer\". All fields are combined with a logical 'AND'."
input poll_answer_bool_exp {
    _and: [poll_answer_bool_exp!]
    _not: poll_answer_bool_exp
    _or: [poll_answer_bool_exp!]
    answers_indexes: _int8_comparison_exp
    attachment_row_id: bigint_comparison_exp
    height: bigint_comparison_exp
    post_attachment: post_attachment_bool_exp
    row_id: Int_comparison_exp
    user_address: String_comparison_exp
}

"input type for incrementing numeric columns in table \"poll_answer\""
input poll_answer_inc_input {
    attachment_row_id: bigint
    height: bigint
    row_id: Int
}

"input type for inserting data into table \"poll_answer\""
input poll_answer_insert_input {
    answers_indexes: _int8
    attachment_row_id: bigint
    height: bigint
    post_attachment: post_attachment_obj_rel_insert_input
    row_id: Int
    user_address: String
}

"order by max() on columns of table \"poll_answer\""
input poll_answer_max_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
    user_address: order_by
}

"order by min() on columns of table \"poll_answer\""
input poll_answer_min_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
    user_address: order_by
}

"on conflict condition type for table \"poll_answer\""
input poll_answer_on_conflict {
    constraint: poll_answer_constraint!
    update_columns: [poll_answer_update_column!]! = []
    where: poll_answer_bool_exp
}

"Ordering options when selecting data from \"poll_answer\"."
input poll_answer_order_by {
    answers_indexes: order_by
    attachment_row_id: order_by
    height: order_by
    post_attachment: post_attachment_order_by
    row_id: order_by
    user_address: order_by
}

"primary key columns input for table: poll_answer"
input poll_answer_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"poll_answer\""
input poll_answer_set_input {
    answers_indexes: _int8
    attachment_row_id: bigint
    height: bigint
    row_id: Int
    user_address: String
}

"order by stddev() on columns of table \"poll_answer\""
input poll_answer_stddev_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"poll_answer\""
input poll_answer_stddev_pop_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"poll_answer\""
input poll_answer_stddev_samp_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by sum() on columns of table \"poll_answer\""
input poll_answer_sum_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"poll_answer\""
input poll_answer_var_pop_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"poll_answer\""
input poll_answer_var_samp_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by variance() on columns of table \"poll_answer\""
input poll_answer_variance_order_by {
    attachment_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by aggregate values of table \"post\""
input post_aggregate_order_by {
    avg: post_avg_order_by
    count: order_by
    max: post_max_order_by
    min: post_min_order_by
    stddev: post_stddev_order_by
    stddev_pop: post_stddev_pop_order_by
    stddev_samp: post_stddev_samp_order_by
    sum: post_sum_order_by
    var_pop: post_var_pop_order_by
    var_samp: post_var_samp_order_by
    variance: post_variance_order_by
}

"input type for inserting array relation for remote table \"post\""
input post_arr_rel_insert_input {
    data: [post_insert_input!]!
    "on conflict condition"
    on_conflict: post_on_conflict
}

"order by aggregate values of table \"post_attachment\""
input post_attachment_aggregate_order_by {
    avg: post_attachment_avg_order_by
    count: order_by
    max: post_attachment_max_order_by
    min: post_attachment_min_order_by
    stddev: post_attachment_stddev_order_by
    stddev_pop: post_attachment_stddev_pop_order_by
    stddev_samp: post_attachment_stddev_samp_order_by
    sum: post_attachment_sum_order_by
    var_pop: post_attachment_var_pop_order_by
    var_samp: post_attachment_var_samp_order_by
    variance: post_attachment_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input post_attachment_append_input {
    content: jsonb
}

"input type for inserting array relation for remote table \"post_attachment\""
input post_attachment_arr_rel_insert_input {
    data: [post_attachment_insert_input!]!
    "on conflict condition"
    on_conflict: post_attachment_on_conflict
}

"order by avg() on columns of table \"post_attachment\""
input post_attachment_avg_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"post_attachment\". All fields are combined with a logical 'AND'."
input post_attachment_bool_exp {
    _and: [post_attachment_bool_exp!]
    _not: post_attachment_bool_exp
    _or: [post_attachment_bool_exp!]
    content: jsonb_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    poll_answers: poll_answer_bool_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input post_attachment_delete_at_path_input {
    content: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input post_attachment_delete_elem_input {
    content: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input post_attachment_delete_key_input {
    content: String
}

"input type for incrementing numeric columns in table \"post_attachment\""
input post_attachment_inc_input {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"input type for inserting data into table \"post_attachment\""
input post_attachment_insert_input {
    content: jsonb
    height: bigint
    id: bigint
    poll_answers: poll_answer_arr_rel_insert_input
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
}

"order by max() on columns of table \"post_attachment\""
input post_attachment_max_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by min() on columns of table \"post_attachment\""
input post_attachment_min_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"input type for inserting object relation for remote table \"post_attachment\""
input post_attachment_obj_rel_insert_input {
    data: post_attachment_insert_input!
    "on conflict condition"
    on_conflict: post_attachment_on_conflict
}

"on conflict condition type for table \"post_attachment\""
input post_attachment_on_conflict {
    constraint: post_attachment_constraint!
    update_columns: [post_attachment_update_column!]! = []
    where: post_attachment_bool_exp
}

"Ordering options when selecting data from \"post_attachment\"."
input post_attachment_order_by {
    content: order_by
    height: order_by
    id: order_by
    poll_answers_aggregate: poll_answer_aggregate_order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
}

"primary key columns input for table: post_attachment"
input post_attachment_pk_columns_input {
    row_id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input post_attachment_prepend_input {
    content: jsonb
}

"input type for updating data in table \"post_attachment\""
input post_attachment_set_input {
    content: jsonb
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"order by stddev() on columns of table \"post_attachment\""
input post_attachment_stddev_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"post_attachment\""
input post_attachment_stddev_pop_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"post_attachment\""
input post_attachment_stddev_samp_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by sum() on columns of table \"post_attachment\""
input post_attachment_sum_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"post_attachment\""
input post_attachment_var_pop_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"post_attachment\""
input post_attachment_var_samp_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by variance() on columns of table \"post_attachment\""
input post_attachment_variance_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by avg() on columns of table \"post\""
input post_avg_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"post\". All fields are combined with a logical 'AND'."
input post_bool_exp {
    _and: [post_bool_exp!]
    _not: post_bool_exp
    _or: [post_bool_exp!]
    attachments: post_attachment_bool_exp
    author: profile_bool_exp
    author_address: String_comparison_exp
    comments: post_bool_exp
    conversation: post_bool_exp
    conversation_row_id: bigint_comparison_exp
    creation_date: timestamp_comparison_exp
    external_id: String_comparison_exp
    hashtags: post_hashtag_bool_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    last_edited_date: timestamp_comparison_exp
    mentions: post_mention_bool_exp
    reactions: reaction_bool_exp
    referees: post_reference_bool_exp
    references: post_reference_bool_exp
    reply_settings: String_comparison_exp
    row_id: Int_comparison_exp
    section: subspace_section_bool_exp
    section_row_id: bigint_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
    tags: post_tag_bool_exp
    text: String_comparison_exp
    tips: tip_post_bool_exp
    transactions: post_transaction_bool_exp
    urls: post_url_bool_exp
}

"order by aggregate values of table \"post_hashtag\""
input post_hashtag_aggregate_order_by {
    avg: post_hashtag_avg_order_by
    count: order_by
    max: post_hashtag_max_order_by
    min: post_hashtag_min_order_by
    stddev: post_hashtag_stddev_order_by
    stddev_pop: post_hashtag_stddev_pop_order_by
    stddev_samp: post_hashtag_stddev_samp_order_by
    sum: post_hashtag_sum_order_by
    var_pop: post_hashtag_var_pop_order_by
    var_samp: post_hashtag_var_samp_order_by
    variance: post_hashtag_variance_order_by
}

"input type for inserting array relation for remote table \"post_hashtag\""
input post_hashtag_arr_rel_insert_input {
    data: [post_hashtag_insert_input!]!
    "on conflict condition"
    on_conflict: post_hashtag_on_conflict
}

"order by avg() on columns of table \"post_hashtag\""
input post_hashtag_avg_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"Boolean expression to filter rows from the table \"post_hashtag\". All fields are combined with a logical 'AND'."
input post_hashtag_bool_exp {
    _and: [post_hashtag_bool_exp!]
    _not: post_hashtag_bool_exp
    _or: [post_hashtag_bool_exp!]
    end_index: bigint_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    start_index: bigint_comparison_exp
    tag: String_comparison_exp
}

"input type for incrementing numeric columns in table \"post_hashtag\""
input post_hashtag_inc_input {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"input type for inserting data into table \"post_hashtag\""
input post_hashtag_insert_input {
    end_index: bigint
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    tag: String
}

"order by max() on columns of table \"post_hashtag\""
input post_hashtag_max_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    tag: order_by
}

"order by min() on columns of table \"post_hashtag\""
input post_hashtag_min_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    tag: order_by
}

"on conflict condition type for table \"post_hashtag\""
input post_hashtag_on_conflict {
    constraint: post_hashtag_constraint!
    update_columns: [post_hashtag_update_column!]! = []
    where: post_hashtag_bool_exp
}

"Ordering options when selecting data from \"post_hashtag\"."
input post_hashtag_order_by {
    end_index: order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    tag: order_by
}

"primary key columns input for table: post_hashtag"
input post_hashtag_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_hashtag\""
input post_hashtag_set_input {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    tag: String
}

"order by stddev() on columns of table \"post_hashtag\""
input post_hashtag_stddev_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_pop() on columns of table \"post_hashtag\""
input post_hashtag_stddev_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_samp() on columns of table \"post_hashtag\""
input post_hashtag_stddev_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by sum() on columns of table \"post_hashtag\""
input post_hashtag_sum_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_pop() on columns of table \"post_hashtag\""
input post_hashtag_var_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_samp() on columns of table \"post_hashtag\""
input post_hashtag_var_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by variance() on columns of table \"post_hashtag\""
input post_hashtag_variance_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"input type for incrementing numeric columns in table \"post\""
input post_inc_input {
    conversation_row_id: bigint
    height: bigint
    id: bigint
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"post\""
input post_insert_input {
    attachments: post_attachment_arr_rel_insert_input
    author: profile_obj_rel_insert_input
    author_address: String
    comments: post_arr_rel_insert_input
    conversation: post_obj_rel_insert_input
    conversation_row_id: bigint
    creation_date: timestamp
    external_id: String
    hashtags: post_hashtag_arr_rel_insert_input
    height: bigint
    id: bigint
    last_edited_date: timestamp
    mentions: post_mention_arr_rel_insert_input
    reactions: reaction_arr_rel_insert_input
    referees: post_reference_arr_rel_insert_input
    references: post_reference_arr_rel_insert_input
    reply_settings: String
    row_id: Int
    section: subspace_section_obj_rel_insert_input
    section_row_id: bigint
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
    tags: post_tag_arr_rel_insert_input
    text: String
    tips: tip_post_arr_rel_insert_input
    transactions: post_transaction_arr_rel_insert_input
    urls: post_url_arr_rel_insert_input
}

"order by max() on columns of table \"post\""
input post_max_order_by {
    author_address: order_by
    conversation_row_id: order_by
    creation_date: order_by
    external_id: order_by
    height: order_by
    id: order_by
    last_edited_date: order_by
    reply_settings: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
    text: order_by
}

"order by aggregate values of table \"post_mention\""
input post_mention_aggregate_order_by {
    avg: post_mention_avg_order_by
    count: order_by
    max: post_mention_max_order_by
    min: post_mention_min_order_by
    stddev: post_mention_stddev_order_by
    stddev_pop: post_mention_stddev_pop_order_by
    stddev_samp: post_mention_stddev_samp_order_by
    sum: post_mention_sum_order_by
    var_pop: post_mention_var_pop_order_by
    var_samp: post_mention_var_samp_order_by
    variance: post_mention_variance_order_by
}

"input type for inserting array relation for remote table \"post_mention\""
input post_mention_arr_rel_insert_input {
    data: [post_mention_insert_input!]!
    "on conflict condition"
    on_conflict: post_mention_on_conflict
}

"order by avg() on columns of table \"post_mention\""
input post_mention_avg_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"Boolean expression to filter rows from the table \"post_mention\". All fields are combined with a logical 'AND'."
input post_mention_bool_exp {
    _and: [post_mention_bool_exp!]
    _not: post_mention_bool_exp
    _or: [post_mention_bool_exp!]
    end_index: bigint_comparison_exp
    mention: profile_bool_exp
    mention_address: String_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    start_index: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"post_mention\""
input post_mention_inc_input {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"input type for inserting data into table \"post_mention\""
input post_mention_insert_input {
    end_index: bigint
    mention: profile_obj_rel_insert_input
    mention_address: String
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"order by max() on columns of table \"post_mention\""
input post_mention_max_order_by {
    end_index: order_by
    mention_address: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by min() on columns of table \"post_mention\""
input post_mention_min_order_by {
    end_index: order_by
    mention_address: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"on conflict condition type for table \"post_mention\""
input post_mention_on_conflict {
    constraint: post_mention_constraint!
    update_columns: [post_mention_update_column!]! = []
    where: post_mention_bool_exp
}

"Ordering options when selecting data from \"post_mention\"."
input post_mention_order_by {
    end_index: order_by
    mention: profile_order_by
    mention_address: order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"primary key columns input for table: post_mention"
input post_mention_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_mention\""
input post_mention_set_input {
    end_index: bigint
    mention_address: String
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"order by stddev() on columns of table \"post_mention\""
input post_mention_stddev_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_pop() on columns of table \"post_mention\""
input post_mention_stddev_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_samp() on columns of table \"post_mention\""
input post_mention_stddev_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by sum() on columns of table \"post_mention\""
input post_mention_sum_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_pop() on columns of table \"post_mention\""
input post_mention_var_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_samp() on columns of table \"post_mention\""
input post_mention_var_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by variance() on columns of table \"post_mention\""
input post_mention_variance_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by min() on columns of table \"post\""
input post_min_order_by {
    author_address: order_by
    conversation_row_id: order_by
    creation_date: order_by
    external_id: order_by
    height: order_by
    id: order_by
    last_edited_date: order_by
    reply_settings: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
    text: order_by
}

"input type for inserting object relation for remote table \"post\""
input post_obj_rel_insert_input {
    data: post_insert_input!
    "on conflict condition"
    on_conflict: post_on_conflict
}

"on conflict condition type for table \"post\""
input post_on_conflict {
    constraint: post_constraint!
    update_columns: [post_update_column!]! = []
    where: post_bool_exp
}

"Ordering options when selecting data from \"post\"."
input post_order_by {
    attachments_aggregate: post_attachment_aggregate_order_by
    author: profile_order_by
    author_address: order_by
    comments_aggregate: post_aggregate_order_by
    conversation: post_order_by
    conversation_row_id: order_by
    creation_date: order_by
    external_id: order_by
    hashtags_aggregate: post_hashtag_aggregate_order_by
    height: order_by
    id: order_by
    last_edited_date: order_by
    mentions_aggregate: post_mention_aggregate_order_by
    reactions_aggregate: reaction_aggregate_order_by
    referees_aggregate: post_reference_aggregate_order_by
    references_aggregate: post_reference_aggregate_order_by
    reply_settings: order_by
    row_id: order_by
    section: subspace_section_order_by
    section_row_id: order_by
    subspace: subspace_order_by
    subspace_id: order_by
    tags_aggregate: post_tag_aggregate_order_by
    text: order_by
    tips_aggregate: tip_post_aggregate_order_by
    transactions_aggregate: post_transaction_aggregate_order_by
    urls_aggregate: post_url_aggregate_order_by
}

"primary key columns input for table: post"
input post_pk_columns_input {
    row_id: Int!
}

"order by aggregate values of table \"post_reference\""
input post_reference_aggregate_order_by {
    avg: post_reference_avg_order_by
    count: order_by
    max: post_reference_max_order_by
    min: post_reference_min_order_by
    stddev: post_reference_stddev_order_by
    stddev_pop: post_reference_stddev_pop_order_by
    stddev_samp: post_reference_stddev_samp_order_by
    sum: post_reference_sum_order_by
    var_pop: post_reference_var_pop_order_by
    var_samp: post_reference_var_samp_order_by
    variance: post_reference_variance_order_by
}

"input type for inserting array relation for remote table \"post_reference\""
input post_reference_arr_rel_insert_input {
    data: [post_reference_insert_input!]!
    "on conflict condition"
    on_conflict: post_reference_on_conflict
}

"order by avg() on columns of table \"post_reference\""
input post_reference_avg_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"post_reference\". All fields are combined with a logical 'AND'."
input post_reference_bool_exp {
    _and: [post_reference_bool_exp!]
    _not: post_reference_bool_exp
    _or: [post_reference_bool_exp!]
    position_index: bigint_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    reference: post_bool_exp
    reference_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    type: String_comparison_exp
}

"input type for incrementing numeric columns in table \"post_reference\""
input post_reference_inc_input {
    position_index: bigint
    post_row_id: bigint
    reference_row_id: bigint
    row_id: Int
}

"input type for inserting data into table \"post_reference\""
input post_reference_insert_input {
    position_index: bigint
    post: post_obj_rel_insert_input
    post_row_id: bigint
    reference: post_obj_rel_insert_input
    reference_row_id: bigint
    row_id: Int
    type: String
}

"order by max() on columns of table \"post_reference\""
input post_reference_max_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
    type: order_by
}

"order by min() on columns of table \"post_reference\""
input post_reference_min_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
    type: order_by
}

"on conflict condition type for table \"post_reference\""
input post_reference_on_conflict {
    constraint: post_reference_constraint!
    update_columns: [post_reference_update_column!]! = []
    where: post_reference_bool_exp
}

"Ordering options when selecting data from \"post_reference\"."
input post_reference_order_by {
    position_index: order_by
    post: post_order_by
    post_row_id: order_by
    reference: post_order_by
    reference_row_id: order_by
    row_id: order_by
    type: order_by
}

"primary key columns input for table: post_reference"
input post_reference_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_reference\""
input post_reference_set_input {
    position_index: bigint
    post_row_id: bigint
    reference_row_id: bigint
    row_id: Int
    type: String
}

"order by stddev() on columns of table \"post_reference\""
input post_reference_stddev_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"post_reference\""
input post_reference_stddev_pop_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"post_reference\""
input post_reference_stddev_samp_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by sum() on columns of table \"post_reference\""
input post_reference_sum_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"post_reference\""
input post_reference_var_pop_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"post_reference\""
input post_reference_var_samp_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"order by variance() on columns of table \"post_reference\""
input post_reference_variance_order_by {
    position_index: order_by
    post_row_id: order_by
    reference_row_id: order_by
    row_id: order_by
}

"input type for updating data in table \"post\""
input post_set_input {
    author_address: String
    conversation_row_id: bigint
    creation_date: timestamp
    external_id: String
    height: bigint
    id: bigint
    last_edited_date: timestamp
    reply_settings: String
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
    text: String
}

"order by stddev() on columns of table \"post\""
input post_stddev_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"post\""
input post_stddev_pop_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"post\""
input post_stddev_samp_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"post\""
input post_sum_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"post_tag\""
input post_tag_aggregate_order_by {
    avg: post_tag_avg_order_by
    count: order_by
    max: post_tag_max_order_by
    min: post_tag_min_order_by
    stddev: post_tag_stddev_order_by
    stddev_pop: post_tag_stddev_pop_order_by
    stddev_samp: post_tag_stddev_samp_order_by
    sum: post_tag_sum_order_by
    var_pop: post_tag_var_pop_order_by
    var_samp: post_tag_var_samp_order_by
    variance: post_tag_variance_order_by
}

"input type for inserting array relation for remote table \"post_tag\""
input post_tag_arr_rel_insert_input {
    data: [post_tag_insert_input!]!
    "on conflict condition"
    on_conflict: post_tag_on_conflict
}

"order by avg() on columns of table \"post_tag\""
input post_tag_avg_order_by {
    post_row_id: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"post_tag\". All fields are combined with a logical 'AND'."
input post_tag_bool_exp {
    _and: [post_tag_bool_exp!]
    _not: post_tag_bool_exp
    _or: [post_tag_bool_exp!]
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    tag: String_comparison_exp
}

"input type for incrementing numeric columns in table \"post_tag\""
input post_tag_inc_input {
    post_row_id: bigint
    row_id: Int
}

"input type for inserting data into table \"post_tag\""
input post_tag_insert_input {
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
    tag: String
}

"order by max() on columns of table \"post_tag\""
input post_tag_max_order_by {
    post_row_id: order_by
    row_id: order_by
    tag: order_by
}

"order by min() on columns of table \"post_tag\""
input post_tag_min_order_by {
    post_row_id: order_by
    row_id: order_by
    tag: order_by
}

"on conflict condition type for table \"post_tag\""
input post_tag_on_conflict {
    constraint: post_tag_constraint!
    update_columns: [post_tag_update_column!]! = []
    where: post_tag_bool_exp
}

"Ordering options when selecting data from \"post_tag\"."
input post_tag_order_by {
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
    tag: order_by
}

"primary key columns input for table: post_tag"
input post_tag_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_tag\""
input post_tag_set_input {
    post_row_id: bigint
    row_id: Int
    tag: String
}

"order by stddev() on columns of table \"post_tag\""
input post_tag_stddev_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"post_tag\""
input post_tag_stddev_pop_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"post_tag\""
input post_tag_stddev_samp_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by sum() on columns of table \"post_tag\""
input post_tag_sum_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"post_tag\""
input post_tag_var_pop_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"post_tag\""
input post_tag_var_samp_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by variance() on columns of table \"post_tag\""
input post_tag_variance_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by aggregate values of table \"post_transaction\""
input post_transaction_aggregate_order_by {
    avg: post_transaction_avg_order_by
    count: order_by
    max: post_transaction_max_order_by
    min: post_transaction_min_order_by
    stddev: post_transaction_stddev_order_by
    stddev_pop: post_transaction_stddev_pop_order_by
    stddev_samp: post_transaction_stddev_samp_order_by
    sum: post_transaction_sum_order_by
    var_pop: post_transaction_var_pop_order_by
    var_samp: post_transaction_var_samp_order_by
    variance: post_transaction_variance_order_by
}

"input type for inserting array relation for remote table \"post_transaction\""
input post_transaction_arr_rel_insert_input {
    data: [post_transaction_insert_input!]!
    "on conflict condition"
    on_conflict: post_transaction_on_conflict
}

"order by avg() on columns of table \"post_transaction\""
input post_transaction_avg_order_by {
    post_row_id: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"post_transaction\". All fields are combined with a logical 'AND'."
input post_transaction_bool_exp {
    _and: [post_transaction_bool_exp!]
    _not: post_transaction_bool_exp
    _or: [post_transaction_bool_exp!]
    hash: String_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"post_transaction\""
input post_transaction_inc_input {
    post_row_id: bigint
    row_id: Int
}

"input type for inserting data into table \"post_transaction\""
input post_transaction_insert_input {
    hash: String
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
}

"order by max() on columns of table \"post_transaction\""
input post_transaction_max_order_by {
    hash: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by min() on columns of table \"post_transaction\""
input post_transaction_min_order_by {
    hash: order_by
    post_row_id: order_by
    row_id: order_by
}

"on conflict condition type for table \"post_transaction\""
input post_transaction_on_conflict {
    constraint: post_transaction_constraint!
    update_columns: [post_transaction_update_column!]! = []
    where: post_transaction_bool_exp
}

"Ordering options when selecting data from \"post_transaction\"."
input post_transaction_order_by {
    hash: order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
}

"primary key columns input for table: post_transaction"
input post_transaction_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_transaction\""
input post_transaction_set_input {
    hash: String
    post_row_id: bigint
    row_id: Int
}

"order by stddev() on columns of table \"post_transaction\""
input post_transaction_stddev_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"post_transaction\""
input post_transaction_stddev_pop_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"post_transaction\""
input post_transaction_stddev_samp_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by sum() on columns of table \"post_transaction\""
input post_transaction_sum_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"post_transaction\""
input post_transaction_var_pop_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"post_transaction\""
input post_transaction_var_samp_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by variance() on columns of table \"post_transaction\""
input post_transaction_variance_order_by {
    post_row_id: order_by
    row_id: order_by
}

"order by aggregate values of table \"post_url\""
input post_url_aggregate_order_by {
    avg: post_url_avg_order_by
    count: order_by
    max: post_url_max_order_by
    min: post_url_min_order_by
    stddev: post_url_stddev_order_by
    stddev_pop: post_url_stddev_pop_order_by
    stddev_samp: post_url_stddev_samp_order_by
    sum: post_url_sum_order_by
    var_pop: post_url_var_pop_order_by
    var_samp: post_url_var_samp_order_by
    variance: post_url_variance_order_by
}

"input type for inserting array relation for remote table \"post_url\""
input post_url_arr_rel_insert_input {
    data: [post_url_insert_input!]!
    "on conflict condition"
    on_conflict: post_url_on_conflict
}

"order by avg() on columns of table \"post_url\""
input post_url_avg_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"Boolean expression to filter rows from the table \"post_url\". All fields are combined with a logical 'AND'."
input post_url_bool_exp {
    _and: [post_url_bool_exp!]
    _not: post_url_bool_exp
    _or: [post_url_bool_exp!]
    display_value: String_comparison_exp
    end_index: bigint_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    start_index: bigint_comparison_exp
    url: String_comparison_exp
}

"input type for incrementing numeric columns in table \"post_url\""
input post_url_inc_input {
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
}

"input type for inserting data into table \"post_url\""
input post_url_insert_input {
    display_value: String
    end_index: bigint
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    url: String
}

"order by max() on columns of table \"post_url\""
input post_url_max_order_by {
    display_value: order_by
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    url: order_by
}

"order by min() on columns of table \"post_url\""
input post_url_min_order_by {
    display_value: order_by
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    url: order_by
}

"on conflict condition type for table \"post_url\""
input post_url_on_conflict {
    constraint: post_url_constraint!
    update_columns: [post_url_update_column!]! = []
    where: post_url_bool_exp
}

"Ordering options when selecting data from \"post_url\"."
input post_url_order_by {
    display_value: order_by
    end_index: order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
    url: order_by
}

"primary key columns input for table: post_url"
input post_url_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"post_url\""
input post_url_set_input {
    display_value: String
    end_index: bigint
    post_row_id: bigint
    row_id: Int
    start_index: bigint
    url: String
}

"order by stddev() on columns of table \"post_url\""
input post_url_stddev_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_pop() on columns of table \"post_url\""
input post_url_stddev_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by stddev_samp() on columns of table \"post_url\""
input post_url_stddev_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by sum() on columns of table \"post_url\""
input post_url_sum_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_pop() on columns of table \"post_url\""
input post_url_var_pop_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_samp() on columns of table \"post_url\""
input post_url_var_samp_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by variance() on columns of table \"post_url\""
input post_url_variance_order_by {
    end_index: order_by
    post_row_id: order_by
    row_id: order_by
    start_index: order_by
}

"order by var_pop() on columns of table \"post\""
input post_var_pop_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"post\""
input post_var_samp_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"post\""
input post_variance_order_by {
    conversation_row_id: order_by
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input posts_params_append_input {
    params: jsonb
}

"Boolean expression to filter rows from the table \"posts_params\". All fields are combined with a logical 'AND'."
input posts_params_bool_exp {
    _and: [posts_params_bool_exp!]
    _not: posts_params_bool_exp
    _or: [posts_params_bool_exp!]
    height: bigint_comparison_exp
    one_row_id: Boolean_comparison_exp
    params: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input posts_params_delete_at_path_input {
    params: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input posts_params_delete_elem_input {
    params: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input posts_params_delete_key_input {
    params: String
}

"input type for incrementing numeric columns in table \"posts_params\""
input posts_params_inc_input {
    height: bigint
}

"input type for inserting data into table \"posts_params\""
input posts_params_insert_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"on conflict condition type for table \"posts_params\""
input posts_params_on_conflict {
    constraint: posts_params_constraint!
    update_columns: [posts_params_update_column!]! = []
    where: posts_params_bool_exp
}

"Ordering options when selecting data from \"posts_params\"."
input posts_params_order_by {
    height: order_by
    one_row_id: order_by
    params: order_by
}

"primary key columns input for table: posts_params"
input posts_params_pk_columns_input {
    one_row_id: Boolean!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input posts_params_prepend_input {
    params: jsonb
}

"input type for updating data in table \"posts_params\""
input posts_params_set_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"Boolean expression to filter rows from the table \"profile\". All fields are combined with a logical 'AND'."
input profile_bool_exp {
    _and: [profile_bool_exp!]
    _not: profile_bool_exp
    _or: [profile_bool_exp!]
    address: String_comparison_exp
    applications_links: application_link_bool_exp
    bio: String_comparison_exp
    blocked_users: user_block_bool_exp
    chain_links: chain_link_bool_exp
    cover_pic: String_comparison_exp
    creation_time: timestamp_comparison_exp
    default_chain_links: default_chain_link_bool_exp
    dtag: String_comparison_exp
    followage: user_relationship_bool_exp
    following: user_relationship_bool_exp
    height: bigint_comparison_exp
    incoming_dtag_transfer_requests: dtag_transfer_requests_bool_exp
    nickname: String_comparison_exp
    outgoing_dtag_transfer_requests: dtag_transfer_requests_bool_exp
    profile_pic: String_comparison_exp
    user_blocks: user_block_bool_exp
}

"input type for incrementing numeric columns in table \"profile\""
input profile_inc_input {
    height: bigint
}

"input type for inserting data into table \"profile\""
input profile_insert_input {
    address: String
    applications_links: application_link_arr_rel_insert_input
    bio: String
    blocked_users: user_block_arr_rel_insert_input
    chain_links: chain_link_arr_rel_insert_input
    cover_pic: String
    creation_time: timestamp
    default_chain_links: default_chain_link_arr_rel_insert_input
    dtag: String
    followage: user_relationship_arr_rel_insert_input
    following: user_relationship_arr_rel_insert_input
    height: bigint
    incoming_dtag_transfer_requests: dtag_transfer_requests_arr_rel_insert_input
    nickname: String
    outgoing_dtag_transfer_requests: dtag_transfer_requests_arr_rel_insert_input
    profile_pic: String
    user_blocks: user_block_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"profile\""
input profile_obj_rel_insert_input {
    data: profile_insert_input!
    "on conflict condition"
    on_conflict: profile_on_conflict
}

"on conflict condition type for table \"profile\""
input profile_on_conflict {
    constraint: profile_constraint!
    update_columns: [profile_update_column!]! = []
    where: profile_bool_exp
}

"Ordering options when selecting data from \"profile\"."
input profile_order_by {
    address: order_by
    applications_links_aggregate: application_link_aggregate_order_by
    bio: order_by
    blocked_users_aggregate: user_block_aggregate_order_by
    chain_links_aggregate: chain_link_aggregate_order_by
    cover_pic: order_by
    creation_time: order_by
    default_chain_links_aggregate: default_chain_link_aggregate_order_by
    dtag: order_by
    followage_aggregate: user_relationship_aggregate_order_by
    following_aggregate: user_relationship_aggregate_order_by
    height: order_by
    incoming_dtag_transfer_requests_aggregate: dtag_transfer_requests_aggregate_order_by
    nickname: order_by
    outgoing_dtag_transfer_requests_aggregate: dtag_transfer_requests_aggregate_order_by
    profile_pic: order_by
    user_blocks_aggregate: user_block_aggregate_order_by
}

"primary key columns input for table: profile"
input profile_pk_columns_input {
    address: String!
}

"input type for updating data in table \"profile\""
input profile_set_input {
    address: String
    bio: String
    cover_pic: String
    creation_time: timestamp
    dtag: String
    height: bigint
    nickname: String
    profile_pic: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input profiles_params_append_input {
    params: jsonb
}

"Boolean expression to filter rows from the table \"profiles_params\". All fields are combined with a logical 'AND'."
input profiles_params_bool_exp {
    _and: [profiles_params_bool_exp!]
    _not: profiles_params_bool_exp
    _or: [profiles_params_bool_exp!]
    height: bigint_comparison_exp
    one_row_id: Boolean_comparison_exp
    params: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input profiles_params_delete_at_path_input {
    params: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input profiles_params_delete_elem_input {
    params: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input profiles_params_delete_key_input {
    params: String
}

"input type for incrementing numeric columns in table \"profiles_params\""
input profiles_params_inc_input {
    height: bigint
}

"input type for inserting data into table \"profiles_params\""
input profiles_params_insert_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"on conflict condition type for table \"profiles_params\""
input profiles_params_on_conflict {
    constraint: profiles_params_constraint!
    update_columns: [profiles_params_update_column!]! = []
    where: profiles_params_bool_exp
}

"Ordering options when selecting data from \"profiles_params\"."
input profiles_params_order_by {
    height: order_by
    one_row_id: order_by
    params: order_by
}

"primary key columns input for table: profiles_params"
input profiles_params_pk_columns_input {
    one_row_id: Boolean!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input profiles_params_prepend_input {
    params: jsonb
}

"input type for updating data in table \"profiles_params\""
input profiles_params_set_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"order by aggregate values of table \"reaction\""
input reaction_aggregate_order_by {
    avg: reaction_avg_order_by
    count: order_by
    max: reaction_max_order_by
    min: reaction_min_order_by
    stddev: reaction_stddev_order_by
    stddev_pop: reaction_stddev_pop_order_by
    stddev_samp: reaction_stddev_samp_order_by
    sum: reaction_sum_order_by
    var_pop: reaction_var_pop_order_by
    var_samp: reaction_var_samp_order_by
    variance: reaction_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input reaction_append_input {
    value: jsonb
}

"input type for inserting array relation for remote table \"reaction\""
input reaction_arr_rel_insert_input {
    data: [reaction_insert_input!]!
    "on conflict condition"
    on_conflict: reaction_on_conflict
}

"order by avg() on columns of table \"reaction\""
input reaction_avg_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"reaction\". All fields are combined with a logical 'AND'."
input reaction_bool_exp {
    _and: [reaction_bool_exp!]
    _not: reaction_bool_exp
    _or: [reaction_bool_exp!]
    author: profile_bool_exp
    author_address: String_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    row_id: Int_comparison_exp
    value: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input reaction_delete_at_path_input {
    value: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input reaction_delete_elem_input {
    value: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input reaction_delete_key_input {
    value: String
}

"input type for incrementing numeric columns in table \"reaction\""
input reaction_inc_input {
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
}

"input type for inserting data into table \"reaction\""
input reaction_insert_input {
    author: profile_obj_rel_insert_input
    author_address: String
    height: bigint
    id: bigint
    post: post_obj_rel_insert_input
    post_row_id: bigint
    row_id: Int
    value: jsonb
}

"order by max() on columns of table \"reaction\""
input reaction_max_order_by {
    author_address: order_by
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by min() on columns of table \"reaction\""
input reaction_min_order_by {
    author_address: order_by
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"on conflict condition type for table \"reaction\""
input reaction_on_conflict {
    constraint: reaction_constraint!
    update_columns: [reaction_update_column!]! = []
    where: reaction_bool_exp
}

"Ordering options when selecting data from \"reaction\"."
input reaction_order_by {
    author: profile_order_by
    author_address: order_by
    height: order_by
    id: order_by
    post: post_order_by
    post_row_id: order_by
    row_id: order_by
    value: order_by
}

"primary key columns input for table: reaction"
input reaction_pk_columns_input {
    row_id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input reaction_prepend_input {
    value: jsonb
}

"input type for updating data in table \"reaction\""
input reaction_set_input {
    author_address: String
    height: bigint
    id: bigint
    post_row_id: bigint
    row_id: Int
    value: jsonb
}

"order by stddev() on columns of table \"reaction\""
input reaction_stddev_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"reaction\""
input reaction_stddev_pop_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"reaction\""
input reaction_stddev_samp_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by sum() on columns of table \"reaction\""
input reaction_sum_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"reaction\""
input reaction_var_pop_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"reaction\""
input reaction_var_samp_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by variance() on columns of table \"reaction\""
input reaction_variance_order_by {
    height: order_by
    id: order_by
    post_row_id: order_by
    row_id: order_by
}

"order by aggregate values of table \"report\""
input report_aggregate_order_by {
    avg: report_avg_order_by
    count: order_by
    max: report_max_order_by
    min: report_min_order_by
    stddev: report_stddev_order_by
    stddev_pop: report_stddev_pop_order_by
    stddev_samp: report_stddev_samp_order_by
    sum: report_sum_order_by
    var_pop: report_var_pop_order_by
    var_samp: report_var_samp_order_by
    variance: report_variance_order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input report_append_input {
    target: jsonb
}

"input type for inserting array relation for remote table \"report\""
input report_arr_rel_insert_input {
    data: [report_insert_input!]!
    "on conflict condition"
    on_conflict: report_on_conflict
}

"order by avg() on columns of table \"report\""
input report_avg_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"report\". All fields are combined with a logical 'AND'."
input report_bool_exp {
    _and: [report_bool_exp!]
    _not: report_bool_exp
    _or: [report_bool_exp!]
    creation_date: timestamp_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    message: String_comparison_exp
    reasons: report_reason_bool_exp
    reporter_address: String_comparison_exp
    row_id: Int_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
    target: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input report_delete_at_path_input {
    target: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input report_delete_elem_input {
    target: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input report_delete_key_input {
    target: String
}

"input type for incrementing numeric columns in table \"report\""
input report_inc_input {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"input type for inserting data into table \"report\""
input report_insert_input {
    creation_date: timestamp
    height: bigint
    id: bigint
    message: String
    reasons: report_reason_arr_rel_insert_input
    reporter_address: String
    row_id: Int
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
    target: jsonb
}

"order by max() on columns of table \"report\""
input report_max_order_by {
    creation_date: order_by
    height: order_by
    id: order_by
    message: order_by
    reporter_address: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"report\""
input report_min_order_by {
    creation_date: order_by
    height: order_by
    id: order_by
    message: order_by
    reporter_address: order_by
    row_id: order_by
    subspace_id: order_by
}

"input type for inserting object relation for remote table \"report\""
input report_obj_rel_insert_input {
    data: report_insert_input!
    "on conflict condition"
    on_conflict: report_on_conflict
}

"on conflict condition type for table \"report\""
input report_on_conflict {
    constraint: report_constraint!
    update_columns: [report_update_column!]! = []
    where: report_bool_exp
}

"Ordering options when selecting data from \"report\"."
input report_order_by {
    creation_date: order_by
    height: order_by
    id: order_by
    message: order_by
    reasons_aggregate: report_reason_aggregate_order_by
    reporter_address: order_by
    row_id: order_by
    subspace: subspace_order_by
    subspace_id: order_by
    target: order_by
}

"primary key columns input for table: report"
input report_pk_columns_input {
    row_id: Int!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input report_prepend_input {
    target: jsonb
}

"order by aggregate values of table \"report_reason\""
input report_reason_aggregate_order_by {
    avg: report_reason_avg_order_by
    count: order_by
    max: report_reason_max_order_by
    min: report_reason_min_order_by
    stddev: report_reason_stddev_order_by
    stddev_pop: report_reason_stddev_pop_order_by
    stddev_samp: report_reason_stddev_samp_order_by
    sum: report_reason_sum_order_by
    var_pop: report_reason_var_pop_order_by
    var_samp: report_reason_var_samp_order_by
    variance: report_reason_variance_order_by
}

"input type for inserting array relation for remote table \"report_reason\""
input report_reason_arr_rel_insert_input {
    data: [report_reason_insert_input!]!
    "on conflict condition"
    on_conflict: report_reason_on_conflict
}

"order by avg() on columns of table \"report_reason\""
input report_reason_avg_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"Boolean expression to filter rows from the table \"report_reason\". All fields are combined with a logical 'AND'."
input report_reason_bool_exp {
    _and: [report_reason_bool_exp!]
    _not: report_reason_bool_exp
    _or: [report_reason_bool_exp!]
    reason: subspace_report_reason_bool_exp
    reason_row_id: bigint_comparison_exp
    report: report_bool_exp
    report_row_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"report_reason\""
input report_reason_inc_input {
    reason_row_id: bigint
    report_row_id: bigint
}

"input type for inserting data into table \"report_reason\""
input report_reason_insert_input {
    reason: subspace_report_reason_obj_rel_insert_input
    reason_row_id: bigint
    report: report_obj_rel_insert_input
    report_row_id: bigint
}

"order by max() on columns of table \"report_reason\""
input report_reason_max_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by min() on columns of table \"report_reason\""
input report_reason_min_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"on conflict condition type for table \"report_reason\""
input report_reason_on_conflict {
    constraint: report_reason_constraint!
    update_columns: [report_reason_update_column!]! = []
    where: report_reason_bool_exp
}

"Ordering options when selecting data from \"report_reason\"."
input report_reason_order_by {
    reason: subspace_report_reason_order_by
    reason_row_id: order_by
    report: report_order_by
    report_row_id: order_by
}

"input type for updating data in table \"report_reason\""
input report_reason_set_input {
    reason_row_id: bigint
    report_row_id: bigint
}

"order by stddev() on columns of table \"report_reason\""
input report_reason_stddev_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by stddev_pop() on columns of table \"report_reason\""
input report_reason_stddev_pop_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by stddev_samp() on columns of table \"report_reason\""
input report_reason_stddev_samp_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by sum() on columns of table \"report_reason\""
input report_reason_sum_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by var_pop() on columns of table \"report_reason\""
input report_reason_var_pop_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by var_samp() on columns of table \"report_reason\""
input report_reason_var_samp_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"order by variance() on columns of table \"report_reason\""
input report_reason_variance_order_by {
    reason_row_id: order_by
    report_row_id: order_by
}

"input type for updating data in table \"report\""
input report_set_input {
    creation_date: timestamp
    height: bigint
    id: bigint
    message: String
    reporter_address: String
    row_id: Int
    subspace_id: bigint
    target: jsonb
}

"order by stddev() on columns of table \"report\""
input report_stddev_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"report\""
input report_stddev_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"report\""
input report_stddev_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"report\""
input report_sum_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"report\""
input report_var_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"report\""
input report_var_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"report\""
input report_variance_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"append existing jsonb value of filtered columns with new jsonb value"
input reports_params_append_input {
    params: jsonb
}

"Boolean expression to filter rows from the table \"reports_params\". All fields are combined with a logical 'AND'."
input reports_params_bool_exp {
    _and: [reports_params_bool_exp!]
    _not: reports_params_bool_exp
    _or: [reports_params_bool_exp!]
    height: bigint_comparison_exp
    one_row_id: Boolean_comparison_exp
    params: jsonb_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input reports_params_delete_at_path_input {
    params: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input reports_params_delete_elem_input {
    params: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input reports_params_delete_key_input {
    params: String
}

"input type for incrementing numeric columns in table \"reports_params\""
input reports_params_inc_input {
    height: bigint
}

"input type for inserting data into table \"reports_params\""
input reports_params_insert_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"on conflict condition type for table \"reports_params\""
input reports_params_on_conflict {
    constraint: reports_params_constraint!
    update_columns: [reports_params_update_column!]! = []
    where: reports_params_bool_exp
}

"Ordering options when selecting data from \"reports_params\"."
input reports_params_order_by {
    height: order_by
    one_row_id: order_by
    params: order_by
}

"primary key columns input for table: reports_params"
input reports_params_pk_columns_input {
    one_row_id: Boolean!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input reports_params_prepend_input {
    params: jsonb
}

"input type for updating data in table \"reports_params\""
input reports_params_set_input {
    height: bigint
    one_row_id: Boolean
    params: jsonb
}

"Boolean expression to filter rows from the table \"subspace\". All fields are combined with a logical 'AND'."
input subspace_bool_exp {
    _and: [subspace_bool_exp!]
    _not: subspace_bool_exp
    _or: [subspace_bool_exp!]
    creation_time: timestamp_comparison_exp
    creator_address: String_comparison_exp
    description: String_comparison_exp
    free_text_reactions_params: subspace_free_text_params_bool_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    name: String_comparison_exp
    owner_address: String_comparison_exp
    posts: post_bool_exp
    registered_reactions: subspace_registered_reaction_bool_exp
    registered_reactions_params: subspace_registered_reaction_params_bool_exp
    report_reasons: subspace_report_reason_bool_exp
    reports: report_bool_exp
    sections: subspace_section_bool_exp
    tip_posts: tip_post_bool_exp
    tip_users: tip_user_bool_exp
    treasury_address: String_comparison_exp
    user_blocks: user_block_bool_exp
    user_groups: subspace_user_group_bool_exp
    user_relationships: user_relationship_bool_exp
}

"Boolean expression to filter rows from the table \"subspace_free_text_params\". All fields are combined with a logical 'AND'."
input subspace_free_text_params_bool_exp {
    _and: [subspace_free_text_params_bool_exp!]
    _not: subspace_free_text_params_bool_exp
    _or: [subspace_free_text_params_bool_exp!]
    enabled: Boolean_comparison_exp
    height: bigint_comparison_exp
    max_length: bigint_comparison_exp
    reg_ex: String_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_free_text_params\""
input subspace_free_text_params_inc_input {
    height: bigint
    max_length: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_free_text_params\""
input subspace_free_text_params_insert_input {
    enabled: Boolean
    height: bigint
    max_length: bigint
    reg_ex: String
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"input type for inserting object relation for remote table \"subspace_free_text_params\""
input subspace_free_text_params_obj_rel_insert_input {
    data: subspace_free_text_params_insert_input!
    "on conflict condition"
    on_conflict: subspace_free_text_params_on_conflict
}

"on conflict condition type for table \"subspace_free_text_params\""
input subspace_free_text_params_on_conflict {
    constraint: subspace_free_text_params_constraint!
    update_columns: [subspace_free_text_params_update_column!]! = []
    where: subspace_free_text_params_bool_exp
}

"Ordering options when selecting data from \"subspace_free_text_params\"."
input subspace_free_text_params_order_by {
    enabled: order_by
    height: order_by
    max_length: order_by
    reg_ex: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"primary key columns input for table: subspace_free_text_params"
input subspace_free_text_params_pk_columns_input {
    subspace_id: bigint!
}

"input type for updating data in table \"subspace_free_text_params\""
input subspace_free_text_params_set_input {
    enabled: Boolean
    height: bigint
    max_length: bigint
    reg_ex: String
    subspace_id: bigint
}

"input type for incrementing numeric columns in table \"subspace\""
input subspace_inc_input {
    height: bigint
    id: bigint
}

"input type for inserting data into table \"subspace\""
input subspace_insert_input {
    creation_time: timestamp
    creator_address: String
    description: String
    free_text_reactions_params: subspace_free_text_params_obj_rel_insert_input
    height: bigint
    id: bigint
    name: String
    owner_address: String
    posts: post_arr_rel_insert_input
    registered_reactions: subspace_registered_reaction_arr_rel_insert_input
    registered_reactions_params: subspace_registered_reaction_params_obj_rel_insert_input
    report_reasons: subspace_report_reason_arr_rel_insert_input
    reports: report_arr_rel_insert_input
    sections: subspace_section_arr_rel_insert_input
    tip_posts: tip_post_arr_rel_insert_input
    tip_users: tip_user_arr_rel_insert_input
    treasury_address: String
    user_blocks: user_block_arr_rel_insert_input
    user_groups: subspace_user_group_arr_rel_insert_input
    user_relationships: user_relationship_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"subspace\""
input subspace_obj_rel_insert_input {
    data: subspace_insert_input!
    "on conflict condition"
    on_conflict: subspace_on_conflict
}

"on conflict condition type for table \"subspace\""
input subspace_on_conflict {
    constraint: subspace_constraint!
    update_columns: [subspace_update_column!]! = []
    where: subspace_bool_exp
}

"Ordering options when selecting data from \"subspace\"."
input subspace_order_by {
    creation_time: order_by
    creator_address: order_by
    description: order_by
    free_text_reactions_params: subspace_free_text_params_order_by
    height: order_by
    id: order_by
    name: order_by
    owner_address: order_by
    posts_aggregate: post_aggregate_order_by
    registered_reactions_aggregate: subspace_registered_reaction_aggregate_order_by
    registered_reactions_params: subspace_registered_reaction_params_order_by
    report_reasons_aggregate: subspace_report_reason_aggregate_order_by
    reports_aggregate: report_aggregate_order_by
    sections_aggregate: subspace_section_aggregate_order_by
    tip_posts_aggregate: tip_post_aggregate_order_by
    tip_users_aggregate: tip_user_aggregate_order_by
    treasury_address: order_by
    user_blocks_aggregate: user_block_aggregate_order_by
    user_groups_aggregate: subspace_user_group_aggregate_order_by
    user_relationships_aggregate: user_relationship_aggregate_order_by
}

"primary key columns input for table: subspace"
input subspace_pk_columns_input {
    id: bigint!
}

"order by aggregate values of table \"subspace_registered_reaction\""
input subspace_registered_reaction_aggregate_order_by {
    avg: subspace_registered_reaction_avg_order_by
    count: order_by
    max: subspace_registered_reaction_max_order_by
    min: subspace_registered_reaction_min_order_by
    stddev: subspace_registered_reaction_stddev_order_by
    stddev_pop: subspace_registered_reaction_stddev_pop_order_by
    stddev_samp: subspace_registered_reaction_stddev_samp_order_by
    sum: subspace_registered_reaction_sum_order_by
    var_pop: subspace_registered_reaction_var_pop_order_by
    var_samp: subspace_registered_reaction_var_samp_order_by
    variance: subspace_registered_reaction_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_registered_reaction\""
input subspace_registered_reaction_arr_rel_insert_input {
    data: [subspace_registered_reaction_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_registered_reaction_on_conflict
}

"order by avg() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_avg_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_registered_reaction\". All fields are combined with a logical 'AND'."
input subspace_registered_reaction_bool_exp {
    _and: [subspace_registered_reaction_bool_exp!]
    _not: subspace_registered_reaction_bool_exp
    _or: [subspace_registered_reaction_bool_exp!]
    display_value: String_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    row_id: Int_comparison_exp
    shorthand_code: String_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_registered_reaction\""
input subspace_registered_reaction_inc_input {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_registered_reaction\""
input subspace_registered_reaction_insert_input {
    display_value: String
    height: bigint
    id: bigint
    row_id: Int
    shorthand_code: String
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_max_order_by {
    display_value: order_by
    height: order_by
    id: order_by
    row_id: order_by
    shorthand_code: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_min_order_by {
    display_value: order_by
    height: order_by
    id: order_by
    row_id: order_by
    shorthand_code: order_by
    subspace_id: order_by
}

"on conflict condition type for table \"subspace_registered_reaction\""
input subspace_registered_reaction_on_conflict {
    constraint: subspace_registered_reaction_constraint!
    update_columns: [subspace_registered_reaction_update_column!]! = []
    where: subspace_registered_reaction_bool_exp
}

"Ordering options when selecting data from \"subspace_registered_reaction\"."
input subspace_registered_reaction_order_by {
    display_value: order_by
    height: order_by
    id: order_by
    row_id: order_by
    shorthand_code: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_registered_reaction_params\". All fields are combined with a logical 'AND'."
input subspace_registered_reaction_params_bool_exp {
    _and: [subspace_registered_reaction_params_bool_exp!]
    _not: subspace_registered_reaction_params_bool_exp
    _or: [subspace_registered_reaction_params_bool_exp!]
    enabled: Boolean_comparison_exp
    height: bigint_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_registered_reaction_params\""
input subspace_registered_reaction_params_inc_input {
    height: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_registered_reaction_params\""
input subspace_registered_reaction_params_insert_input {
    enabled: Boolean
    height: bigint
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"input type for inserting object relation for remote table \"subspace_registered_reaction_params\""
input subspace_registered_reaction_params_obj_rel_insert_input {
    data: subspace_registered_reaction_params_insert_input!
    "on conflict condition"
    on_conflict: subspace_registered_reaction_params_on_conflict
}

"on conflict condition type for table \"subspace_registered_reaction_params\""
input subspace_registered_reaction_params_on_conflict {
    constraint: subspace_registered_reaction_params_constraint!
    update_columns: [subspace_registered_reaction_params_update_column!]! = []
    where: subspace_registered_reaction_params_bool_exp
}

"Ordering options when selecting data from \"subspace_registered_reaction_params\"."
input subspace_registered_reaction_params_order_by {
    enabled: order_by
    height: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"primary key columns input for table: subspace_registered_reaction_params"
input subspace_registered_reaction_params_pk_columns_input {
    subspace_id: bigint!
}

"input type for updating data in table \"subspace_registered_reaction_params\""
input subspace_registered_reaction_params_set_input {
    enabled: Boolean
    height: bigint
    subspace_id: bigint
}

"primary key columns input for table: subspace_registered_reaction"
input subspace_registered_reaction_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"subspace_registered_reaction\""
input subspace_registered_reaction_set_input {
    display_value: String
    height: bigint
    id: bigint
    row_id: Int
    shorthand_code: String
    subspace_id: bigint
}

"order by stddev() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_stddev_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_stddev_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_stddev_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_sum_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_var_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_var_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"subspace_registered_reaction\""
input subspace_registered_reaction_variance_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"subspace_report_reason\""
input subspace_report_reason_aggregate_order_by {
    avg: subspace_report_reason_avg_order_by
    count: order_by
    max: subspace_report_reason_max_order_by
    min: subspace_report_reason_min_order_by
    stddev: subspace_report_reason_stddev_order_by
    stddev_pop: subspace_report_reason_stddev_pop_order_by
    stddev_samp: subspace_report_reason_stddev_samp_order_by
    sum: subspace_report_reason_sum_order_by
    var_pop: subspace_report_reason_var_pop_order_by
    var_samp: subspace_report_reason_var_samp_order_by
    variance: subspace_report_reason_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_report_reason\""
input subspace_report_reason_arr_rel_insert_input {
    data: [subspace_report_reason_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_report_reason_on_conflict
}

"order by avg() on columns of table \"subspace_report_reason\""
input subspace_report_reason_avg_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_report_reason\". All fields are combined with a logical 'AND'."
input subspace_report_reason_bool_exp {
    _and: [subspace_report_reason_bool_exp!]
    _not: subspace_report_reason_bool_exp
    _or: [subspace_report_reason_bool_exp!]
    description: String_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    report_reasons: report_reason_bool_exp
    row_id: Int_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
    title: String_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_report_reason\""
input subspace_report_reason_inc_input {
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_report_reason\""
input subspace_report_reason_insert_input {
    description: String
    height: bigint
    id: bigint
    report_reasons: report_reason_arr_rel_insert_input
    row_id: Int
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
    title: String
}

"order by max() on columns of table \"subspace_report_reason\""
input subspace_report_reason_max_order_by {
    description: order_by
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
    title: order_by
}

"order by min() on columns of table \"subspace_report_reason\""
input subspace_report_reason_min_order_by {
    description: order_by
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
    title: order_by
}

"input type for inserting object relation for remote table \"subspace_report_reason\""
input subspace_report_reason_obj_rel_insert_input {
    data: subspace_report_reason_insert_input!
    "on conflict condition"
    on_conflict: subspace_report_reason_on_conflict
}

"on conflict condition type for table \"subspace_report_reason\""
input subspace_report_reason_on_conflict {
    constraint: subspace_report_reason_constraint!
    update_columns: [subspace_report_reason_update_column!]! = []
    where: subspace_report_reason_bool_exp
}

"Ordering options when selecting data from \"subspace_report_reason\"."
input subspace_report_reason_order_by {
    description: order_by
    height: order_by
    id: order_by
    report_reasons_aggregate: report_reason_aggregate_order_by
    row_id: order_by
    subspace: subspace_order_by
    subspace_id: order_by
    title: order_by
}

"primary key columns input for table: subspace_report_reason"
input subspace_report_reason_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"subspace_report_reason\""
input subspace_report_reason_set_input {
    description: String
    height: bigint
    id: bigint
    row_id: Int
    subspace_id: bigint
    title: String
}

"order by stddev() on columns of table \"subspace_report_reason\""
input subspace_report_reason_stddev_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_report_reason\""
input subspace_report_reason_stddev_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_report_reason\""
input subspace_report_reason_stddev_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"subspace_report_reason\""
input subspace_report_reason_sum_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"subspace_report_reason\""
input subspace_report_reason_var_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"subspace_report_reason\""
input subspace_report_reason_var_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"subspace_report_reason\""
input subspace_report_reason_variance_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"subspace_section\""
input subspace_section_aggregate_order_by {
    avg: subspace_section_avg_order_by
    count: order_by
    max: subspace_section_max_order_by
    min: subspace_section_min_order_by
    stddev: subspace_section_stddev_order_by
    stddev_pop: subspace_section_stddev_pop_order_by
    stddev_samp: subspace_section_stddev_samp_order_by
    sum: subspace_section_sum_order_by
    var_pop: subspace_section_var_pop_order_by
    var_samp: subspace_section_var_samp_order_by
    variance: subspace_section_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_section\""
input subspace_section_arr_rel_insert_input {
    data: [subspace_section_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_section_on_conflict
}

"order by avg() on columns of table \"subspace_section\""
input subspace_section_avg_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_section\". All fields are combined with a logical 'AND'."
input subspace_section_bool_exp {
    _and: [subspace_section_bool_exp!]
    _not: subspace_section_bool_exp
    _or: [subspace_section_bool_exp!]
    children: subspace_section_bool_exp
    description: String_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    name: String_comparison_exp
    parent: subspace_section_bool_exp
    parent_row_id: bigint_comparison_exp
    posts: post_bool_exp
    row_id: Int_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
    user_groups: subspace_user_group_bool_exp
    user_permissions: subspace_user_permission_bool_exp
}

"input type for incrementing numeric columns in table \"subspace_section\""
input subspace_section_inc_input {
    height: bigint
    id: bigint
    parent_row_id: bigint
    row_id: Int
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_section\""
input subspace_section_insert_input {
    children: subspace_section_arr_rel_insert_input
    description: String
    height: bigint
    id: bigint
    name: String
    parent: subspace_section_obj_rel_insert_input
    parent_row_id: bigint
    posts: post_arr_rel_insert_input
    row_id: Int
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
    user_groups: subspace_user_group_arr_rel_insert_input
    user_permissions: subspace_user_permission_arr_rel_insert_input
}

"order by max() on columns of table \"subspace_section\""
input subspace_section_max_order_by {
    description: order_by
    height: order_by
    id: order_by
    name: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"subspace_section\""
input subspace_section_min_order_by {
    description: order_by
    height: order_by
    id: order_by
    name: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"input type for inserting object relation for remote table \"subspace_section\""
input subspace_section_obj_rel_insert_input {
    data: subspace_section_insert_input!
    "on conflict condition"
    on_conflict: subspace_section_on_conflict
}

"on conflict condition type for table \"subspace_section\""
input subspace_section_on_conflict {
    constraint: subspace_section_constraint!
    update_columns: [subspace_section_update_column!]! = []
    where: subspace_section_bool_exp
}

"Ordering options when selecting data from \"subspace_section\"."
input subspace_section_order_by {
    children_aggregate: subspace_section_aggregate_order_by
    description: order_by
    height: order_by
    id: order_by
    name: order_by
    parent: subspace_section_order_by
    parent_row_id: order_by
    posts_aggregate: post_aggregate_order_by
    row_id: order_by
    subspace: subspace_order_by
    subspace_id: order_by
    user_groups_aggregate: subspace_user_group_aggregate_order_by
    user_permissions_aggregate: subspace_user_permission_aggregate_order_by
}

"primary key columns input for table: subspace_section"
input subspace_section_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"subspace_section\""
input subspace_section_set_input {
    description: String
    height: bigint
    id: bigint
    name: String
    parent_row_id: bigint
    row_id: Int
    subspace_id: bigint
}

"order by stddev() on columns of table \"subspace_section\""
input subspace_section_stddev_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_section\""
input subspace_section_stddev_pop_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_section\""
input subspace_section_stddev_samp_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"subspace_section\""
input subspace_section_sum_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"subspace_section\""
input subspace_section_var_pop_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"subspace_section\""
input subspace_section_var_samp_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"subspace_section\""
input subspace_section_variance_order_by {
    height: order_by
    id: order_by
    parent_row_id: order_by
    row_id: order_by
    subspace_id: order_by
}

"input type for updating data in table \"subspace\""
input subspace_set_input {
    creation_time: timestamp
    creator_address: String
    description: String
    height: bigint
    id: bigint
    name: String
    owner_address: String
    treasury_address: String
}

"order by aggregate values of table \"subspace_user_group\""
input subspace_user_group_aggregate_order_by {
    avg: subspace_user_group_avg_order_by
    count: order_by
    max: subspace_user_group_max_order_by
    min: subspace_user_group_min_order_by
    stddev: subspace_user_group_stddev_order_by
    stddev_pop: subspace_user_group_stddev_pop_order_by
    stddev_samp: subspace_user_group_stddev_samp_order_by
    sum: subspace_user_group_sum_order_by
    var_pop: subspace_user_group_var_pop_order_by
    var_samp: subspace_user_group_var_samp_order_by
    variance: subspace_user_group_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_user_group\""
input subspace_user_group_arr_rel_insert_input {
    data: [subspace_user_group_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_user_group_on_conflict
}

"order by avg() on columns of table \"subspace_user_group\""
input subspace_user_group_avg_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_user_group\". All fields are combined with a logical 'AND'."
input subspace_user_group_bool_exp {
    _and: [subspace_user_group_bool_exp!]
    _not: subspace_user_group_bool_exp
    _or: [subspace_user_group_bool_exp!]
    description: String_comparison_exp
    height: bigint_comparison_exp
    id: bigint_comparison_exp
    members: subspace_user_group_member_bool_exp
    name: String_comparison_exp
    permissions: _text_comparison_exp
    row_id: Int_comparison_exp
    section: subspace_section_bool_exp
    section_row_id: bigint_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_user_group\""
input subspace_user_group_inc_input {
    height: bigint
    id: bigint
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"subspace_user_group\""
input subspace_user_group_insert_input {
    description: String
    height: bigint
    id: bigint
    members: subspace_user_group_member_arr_rel_insert_input
    name: String
    permissions: _text
    row_id: Int
    section: subspace_section_obj_rel_insert_input
    section_row_id: bigint
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"subspace_user_group\""
input subspace_user_group_max_order_by {
    description: order_by
    height: order_by
    id: order_by
    name: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"subspace_user_group_member\""
input subspace_user_group_member_aggregate_order_by {
    avg: subspace_user_group_member_avg_order_by
    count: order_by
    max: subspace_user_group_member_max_order_by
    min: subspace_user_group_member_min_order_by
    stddev: subspace_user_group_member_stddev_order_by
    stddev_pop: subspace_user_group_member_stddev_pop_order_by
    stddev_samp: subspace_user_group_member_stddev_samp_order_by
    sum: subspace_user_group_member_sum_order_by
    var_pop: subspace_user_group_member_var_pop_order_by
    var_samp: subspace_user_group_member_var_samp_order_by
    variance: subspace_user_group_member_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_user_group_member\""
input subspace_user_group_member_arr_rel_insert_input {
    data: [subspace_user_group_member_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_user_group_member_on_conflict
}

"order by avg() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_avg_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_user_group_member\". All fields are combined with a logical 'AND'."
input subspace_user_group_member_bool_exp {
    _and: [subspace_user_group_member_bool_exp!]
    _not: subspace_user_group_member_bool_exp
    _or: [subspace_user_group_member_bool_exp!]
    group: subspace_user_group_bool_exp
    group_row_id: bigint_comparison_exp
    height: bigint_comparison_exp
    member_address: String_comparison_exp
    row_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_user_group_member\""
input subspace_user_group_member_inc_input {
    group_row_id: bigint
    height: bigint
    row_id: Int
}

"input type for inserting data into table \"subspace_user_group_member\""
input subspace_user_group_member_insert_input {
    group: subspace_user_group_obj_rel_insert_input
    group_row_id: bigint
    height: bigint
    member_address: String
    row_id: Int
}

"order by max() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_max_order_by {
    group_row_id: order_by
    height: order_by
    member_address: order_by
    row_id: order_by
}

"order by min() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_min_order_by {
    group_row_id: order_by
    height: order_by
    member_address: order_by
    row_id: order_by
}

"on conflict condition type for table \"subspace_user_group_member\""
input subspace_user_group_member_on_conflict {
    constraint: subspace_user_group_member_constraint!
    update_columns: [subspace_user_group_member_update_column!]! = []
    where: subspace_user_group_member_bool_exp
}

"Ordering options when selecting data from \"subspace_user_group_member\"."
input subspace_user_group_member_order_by {
    group: subspace_user_group_order_by
    group_row_id: order_by
    height: order_by
    member_address: order_by
    row_id: order_by
}

"input type for updating data in table \"subspace_user_group_member\""
input subspace_user_group_member_set_input {
    group_row_id: bigint
    height: bigint
    member_address: String
    row_id: Int
}

"order by stddev() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_stddev_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_stddev_pop_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_stddev_samp_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by sum() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_sum_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by var_pop() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_var_pop_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by var_samp() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_var_samp_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by variance() on columns of table \"subspace_user_group_member\""
input subspace_user_group_member_variance_order_by {
    group_row_id: order_by
    height: order_by
    row_id: order_by
}

"order by min() on columns of table \"subspace_user_group\""
input subspace_user_group_min_order_by {
    description: order_by
    height: order_by
    id: order_by
    name: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"input type for inserting object relation for remote table \"subspace_user_group\""
input subspace_user_group_obj_rel_insert_input {
    data: subspace_user_group_insert_input!
    "on conflict condition"
    on_conflict: subspace_user_group_on_conflict
}

"on conflict condition type for table \"subspace_user_group\""
input subspace_user_group_on_conflict {
    constraint: subspace_user_group_constraint!
    update_columns: [subspace_user_group_update_column!]! = []
    where: subspace_user_group_bool_exp
}

"Ordering options when selecting data from \"subspace_user_group\"."
input subspace_user_group_order_by {
    description: order_by
    height: order_by
    id: order_by
    members_aggregate: subspace_user_group_member_aggregate_order_by
    name: order_by
    permissions: order_by
    row_id: order_by
    section: subspace_section_order_by
    section_row_id: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"primary key columns input for table: subspace_user_group"
input subspace_user_group_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"subspace_user_group\""
input subspace_user_group_set_input {
    description: String
    height: bigint
    id: bigint
    name: String
    permissions: _text
    row_id: Int
    section_row_id: bigint
    subspace_id: bigint
}

"order by stddev() on columns of table \"subspace_user_group\""
input subspace_user_group_stddev_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_user_group\""
input subspace_user_group_stddev_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_user_group\""
input subspace_user_group_stddev_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"subspace_user_group\""
input subspace_user_group_sum_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"subspace_user_group\""
input subspace_user_group_var_pop_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"subspace_user_group\""
input subspace_user_group_var_samp_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"subspace_user_group\""
input subspace_user_group_variance_order_by {
    height: order_by
    id: order_by
    row_id: order_by
    section_row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"subspace_user_permission\""
input subspace_user_permission_aggregate_order_by {
    avg: subspace_user_permission_avg_order_by
    count: order_by
    max: subspace_user_permission_max_order_by
    min: subspace_user_permission_min_order_by
    stddev: subspace_user_permission_stddev_order_by
    stddev_pop: subspace_user_permission_stddev_pop_order_by
    stddev_samp: subspace_user_permission_stddev_samp_order_by
    sum: subspace_user_permission_sum_order_by
    var_pop: subspace_user_permission_var_pop_order_by
    var_samp: subspace_user_permission_var_samp_order_by
    variance: subspace_user_permission_variance_order_by
}

"input type for inserting array relation for remote table \"subspace_user_permission\""
input subspace_user_permission_arr_rel_insert_input {
    data: [subspace_user_permission_insert_input!]!
    "on conflict condition"
    on_conflict: subspace_user_permission_on_conflict
}

"order by avg() on columns of table \"subspace_user_permission\""
input subspace_user_permission_avg_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"Boolean expression to filter rows from the table \"subspace_user_permission\". All fields are combined with a logical 'AND'."
input subspace_user_permission_bool_exp {
    _and: [subspace_user_permission_bool_exp!]
    _not: subspace_user_permission_bool_exp
    _or: [subspace_user_permission_bool_exp!]
    height: bigint_comparison_exp
    permissions: _text_comparison_exp
    row_id: Int_comparison_exp
    section: subspace_section_bool_exp
    section_row_id: bigint_comparison_exp
    user_address: String_comparison_exp
}

"input type for incrementing numeric columns in table \"subspace_user_permission\""
input subspace_user_permission_inc_input {
    height: bigint
    row_id: Int
    section_row_id: bigint
}

"input type for inserting data into table \"subspace_user_permission\""
input subspace_user_permission_insert_input {
    height: bigint
    permissions: _text
    row_id: Int
    section: subspace_section_obj_rel_insert_input
    section_row_id: bigint
    user_address: String
}

"order by max() on columns of table \"subspace_user_permission\""
input subspace_user_permission_max_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
    user_address: order_by
}

"order by min() on columns of table \"subspace_user_permission\""
input subspace_user_permission_min_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
    user_address: order_by
}

"on conflict condition type for table \"subspace_user_permission\""
input subspace_user_permission_on_conflict {
    constraint: subspace_user_permission_constraint!
    update_columns: [subspace_user_permission_update_column!]! = []
    where: subspace_user_permission_bool_exp
}

"Ordering options when selecting data from \"subspace_user_permission\"."
input subspace_user_permission_order_by {
    height: order_by
    permissions: order_by
    row_id: order_by
    section: subspace_section_order_by
    section_row_id: order_by
    user_address: order_by
}

"primary key columns input for table: subspace_user_permission"
input subspace_user_permission_pk_columns_input {
    row_id: Int!
}

"input type for updating data in table \"subspace_user_permission\""
input subspace_user_permission_set_input {
    height: bigint
    permissions: _text
    row_id: Int
    section_row_id: bigint
    user_address: String
}

"order by stddev() on columns of table \"subspace_user_permission\""
input subspace_user_permission_stddev_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by stddev_pop() on columns of table \"subspace_user_permission\""
input subspace_user_permission_stddev_pop_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by stddev_samp() on columns of table \"subspace_user_permission\""
input subspace_user_permission_stddev_samp_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by sum() on columns of table \"subspace_user_permission\""
input subspace_user_permission_sum_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by var_pop() on columns of table \"subspace_user_permission\""
input subspace_user_permission_var_pop_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by var_samp() on columns of table \"subspace_user_permission\""
input subspace_user_permission_var_samp_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"order by variance() on columns of table \"subspace_user_permission\""
input subspace_user_permission_variance_order_by {
    height: order_by
    row_id: order_by
    section_row_id: order_by
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _is_null: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"order by aggregate values of table \"tip_post\""
input tip_post_aggregate_order_by {
    avg: tip_post_avg_order_by
    count: order_by
    max: tip_post_max_order_by
    min: tip_post_min_order_by
    stddev: tip_post_stddev_order_by
    stddev_pop: tip_post_stddev_pop_order_by
    stddev_samp: tip_post_stddev_samp_order_by
    sum: tip_post_sum_order_by
    var_pop: tip_post_var_pop_order_by
    var_samp: tip_post_var_samp_order_by
    variance: tip_post_variance_order_by
}

"input type for inserting array relation for remote table \"tip_post\""
input tip_post_arr_rel_insert_input {
    data: [tip_post_insert_input!]!
    "on conflict condition"
    on_conflict: tip_post_on_conflict
}

"order by avg() on columns of table \"tip_post\""
input tip_post_avg_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"tip_post\". All fields are combined with a logical 'AND'."
input tip_post_bool_exp {
    _and: [tip_post_bool_exp!]
    _not: tip_post_bool_exp
    _or: [tip_post_bool_exp!]
    amount: _coin_comparison_exp
    height: bigint_comparison_exp
    post: post_bool_exp
    post_row_id: bigint_comparison_exp
    sender: profile_bool_exp
    sender_address: String_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"tip_post\""
input tip_post_inc_input {
    height: bigint
    post_row_id: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"tip_post\""
input tip_post_insert_input {
    amount: _coin
    height: bigint
    post: post_obj_rel_insert_input
    post_row_id: bigint
    sender: profile_obj_rel_insert_input
    sender_address: String
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"tip_post\""
input tip_post_max_order_by {
    height: order_by
    post_row_id: order_by
    sender_address: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"tip_post\""
input tip_post_min_order_by {
    height: order_by
    post_row_id: order_by
    sender_address: order_by
    subspace_id: order_by
}

"on conflict condition type for table \"tip_post\""
input tip_post_on_conflict {
    constraint: tip_post_constraint!
    update_columns: [tip_post_update_column!]! = []
    where: tip_post_bool_exp
}

"Ordering options when selecting data from \"tip_post\"."
input tip_post_order_by {
    amount: order_by
    height: order_by
    post: post_order_by
    post_row_id: order_by
    sender: profile_order_by
    sender_address: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"input type for updating data in table \"tip_post\""
input tip_post_set_input {
    amount: _coin
    height: bigint
    post_row_id: bigint
    sender_address: String
    subspace_id: bigint
}

"order by stddev() on columns of table \"tip_post\""
input tip_post_stddev_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"tip_post\""
input tip_post_stddev_pop_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"tip_post\""
input tip_post_stddev_samp_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"tip_post\""
input tip_post_sum_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"tip_post\""
input tip_post_var_pop_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"tip_post\""
input tip_post_var_samp_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"tip_post\""
input tip_post_variance_order_by {
    height: order_by
    post_row_id: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"tip_user\""
input tip_user_aggregate_order_by {
    avg: tip_user_avg_order_by
    count: order_by
    max: tip_user_max_order_by
    min: tip_user_min_order_by
    stddev: tip_user_stddev_order_by
    stddev_pop: tip_user_stddev_pop_order_by
    stddev_samp: tip_user_stddev_samp_order_by
    sum: tip_user_sum_order_by
    var_pop: tip_user_var_pop_order_by
    var_samp: tip_user_var_samp_order_by
    variance: tip_user_variance_order_by
}

"input type for inserting array relation for remote table \"tip_user\""
input tip_user_arr_rel_insert_input {
    data: [tip_user_insert_input!]!
    "on conflict condition"
    on_conflict: tip_user_on_conflict
}

"order by avg() on columns of table \"tip_user\""
input tip_user_avg_order_by {
    height: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"tip_user\". All fields are combined with a logical 'AND'."
input tip_user_bool_exp {
    _and: [tip_user_bool_exp!]
    _not: tip_user_bool_exp
    _or: [tip_user_bool_exp!]
    amount: _coin_comparison_exp
    height: bigint_comparison_exp
    receiver: profile_bool_exp
    receiver_address: String_comparison_exp
    sender: profile_bool_exp
    sender_address: String_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"tip_user\""
input tip_user_inc_input {
    height: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"tip_user\""
input tip_user_insert_input {
    amount: _coin
    height: bigint
    receiver: profile_obj_rel_insert_input
    receiver_address: String
    sender: profile_obj_rel_insert_input
    sender_address: String
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"tip_user\""
input tip_user_max_order_by {
    height: order_by
    receiver_address: order_by
    sender_address: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"tip_user\""
input tip_user_min_order_by {
    height: order_by
    receiver_address: order_by
    sender_address: order_by
    subspace_id: order_by
}

"on conflict condition type for table \"tip_user\""
input tip_user_on_conflict {
    constraint: tip_user_constraint!
    update_columns: [tip_user_update_column!]! = []
    where: tip_user_bool_exp
}

"Ordering options when selecting data from \"tip_user\"."
input tip_user_order_by {
    amount: order_by
    height: order_by
    receiver: profile_order_by
    receiver_address: order_by
    sender: profile_order_by
    sender_address: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"input type for updating data in table \"tip_user\""
input tip_user_set_input {
    amount: _coin
    height: bigint
    receiver_address: String
    sender_address: String
    subspace_id: bigint
}

"order by stddev() on columns of table \"tip_user\""
input tip_user_stddev_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"tip_user\""
input tip_user_stddev_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"tip_user\""
input tip_user_stddev_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"tip_user\""
input tip_user_sum_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"tip_user\""
input tip_user_var_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"tip_user\""
input tip_user_var_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"tip_user\""
input tip_user_variance_order_by {
    height: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"user_block\""
input user_block_aggregate_order_by {
    avg: user_block_avg_order_by
    count: order_by
    max: user_block_max_order_by
    min: user_block_min_order_by
    stddev: user_block_stddev_order_by
    stddev_pop: user_block_stddev_pop_order_by
    stddev_samp: user_block_stddev_samp_order_by
    sum: user_block_sum_order_by
    var_pop: user_block_var_pop_order_by
    var_samp: user_block_var_samp_order_by
    variance: user_block_variance_order_by
}

"input type for inserting array relation for remote table \"user_block\""
input user_block_arr_rel_insert_input {
    data: [user_block_insert_input!]!
    "on conflict condition"
    on_conflict: user_block_on_conflict
}

"order by avg() on columns of table \"user_block\""
input user_block_avg_order_by {
    height: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"user_block\". All fields are combined with a logical 'AND'."
input user_block_bool_exp {
    _and: [user_block_bool_exp!]
    _not: user_block_bool_exp
    _or: [user_block_bool_exp!]
    blocked: profile_bool_exp
    blocked_address: String_comparison_exp
    blocker: profile_bool_exp
    blocker_address: String_comparison_exp
    height: bigint_comparison_exp
    reason: String_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"user_block\""
input user_block_inc_input {
    height: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"user_block\""
input user_block_insert_input {
    blocked: profile_obj_rel_insert_input
    blocked_address: String
    blocker: profile_obj_rel_insert_input
    blocker_address: String
    height: bigint
    reason: String
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"user_block\""
input user_block_max_order_by {
    blocked_address: order_by
    blocker_address: order_by
    height: order_by
    reason: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"user_block\""
input user_block_min_order_by {
    blocked_address: order_by
    blocker_address: order_by
    height: order_by
    reason: order_by
    subspace_id: order_by
}

"on conflict condition type for table \"user_block\""
input user_block_on_conflict {
    constraint: user_block_constraint!
    update_columns: [user_block_update_column!]! = []
    where: user_block_bool_exp
}

"Ordering options when selecting data from \"user_block\"."
input user_block_order_by {
    blocked: profile_order_by
    blocked_address: order_by
    blocker: profile_order_by
    blocker_address: order_by
    height: order_by
    reason: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"input type for updating data in table \"user_block\""
input user_block_set_input {
    blocked_address: String
    blocker_address: String
    height: bigint
    reason: String
    subspace_id: bigint
}

"order by stddev() on columns of table \"user_block\""
input user_block_stddev_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"user_block\""
input user_block_stddev_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"user_block\""
input user_block_stddev_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"user_block\""
input user_block_sum_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"user_block\""
input user_block_var_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"user_block\""
input user_block_var_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"user_block\""
input user_block_variance_order_by {
    height: order_by
    subspace_id: order_by
}

"order by aggregate values of table \"user_relationship\""
input user_relationship_aggregate_order_by {
    avg: user_relationship_avg_order_by
    count: order_by
    max: user_relationship_max_order_by
    min: user_relationship_min_order_by
    stddev: user_relationship_stddev_order_by
    stddev_pop: user_relationship_stddev_pop_order_by
    stddev_samp: user_relationship_stddev_samp_order_by
    sum: user_relationship_sum_order_by
    var_pop: user_relationship_var_pop_order_by
    var_samp: user_relationship_var_samp_order_by
    variance: user_relationship_variance_order_by
}

"input type for inserting array relation for remote table \"user_relationship\""
input user_relationship_arr_rel_insert_input {
    data: [user_relationship_insert_input!]!
    "on conflict condition"
    on_conflict: user_relationship_on_conflict
}

"order by avg() on columns of table \"user_relationship\""
input user_relationship_avg_order_by {
    height: order_by
    subspace_id: order_by
}

"Boolean expression to filter rows from the table \"user_relationship\". All fields are combined with a logical 'AND'."
input user_relationship_bool_exp {
    _and: [user_relationship_bool_exp!]
    _not: user_relationship_bool_exp
    _or: [user_relationship_bool_exp!]
    counterparty: profile_bool_exp
    counterparty_address: String_comparison_exp
    creator: profile_bool_exp
    creator_address: String_comparison_exp
    height: bigint_comparison_exp
    subspace: subspace_bool_exp
    subspace_id: bigint_comparison_exp
}

"input type for incrementing numeric columns in table \"user_relationship\""
input user_relationship_inc_input {
    height: bigint
    subspace_id: bigint
}

"input type for inserting data into table \"user_relationship\""
input user_relationship_insert_input {
    counterparty: profile_obj_rel_insert_input
    counterparty_address: String
    creator: profile_obj_rel_insert_input
    creator_address: String
    height: bigint
    subspace: subspace_obj_rel_insert_input
    subspace_id: bigint
}

"order by max() on columns of table \"user_relationship\""
input user_relationship_max_order_by {
    counterparty_address: order_by
    creator_address: order_by
    height: order_by
    subspace_id: order_by
}

"order by min() on columns of table \"user_relationship\""
input user_relationship_min_order_by {
    counterparty_address: order_by
    creator_address: order_by
    height: order_by
    subspace_id: order_by
}

"on conflict condition type for table \"user_relationship\""
input user_relationship_on_conflict {
    constraint: user_relationship_constraint!
    update_columns: [user_relationship_update_column!]! = []
    where: user_relationship_bool_exp
}

"Ordering options when selecting data from \"user_relationship\"."
input user_relationship_order_by {
    counterparty: profile_order_by
    counterparty_address: order_by
    creator: profile_order_by
    creator_address: order_by
    height: order_by
    subspace: subspace_order_by
    subspace_id: order_by
}

"input type for updating data in table \"user_relationship\""
input user_relationship_set_input {
    counterparty_address: String
    creator_address: String
    height: bigint
    subspace_id: bigint
}

"order by stddev() on columns of table \"user_relationship\""
input user_relationship_stddev_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_pop() on columns of table \"user_relationship\""
input user_relationship_stddev_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by stddev_samp() on columns of table \"user_relationship\""
input user_relationship_stddev_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by sum() on columns of table \"user_relationship\""
input user_relationship_sum_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_pop() on columns of table \"user_relationship\""
input user_relationship_var_pop_order_by {
    height: order_by
    subspace_id: order_by
}

"order by var_samp() on columns of table \"user_relationship\""
input user_relationship_var_samp_order_by {
    height: order_by
    subspace_id: order_by
}

"order by variance() on columns of table \"user_relationship\""
input user_relationship_variance_order_by {
    height: order_by
    subspace_id: order_by
}
